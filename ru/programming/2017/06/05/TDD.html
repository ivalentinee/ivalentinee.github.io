<!DOCTYPE html>
<html lang="ru"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Про TDD | ivalentinee</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Про TDD" />
<meta property="og:locale" content="ru" />
<meta name="description" content="Предисловие Причиной этому посту послужило моё всё более и более религиозное отношение к TDD. Недавно состоялся диалог меня (ivalentinee) и одного моего друга (SomeoneFromTheInternet): ivalentinee: Рекомендую проникнуться духом TDD. SomeoneFromTheInternet: TDD всё-таки требует дисциплины. ivalentinee: Ни в коем случае не пропагандирую абсолютный TDD. ivalentinee: Но попробовать стоит, потому что заставляет задумываться о коде “с другой стороны”. SomeoneFromTheInternet: Думаю, что надо просто при описании логики писать тесты. SomeoneFromTheInternet: Типа думать, где наебнётся и что лучше бы это проверить. Это только один пример из многих. Я уже много раз сталкивался с тем, что люди понимают TDD неправильно не так, как я. Заранее надо предупредить о трёх вещах: Это моё понимание TDD. Не претендую на истину. Я же не какой-нибудь там Боб Мартин. Описываемое мной понимание TDD является утрированным и извращённым. В реальной жизни грань между “правильным” и “неправильным” TDD размывается до неразличимости. Писать примеры буду на псевдокоде русскими словами. И буду склонять названия. Потому что могу, вот почему. Что ж, поехали. Что такое TDD Как следует из расшифровки аббревиатуры TDD — Test Driven Development. По-русски это будет примерно «Разработка через тестирование». Так вот, самое важное слово в данном случае не “тестирование” (которое стоит на последнем месте), а “разработка” (которое стоит на первом месте). Из вышесказанного вытекает следующий неочевидный вывод: TDD это не про тестирование, а про разработку, про написание кода. Приведу для красного словца известное описание TDD: Красный Зелёный Рефакторинг Отмечу, что данный сценарий является циклическим. Какие проблемы не решает TDD Гарантированная безошибочность приложения. Гарантированное покрытие тестами &gt; n%. Эти проблемы, конечно, решаются TDD, но по чистой случайности. Сама по себе методология была создана не для этого Какие проблемы решает TDD Изолированность написания модулей приложения. Скорость написания кода. Чуть ниже все четыре пункта рассмотрю подробнее, а пока опишу модель TDD. Модель TDD Начинать описание нужно с того же, с чего нужно начинать описание и всего остального в мире разработки: с проблемы. Итак, предположим, что у нас есть некоторое готовое приложение. И тут к нам приходит заказчик/начальник/уборщица/кто-угодно и говорит: “нам нужно, чтобы приложение делало ещё вот_это_вот”. Далее любой человек в здравом уме будет всеми способами доказывать глупость идеи заказчика/начальника/уборщицы/кого-угодно. Но для чистоты описания я вынужден предположить, что этот пункт с грохотом провалился. То есть надо что-то сделать. Для удобства предположим, что часть нашего нового функционала в конечном итоге упирается в получение результата по входным аргументам. То есть для всей области определения входных аргументов определена функция, возвращающая результат, соответствующий необходимым критериям. Разберём на примере выбора самого высокого человека из предоставленного ряда. Человек будет объектом со свойством рост. Сильно утрированный сценарий, но так будет проще. Красная фаза Тут надо крепко задуматься. Ибо предстоит решить “а что мы всё-таки в результате-то хотим”? Ответ на этот вопрос и является решением красной фазы. На примере человека становится ясно, что мы пишем такое требование: Из всего ряда людей нам нужно выбрать единственного человека таким образом, чтобы рост всех остальных был меньше или равен росту выбранного человека. Справедливое требование, не правда ли? Так как это требование является уже достаточно формализованным, то написание контракта в терминах выбранного ЯП становится очевидной операцией: РЯД = РядСлучайныхЛюдей; САМЫЙ_ВЫСОКИЙ_ЧЕЛОВЕК = выбратьСамогоВысокогоЧеловека(РЯД) для каждого ВЫБРАННОГО_ЧЕЛОВЕКА из РЯДА: если рост(ВЫБРАННОГО_ЧЕЛОВЕКА) &gt; рост(САМОГО_ВЫСОКОГО_ЧЕЛОВЕКА) то провалитьТест Очевидное преобразование, не так ли? С этого момента у программиста есть формализованный контракт к самому себе на написание кода, который в отвечает на вопрос: “Мы написали то что хотели, или нет?” До сих пор мы не написали ни строки кода реализации. Красная фаза пройдена. Почему красная? Потому что проверка нашего кода по контракту выдаёт отрицательный — “красный” — результат. Зелёная фаза И в этой фазе нужно выполнить написанный контракт. Нужно написать решение. Какое это будет решение — не очень-то и важно, на самом деле. Но приведу примерный псевдокод: определение: выбратьСамогоВысокогоЧеловека(РЯД) выбратьПервыйЭлемент(отсортироватьПузырьком(РЯД)) Контракт программиста самому себе выполнен. Зелёная фаза пройдена. Почему зелёная? Потому что проверка нашего кода по контракту выдаёт положительный — “зелёный” — результат. Рефакторинг На данном этапе нужно улучшать качественные характеристики кода. Например оптимизация, оформление, внутренняя декомпозиция и прочее. Важно то, что на данном этапе не изменяется ни контракт, ни сам факт его выполнения. Изменяется только способ его выполнения. Например, изменяем нашу реализацию таким образом: определение: выбратьСамогоВысокогоЧеловека(РЯД) отсортированыйРяд = отсортироватьДвоичнойСортировкой(РЯД) выбратьПервыйЭлемент(отсортированыйРяд) Написанный контракт позволяет программисту в любой момент проверить его выполнение, что делает рефакторинг безопасным. Эта фаза может совмещаться с code review, например, если это необходимо. Фаза рефакторинга пройдена. Что это нам даёт и чего не даёт (вышеупомянутые четыре пункта) Изолированность написания модулей приложения Такой способ написания кода позволяет проверять и реализовывать необходимый функционал. Контракт проверяет выполнение только выбраной нами функции и никакой другой. И не зависит от работы других функций. Скорость написания кода Для проверки реализации во время написания кода нет необходимости запускать всё приложение и руками проверять. Нет также необходимости подготавливать данные для проверки, потому как их подготовкой также занимается код контракта. Всё автоматизированно и потому быстро. Гарантированная безошибочность приложения Конечно, из описания выше можно сделать ложный вывод о том, что при наличии контрактов на весь функционал будет гарантия работоспособности приложения. Но это не так, увы. Мы живём в реальном мире. А это значит, что есть две большие проблемы: Невозможно составить полный контракт на всю область определения. Внешние зависимости не обязаны отвечать требованиям контрактов приложения. Про это я ещё чуть подробнее напишу в “советах”. Гарантированное покрытие тестами &gt; n%. Следует из пункта выше. Реальных сценариев слишком много, чтобы их можно было описать и при этом иметь поддерживаемую систему. Про это тоже будет в советах. Небольшой список советов (в том числе основанных на личном опыте) Не надо пытаться писать контракты на любой сценарий. Опишите только на минимально-необходимый. И уточняйте контракт только в том случае, если есть зафиксированный баг. Не надо определять контракты для внешних зависимостей. Контракт, который проверяет dnslookup(googleDNS) не только бессмысленнен, но и вреден. Ибо будет ломаться тогда, когда приложение будет работать. Отсюда следует следующий совет: Изолируйте свои контракты. Если внутри себя функция А вызывает достаточно сложную (и ненадёжную) функцию Б из какого-то другого модуля — применяйте stub. Если нужен какой-то сложный (и ненадёжный) объект для проверки — применяйте mock-объект. Не ленитесь описывать подготовку данных для каждой проверки заново. Один из примеров библиотек для изоляции тестов — webmock — мой спаситель в очень многих ситуациях. Не пишите большие и сложные контракты. Лучше их декомпозировать. Если есть, например, две проверки на разное поведение одной функции, то это два теста, а не один с двумя проверками. Когда наберётесь опыта, можно будет в фазу рефакторинга включить не только рефакторинг кода, но и рефакторинг контракта. Правда, делать это надо осторожно и последовательно: сначала полностью заканчиваете рефакторинг кода, а потом уже рефакторите контракт. Оставьте регрессионные и интеграционные тесты команде тестирования. Потому что писать код с помощью интеграционных тестов (в том числе всякие зашкварные капибары и phantomjs’ы) — это адЪ (есть личный опыт). К тому же это будет лишней тратой времени, никак не связанной с написанием кода приложения. Набросы (будет со временем обновляться, я надеюсь) О чрезмерном тестировании BDD: RSpec, Cucumber Тестирование серого ящика Stub и Mock Великий webmock-спаситель — позволяет сделать некрасивые stub’ы для сторонних API." />
<meta property="og:description" content="Предисловие Причиной этому посту послужило моё всё более и более религиозное отношение к TDD. Недавно состоялся диалог меня (ivalentinee) и одного моего друга (SomeoneFromTheInternet): ivalentinee: Рекомендую проникнуться духом TDD. SomeoneFromTheInternet: TDD всё-таки требует дисциплины. ivalentinee: Ни в коем случае не пропагандирую абсолютный TDD. ivalentinee: Но попробовать стоит, потому что заставляет задумываться о коде “с другой стороны”. SomeoneFromTheInternet: Думаю, что надо просто при описании логики писать тесты. SomeoneFromTheInternet: Типа думать, где наебнётся и что лучше бы это проверить. Это только один пример из многих. Я уже много раз сталкивался с тем, что люди понимают TDD неправильно не так, как я. Заранее надо предупредить о трёх вещах: Это моё понимание TDD. Не претендую на истину. Я же не какой-нибудь там Боб Мартин. Описываемое мной понимание TDD является утрированным и извращённым. В реальной жизни грань между “правильным” и “неправильным” TDD размывается до неразличимости. Писать примеры буду на псевдокоде русскими словами. И буду склонять названия. Потому что могу, вот почему. Что ж, поехали. Что такое TDD Как следует из расшифровки аббревиатуры TDD — Test Driven Development. По-русски это будет примерно «Разработка через тестирование». Так вот, самое важное слово в данном случае не “тестирование” (которое стоит на последнем месте), а “разработка” (которое стоит на первом месте). Из вышесказанного вытекает следующий неочевидный вывод: TDD это не про тестирование, а про разработку, про написание кода. Приведу для красного словца известное описание TDD: Красный Зелёный Рефакторинг Отмечу, что данный сценарий является циклическим. Какие проблемы не решает TDD Гарантированная безошибочность приложения. Гарантированное покрытие тестами &gt; n%. Эти проблемы, конечно, решаются TDD, но по чистой случайности. Сама по себе методология была создана не для этого Какие проблемы решает TDD Изолированность написания модулей приложения. Скорость написания кода. Чуть ниже все четыре пункта рассмотрю подробнее, а пока опишу модель TDD. Модель TDD Начинать описание нужно с того же, с чего нужно начинать описание и всего остального в мире разработки: с проблемы. Итак, предположим, что у нас есть некоторое готовое приложение. И тут к нам приходит заказчик/начальник/уборщица/кто-угодно и говорит: “нам нужно, чтобы приложение делало ещё вот_это_вот”. Далее любой человек в здравом уме будет всеми способами доказывать глупость идеи заказчика/начальника/уборщицы/кого-угодно. Но для чистоты описания я вынужден предположить, что этот пункт с грохотом провалился. То есть надо что-то сделать. Для удобства предположим, что часть нашего нового функционала в конечном итоге упирается в получение результата по входным аргументам. То есть для всей области определения входных аргументов определена функция, возвращающая результат, соответствующий необходимым критериям. Разберём на примере выбора самого высокого человека из предоставленного ряда. Человек будет объектом со свойством рост. Сильно утрированный сценарий, но так будет проще. Красная фаза Тут надо крепко задуматься. Ибо предстоит решить “а что мы всё-таки в результате-то хотим”? Ответ на этот вопрос и является решением красной фазы. На примере человека становится ясно, что мы пишем такое требование: Из всего ряда людей нам нужно выбрать единственного человека таким образом, чтобы рост всех остальных был меньше или равен росту выбранного человека. Справедливое требование, не правда ли? Так как это требование является уже достаточно формализованным, то написание контракта в терминах выбранного ЯП становится очевидной операцией: РЯД = РядСлучайныхЛюдей; САМЫЙ_ВЫСОКИЙ_ЧЕЛОВЕК = выбратьСамогоВысокогоЧеловека(РЯД) для каждого ВЫБРАННОГО_ЧЕЛОВЕКА из РЯДА: если рост(ВЫБРАННОГО_ЧЕЛОВЕКА) &gt; рост(САМОГО_ВЫСОКОГО_ЧЕЛОВЕКА) то провалитьТест Очевидное преобразование, не так ли? С этого момента у программиста есть формализованный контракт к самому себе на написание кода, который в отвечает на вопрос: “Мы написали то что хотели, или нет?” До сих пор мы не написали ни строки кода реализации. Красная фаза пройдена. Почему красная? Потому что проверка нашего кода по контракту выдаёт отрицательный — “красный” — результат. Зелёная фаза И в этой фазе нужно выполнить написанный контракт. Нужно написать решение. Какое это будет решение — не очень-то и важно, на самом деле. Но приведу примерный псевдокод: определение: выбратьСамогоВысокогоЧеловека(РЯД) выбратьПервыйЭлемент(отсортироватьПузырьком(РЯД)) Контракт программиста самому себе выполнен. Зелёная фаза пройдена. Почему зелёная? Потому что проверка нашего кода по контракту выдаёт положительный — “зелёный” — результат. Рефакторинг На данном этапе нужно улучшать качественные характеристики кода. Например оптимизация, оформление, внутренняя декомпозиция и прочее. Важно то, что на данном этапе не изменяется ни контракт, ни сам факт его выполнения. Изменяется только способ его выполнения. Например, изменяем нашу реализацию таким образом: определение: выбратьСамогоВысокогоЧеловека(РЯД) отсортированыйРяд = отсортироватьДвоичнойСортировкой(РЯД) выбратьПервыйЭлемент(отсортированыйРяд) Написанный контракт позволяет программисту в любой момент проверить его выполнение, что делает рефакторинг безопасным. Эта фаза может совмещаться с code review, например, если это необходимо. Фаза рефакторинга пройдена. Что это нам даёт и чего не даёт (вышеупомянутые четыре пункта) Изолированность написания модулей приложения Такой способ написания кода позволяет проверять и реализовывать необходимый функционал. Контракт проверяет выполнение только выбраной нами функции и никакой другой. И не зависит от работы других функций. Скорость написания кода Для проверки реализации во время написания кода нет необходимости запускать всё приложение и руками проверять. Нет также необходимости подготавливать данные для проверки, потому как их подготовкой также занимается код контракта. Всё автоматизированно и потому быстро. Гарантированная безошибочность приложения Конечно, из описания выше можно сделать ложный вывод о том, что при наличии контрактов на весь функционал будет гарантия работоспособности приложения. Но это не так, увы. Мы живём в реальном мире. А это значит, что есть две большие проблемы: Невозможно составить полный контракт на всю область определения. Внешние зависимости не обязаны отвечать требованиям контрактов приложения. Про это я ещё чуть подробнее напишу в “советах”. Гарантированное покрытие тестами &gt; n%. Следует из пункта выше. Реальных сценариев слишком много, чтобы их можно было описать и при этом иметь поддерживаемую систему. Про это тоже будет в советах. Небольшой список советов (в том числе основанных на личном опыте) Не надо пытаться писать контракты на любой сценарий. Опишите только на минимально-необходимый. И уточняйте контракт только в том случае, если есть зафиксированный баг. Не надо определять контракты для внешних зависимостей. Контракт, который проверяет dnslookup(googleDNS) не только бессмысленнен, но и вреден. Ибо будет ломаться тогда, когда приложение будет работать. Отсюда следует следующий совет: Изолируйте свои контракты. Если внутри себя функция А вызывает достаточно сложную (и ненадёжную) функцию Б из какого-то другого модуля — применяйте stub. Если нужен какой-то сложный (и ненадёжный) объект для проверки — применяйте mock-объект. Не ленитесь описывать подготовку данных для каждой проверки заново. Один из примеров библиотек для изоляции тестов — webmock — мой спаситель в очень многих ситуациях. Не пишите большие и сложные контракты. Лучше их декомпозировать. Если есть, например, две проверки на разное поведение одной функции, то это два теста, а не один с двумя проверками. Когда наберётесь опыта, можно будет в фазу рефакторинга включить не только рефакторинг кода, но и рефакторинг контракта. Правда, делать это надо осторожно и последовательно: сначала полностью заканчиваете рефакторинг кода, а потом уже рефакторите контракт. Оставьте регрессионные и интеграционные тесты команде тестирования. Потому что писать код с помощью интеграционных тестов (в том числе всякие зашкварные капибары и phantomjs’ы) — это адЪ (есть личный опыт). К тому же это будет лишней тратой времени, никак не связанной с написанием кода приложения. Набросы (будет со временем обновляться, я надеюсь) О чрезмерном тестировании BDD: RSpec, Cucumber Тестирование серого ящика Stub и Mock Великий webmock-спаситель — позволяет сделать некрасивые stub’ы для сторонних API." />
<link rel="canonical" href="https://ivalentinee.github.io/ru/programming/2017/06/05/TDD.html" />
<meta property="og:url" content="https://ivalentinee.github.io/ru/programming/2017/06/05/TDD.html" />
<meta property="og:site_name" content="ivalentinee" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-06-05T00:00:00+00:00" />
<script type="application/ld+json">
{"headline":"Про TDD","dateModified":"2017-06-05T00:00:00+00:00","datePublished":"2017-06-05T00:00:00+00:00","description":"Предисловие Причиной этому посту послужило моё всё более и более религиозное отношение к TDD. Недавно состоялся диалог меня (ivalentinee) и одного моего друга (SomeoneFromTheInternet): ivalentinee: Рекомендую проникнуться духом TDD. SomeoneFromTheInternet: TDD всё-таки требует дисциплины. ivalentinee: Ни в коем случае не пропагандирую абсолютный TDD. ivalentinee: Но попробовать стоит, потому что заставляет задумываться о коде “с другой стороны”. SomeoneFromTheInternet: Думаю, что надо просто при описании логики писать тесты. SomeoneFromTheInternet: Типа думать, где наебнётся и что лучше бы это проверить. Это только один пример из многих. Я уже много раз сталкивался с тем, что люди понимают TDD неправильно не так, как я. Заранее надо предупредить о трёх вещах: Это моё понимание TDD. Не претендую на истину. Я же не какой-нибудь там Боб Мартин. Описываемое мной понимание TDD является утрированным и извращённым. В реальной жизни грань между “правильным” и “неправильным” TDD размывается до неразличимости. Писать примеры буду на псевдокоде русскими словами. И буду склонять названия. Потому что могу, вот почему. Что ж, поехали. Что такое TDD Как следует из расшифровки аббревиатуры TDD — Test Driven Development. По-русски это будет примерно «Разработка через тестирование». Так вот, самое важное слово в данном случае не “тестирование” (которое стоит на последнем месте), а “разработка” (которое стоит на первом месте). Из вышесказанного вытекает следующий неочевидный вывод: TDD это не про тестирование, а про разработку, про написание кода. Приведу для красного словца известное описание TDD: Красный Зелёный Рефакторинг Отмечу, что данный сценарий является циклическим. Какие проблемы не решает TDD Гарантированная безошибочность приложения. Гарантированное покрытие тестами &gt; n%. Эти проблемы, конечно, решаются TDD, но по чистой случайности. Сама по себе методология была создана не для этого Какие проблемы решает TDD Изолированность написания модулей приложения. Скорость написания кода. Чуть ниже все четыре пункта рассмотрю подробнее, а пока опишу модель TDD. Модель TDD Начинать описание нужно с того же, с чего нужно начинать описание и всего остального в мире разработки: с проблемы. Итак, предположим, что у нас есть некоторое готовое приложение. И тут к нам приходит заказчик/начальник/уборщица/кто-угодно и говорит: “нам нужно, чтобы приложение делало ещё вот_это_вот”. Далее любой человек в здравом уме будет всеми способами доказывать глупость идеи заказчика/начальника/уборщицы/кого-угодно. Но для чистоты описания я вынужден предположить, что этот пункт с грохотом провалился. То есть надо что-то сделать. Для удобства предположим, что часть нашего нового функционала в конечном итоге упирается в получение результата по входным аргументам. То есть для всей области определения входных аргументов определена функция, возвращающая результат, соответствующий необходимым критериям. Разберём на примере выбора самого высокого человека из предоставленного ряда. Человек будет объектом со свойством рост. Сильно утрированный сценарий, но так будет проще. Красная фаза Тут надо крепко задуматься. Ибо предстоит решить “а что мы всё-таки в результате-то хотим”? Ответ на этот вопрос и является решением красной фазы. На примере человека становится ясно, что мы пишем такое требование: Из всего ряда людей нам нужно выбрать единственного человека таким образом, чтобы рост всех остальных был меньше или равен росту выбранного человека. Справедливое требование, не правда ли? Так как это требование является уже достаточно формализованным, то написание контракта в терминах выбранного ЯП становится очевидной операцией: РЯД = РядСлучайныхЛюдей; САМЫЙ_ВЫСОКИЙ_ЧЕЛОВЕК = выбратьСамогоВысокогоЧеловека(РЯД) для каждого ВЫБРАННОГО_ЧЕЛОВЕКА из РЯДА: если рост(ВЫБРАННОГО_ЧЕЛОВЕКА) &gt; рост(САМОГО_ВЫСОКОГО_ЧЕЛОВЕКА) то провалитьТест Очевидное преобразование, не так ли? С этого момента у программиста есть формализованный контракт к самому себе на написание кода, который в отвечает на вопрос: “Мы написали то что хотели, или нет?” До сих пор мы не написали ни строки кода реализации. Красная фаза пройдена. Почему красная? Потому что проверка нашего кода по контракту выдаёт отрицательный — “красный” — результат. Зелёная фаза И в этой фазе нужно выполнить написанный контракт. Нужно написать решение. Какое это будет решение — не очень-то и важно, на самом деле. Но приведу примерный псевдокод: определение: выбратьСамогоВысокогоЧеловека(РЯД) выбратьПервыйЭлемент(отсортироватьПузырьком(РЯД)) Контракт программиста самому себе выполнен. Зелёная фаза пройдена. Почему зелёная? Потому что проверка нашего кода по контракту выдаёт положительный — “зелёный” — результат. Рефакторинг На данном этапе нужно улучшать качественные характеристики кода. Например оптимизация, оформление, внутренняя декомпозиция и прочее. Важно то, что на данном этапе не изменяется ни контракт, ни сам факт его выполнения. Изменяется только способ его выполнения. Например, изменяем нашу реализацию таким образом: определение: выбратьСамогоВысокогоЧеловека(РЯД) отсортированыйРяд = отсортироватьДвоичнойСортировкой(РЯД) выбратьПервыйЭлемент(отсортированыйРяд) Написанный контракт позволяет программисту в любой момент проверить его выполнение, что делает рефакторинг безопасным. Эта фаза может совмещаться с code review, например, если это необходимо. Фаза рефакторинга пройдена. Что это нам даёт и чего не даёт (вышеупомянутые четыре пункта) Изолированность написания модулей приложения Такой способ написания кода позволяет проверять и реализовывать необходимый функционал. Контракт проверяет выполнение только выбраной нами функции и никакой другой. И не зависит от работы других функций. Скорость написания кода Для проверки реализации во время написания кода нет необходимости запускать всё приложение и руками проверять. Нет также необходимости подготавливать данные для проверки, потому как их подготовкой также занимается код контракта. Всё автоматизированно и потому быстро. Гарантированная безошибочность приложения Конечно, из описания выше можно сделать ложный вывод о том, что при наличии контрактов на весь функционал будет гарантия работоспособности приложения. Но это не так, увы. Мы живём в реальном мире. А это значит, что есть две большие проблемы: Невозможно составить полный контракт на всю область определения. Внешние зависимости не обязаны отвечать требованиям контрактов приложения. Про это я ещё чуть подробнее напишу в “советах”. Гарантированное покрытие тестами &gt; n%. Следует из пункта выше. Реальных сценариев слишком много, чтобы их можно было описать и при этом иметь поддерживаемую систему. Про это тоже будет в советах. Небольшой список советов (в том числе основанных на личном опыте) Не надо пытаться писать контракты на любой сценарий. Опишите только на минимально-необходимый. И уточняйте контракт только в том случае, если есть зафиксированный баг. Не надо определять контракты для внешних зависимостей. Контракт, который проверяет dnslookup(googleDNS) не только бессмысленнен, но и вреден. Ибо будет ломаться тогда, когда приложение будет работать. Отсюда следует следующий совет: Изолируйте свои контракты. Если внутри себя функция А вызывает достаточно сложную (и ненадёжную) функцию Б из какого-то другого модуля — применяйте stub. Если нужен какой-то сложный (и ненадёжный) объект для проверки — применяйте mock-объект. Не ленитесь описывать подготовку данных для каждой проверки заново. Один из примеров библиотек для изоляции тестов — webmock — мой спаситель в очень многих ситуациях. Не пишите большие и сложные контракты. Лучше их декомпозировать. Если есть, например, две проверки на разное поведение одной функции, то это два теста, а не один с двумя проверками. Когда наберётесь опыта, можно будет в фазу рефакторинга включить не только рефакторинг кода, но и рефакторинг контракта. Правда, делать это надо осторожно и последовательно: сначала полностью заканчиваете рефакторинг кода, а потом уже рефакторите контракт. Оставьте регрессионные и интеграционные тесты команде тестирования. Потому что писать код с помощью интеграционных тестов (в том числе всякие зашкварные капибары и phantomjs’ы) — это адЪ (есть личный опыт). К тому же это будет лишней тратой времени, никак не связанной с написанием кода приложения. Набросы (будет со временем обновляться, я надеюсь) О чрезмерном тестировании BDD: RSpec, Cucumber Тестирование серого ящика Stub и Mock Великий webmock-спаситель — позволяет сделать некрасивые stub’ы для сторонних API.","mainEntityOfPage":{"@type":"WebPage","@id":"https://ivalentinee.github.io/ru/programming/2017/06/05/TDD.html"},"@type":"BlogPosting","url":"https://ivalentinee.github.io/ru/programming/2017/06/05/TDD.html","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://ivalentinee.github.io/feed.xml" title="ivalentinee" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/ru/">ivalentinee</a>

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
                <a class="page-link" href="/ru/about/">Обо мне</a>
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
          
            
            
          
            
            
          
            
            
              
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Про TDD</h1>
    <p class="post-meta">
      <time datetime="2017-06-05T00:00:00+00:00" itemprop="datePublished">
        
        Jun 5, 2017
      </time>
      </p>
  </header>

  

  <div class="post-content" itemprop="articleBody">
    <h2 id="предисловие">Предисловие</h2>
<p>Причиной этому посту послужило моё всё более и более религиозное отношение к TDD.</p>

<p>Недавно состоялся диалог меня (ivalentinee) и одного моего друга (SomeoneFromTheInternet):</p>
<blockquote>
  <p>ivalentinee: Рекомендую проникнуться духом TDD.</p>

  <p>SomeoneFromTheInternet: TDD всё-таки требует дисциплины.</p>

  <p>ivalentinee: Ни в коем случае не пропагандирую абсолютный TDD.</p>

  <p>ivalentinee: Но попробовать стоит, потому что заставляет задумываться о коде “с другой стороны”.</p>

  <p>SomeoneFromTheInternet: Думаю, что надо просто при описании логики писать тесты.</p>

  <p>SomeoneFromTheInternet: Типа думать, где наебнётся и что лучше бы это проверить.</p>
</blockquote>

<p>Это только один пример из многих. Я уже много раз сталкивался с тем, что люди понимают TDD <del>неправильно</del> не так, как я.</p>

<p>Заранее надо предупредить о трёх вещах:</p>
<ol>
  <li>Это моё понимание TDD. Не претендую на истину. Я же не какой-нибудь там Боб Мартин.</li>
  <li>Описываемое мной понимание TDD является утрированным и извращённым. В реальной жизни грань между “правильным” и “неправильным” TDD размывается до неразличимости.</li>
  <li>Писать примеры буду на псевдокоде русскими словами. И буду склонять названия. Потому что могу, вот почему.</li>
</ol>

<p>Что ж, поехали.</p>

<h2 id="что-такое-tdd">Что такое TDD</h2>
<p>Как следует из расшифровки аббревиатуры TDD — Test Driven Development. По-русски это будет примерно «Разработка через тестирование». Так вот, самое важное слово в данном случае не “тестирование” (которое стоит на последнем месте), а “разработка” (которое стоит на первом месте).</p>

<p>Из вышесказанного вытекает следующий неочевидный вывод: TDD это <strong>не про тестирование</strong>, а <strong>про разработку</strong>, про <strong>написание кода</strong>.</p>

<p>Приведу для красного словца известное описание TDD:</p>
<ol>
  <li>Красный</li>
  <li>Зелёный</li>
  <li>Рефакторинг</li>
</ol>

<p>Отмечу, что данный сценарий является <em>циклическим</em>.</p>

<h3 id="какие-проблемы-не-решает-tdd">Какие проблемы не решает TDD</h3>
<ol>
  <li>Гарантированная безошибочность приложения.</li>
  <li>Гарантированное покрытие тестами &gt; n%.</li>
</ol>

<p>Эти проблемы, конечно, решаются TDD, но по чистой случайности. Сама по себе методология была создана не для этого</p>

<h3 id="какие-проблемы-решает-tdd">Какие проблемы решает TDD</h3>
<ol>
  <li>Изолированность написания модулей приложения.</li>
  <li>Скорость написания кода.</li>
</ol>

<p>Чуть ниже все четыре пункта рассмотрю подробнее, а пока опишу модель TDD.</p>

<h3 id="модель-tdd">Модель TDD</h3>
<p>Начинать описание нужно с того же, с чего нужно начинать описание и всего остального в мире разработки: с <strong>проблемы</strong>.</p>

<p>Итак, предположим, что у нас есть некоторое готовое приложение. И тут к нам приходит заказчик/начальник/уборщица/кто-угодно и говорит: “нам нужно, чтобы приложение делало ещё вот_это_вот”.</p>

<p>Далее любой человек в здравом уме будет всеми способами доказывать глупость идеи заказчика/начальника/уборщицы/кого-угодно. Но для чистоты описания я вынужден предположить, что этот пункт с грохотом провалился. То есть надо что-то сделать.</p>

<p>Для удобства предположим, что часть нашего нового функционала в конечном итоге упирается в получение результата по входным аргументам. То есть для всей области определения входных аргументов определена функция, возвращающая результат, соответствующий необходимым критериям.</p>

<p>Разберём на примере выбора самого высокого человека из предоставленного ряда. Человек будет объектом со свойством <code class="highlighter-rouge">рост</code>. Сильно утрированный сценарий, но так будет проще.</p>

<h4 id="красная-фаза">Красная фаза</h4>
<p>Тут надо крепко задуматься. Ибо предстоит решить “а что мы всё-таки в результате-то хотим”? Ответ на этот вопрос и является решением красной фазы.</p>

<p>На примере человека становится ясно, что мы пишем такое требование:</p>
<blockquote>
  <p>Из всего ряда людей нам нужно выбрать единственного человека таким образом, чтобы рост всех остальных был меньше или равен росту выбранного человека.</p>
</blockquote>

<p>Справедливое требование, не правда ли?</p>

<p>Так как это требование является уже достаточно формализованным, то написание <em>контракта</em> в терминах выбранного ЯП становится очевидной операцией:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>РЯД = РядСлучайныхЛюдей;

САМЫЙ_ВЫСОКИЙ_ЧЕЛОВЕК = выбратьСамогоВысокогоЧеловека(РЯД)

для каждого ВЫБРАННОГО_ЧЕЛОВЕКА из РЯДА:
  если рост(ВЫБРАННОГО_ЧЕЛОВЕКА) &gt; рост(САМОГО_ВЫСОКОГО_ЧЕЛОВЕКА) то провалитьТест
</code></pre></div></div>

<p>Очевидное преобразование, не так ли?</p>

<p>С этого момента у программиста есть <em>формализованный контракт</em> к самому себе на написание кода, который в отвечает на вопрос: “Мы написали то что хотели, или нет?”</p>

<p>До сих пор мы не написали ни строки кода реализации.</p>

<p>Красная фаза пройдена.</p>

<p>Почему красная? Потому что проверка нашего кода по контракту выдаёт отрицательный — “красный” — результат.</p>

<h4 id="зелёная-фаза">Зелёная фаза</h4>
<p>И в этой фазе нужно выполнить написанный контракт. Нужно написать решение. Какое это будет решение — не очень-то и важно, на самом деле.</p>

<p>Но приведу примерный псевдокод:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>определение: выбратьСамогоВысокогоЧеловека(РЯД)
  выбратьПервыйЭлемент(отсортироватьПузырьком(РЯД))
</code></pre></div></div>

<p>Контракт программиста самому себе выполнен. Зелёная фаза пройдена.</p>

<p>Почему зелёная? Потому что проверка нашего кода по контракту выдаёт положительный — “зелёный” — результат.</p>

<h4 id="рефакторинг">Рефакторинг</h4>
<p>На данном этапе нужно улучшать качественные характеристики кода. Например оптимизация, оформление, внутренняя декомпозиция и прочее.</p>

<p>Важно то, что на данном этапе не изменяется ни контракт, ни сам факт его выполнения. Изменяется только способ его выполнения.</p>

<p>Например, изменяем нашу реализацию таким образом:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>определение: выбратьСамогоВысокогоЧеловека(РЯД)
  отсортированыйРяд = отсортироватьДвоичнойСортировкой(РЯД)
  выбратьПервыйЭлемент(отсортированыйРяд)
</code></pre></div></div>

<p>Написанный контракт позволяет программисту в любой момент проверить его выполнение, что делает рефакторинг <strong>безопасным</strong>.</p>

<p>Эта фаза может совмещаться с code review, например, если это необходимо.</p>

<p>Фаза рефакторинга пройдена.</p>

<h3 id="что-это-нам-даёт-и-чего-не-даёт-вышеупомянутые-четыре-пункта">Что это нам даёт и чего не даёт (вышеупомянутые четыре пункта)</h3>

<h4 id="изолированность-написания-модулей-приложения">Изолированность написания модулей приложения</h4>
<p>Такой способ написания кода позволяет проверять и реализовывать необходимый функционал. Контракт проверяет выполнение только выбраной нами функции и никакой другой. И не зависит от работы других функций.</p>

<h4 id="скорость-написания-кода">Скорость написания кода</h4>
<p>Для проверки реализации <em>во время написания кода</em> нет необходимости запускать всё приложение и руками проверять. Нет также необходимости подготавливать данные для проверки, потому как их подготовкой также занимается код контракта. Всё автоматизированно и потому быстро.</p>

<h4 id="гарантированная-безошибочность-приложения">Гарантированная безошибочность приложения</h4>
<p>Конечно, из описания выше можно сделать ложный вывод о том, что при наличии контрактов на весь функционал будет гарантия работоспособности приложения. Но это не так, увы.</p>

<p>Мы живём в реальном мире. А это значит, что есть две большие проблемы:</p>
<ol>
  <li>Невозможно составить полный контракт на всю область определения.</li>
  <li>Внешние зависимости не обязаны отвечать требованиям контрактов приложения.</li>
</ol>

<p>Про это я ещё чуть подробнее напишу в “советах”.</p>

<h4 id="гарантированное-покрытие-тестами--n">Гарантированное покрытие тестами &gt; n%.</h4>
<p>Следует из пункта выше. Реальных сценариев слишком много, чтобы их можно было описать и при этом иметь поддерживаемую систему. Про это тоже будет в советах.</p>

<h3 id="небольшой-список-советов-в-том-числе-основанных-на-личном-опыте">Небольшой список советов (в том числе основанных на личном опыте)</h3>
<ol>
  <li>Не надо пытаться писать контракты на любой сценарий. Опишите только на минимально-необходимый. И уточняйте контракт только в том случае, если есть зафиксированный баг.</li>
  <li>Не надо определять контракты для внешних зависимостей. Контракт, который проверяет dnslookup(googleDNS) не только бессмысленнен, но и вреден. Ибо будет ломаться тогда, когда приложение будет работать. Отсюда следует следующий совет:</li>
  <li>Изолируйте свои контракты. Если внутри себя функция А вызывает достаточно сложную (и ненадёжную) функцию Б из какого-то другого модуля — применяйте <a href="https://en.wikipedia.org/wiki/Method_stub">stub</a>. Если нужен какой-то сложный (и ненадёжный) объект для проверки — применяйте <a href="https://en.wikipedia.org/wiki/Mock_object">mock-объект</a>. Не ленитесь описывать подготовку данных для каждой проверки заново. Один из примеров библиотек для изоляции тестов — <a href="https://github.com/bblimke/webmock">webmock</a> — мой спаситель в очень многих ситуациях.</li>
  <li>Не пишите большие и сложные контракты. Лучше их декомпозировать. Если есть, например, две проверки на разное поведение одной функции, то это два теста, а не один с двумя проверками.</li>
  <li>Когда наберётесь опыта, можно будет в фазу рефакторинга включить не только рефакторинг кода, но и рефакторинг контракта. Правда, делать это надо осторожно и последовательно: сначала полностью заканчиваете рефакторинг кода, а потом уже рефакторите контракт.</li>
  <li>Оставьте регрессионные и интеграционные тесты команде тестирования. Потому что писать код с помощью интеграционных тестов (в том числе всякие зашкварные <a href="http://teamcapybara.github.io/capybara/">капибары</a> и <a href="http://phantomjs.org/">phantomjs’ы</a>) — это адЪ (есть личный опыт). К тому же это будет лишней тратой времени, никак не связанной с написанием кода приложения.</li>
</ol>

<h2 id="набросы-будет-со-временем-обновляться-я-надеюсь">Набросы (будет со временем обновляться, я надеюсь)</h2>
<p><a href="https://habrahabr.ru/post/143616/">О чрезмерном тестировании</a></p>

<p><a href="https://en.wikipedia.org/wiki/Behavior-driven_development">BDD</a>: <a href="http://rspec.info/">RSpec</a>, <a href="https://cucumber.io/">Cucumber</a></p>

<p><a href="https://en.wikipedia.org/wiki/Gray_box_testing">Тестирование серого ящика</a></p>

<p><a href="https://en.wikipedia.org/wiki/Method_stub">Stub</a> и <a href="https://en.wikipedia.org/wiki/Mock_object">Mock</a></p>

<p><a href="https://github.com/bblimke/webmock">Великий webmock-спаситель</a> — позволяет сделать <del>не</del>красивые stub’ы для сторонних API.</p>

  </div>

  
  <div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://ivalentinee.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">ivalentinee</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">ivalentinee</li><li><a class="u-email" href="mailto:valentine.emperor@gmail.com">valentine.emperor@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ivalentinee"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ivalentinee</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
