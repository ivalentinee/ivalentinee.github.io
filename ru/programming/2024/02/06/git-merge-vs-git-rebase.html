<!DOCTYPE html>
<html lang="ru"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>В чём разница между git merge и git rebase? | ivalentinee</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="В чём разница между git merge и git rebase?" />
<meta property="og:locale" content="ru" />
<meta name="description" content="Введение Для начала я отвечу на вопрос «зачем этот пост?» Ну, во-первых, я уже давно обещал Виталию из Evrone написать хоть что-то в блог. Обещаного, как говорится, лучше вообще не ждать, а то расстроишься. А во-вторых вот уже полтора года как я провожу собеседования на позицию Señor NodeJS developer, при этом на момент первого собеседования я сам писал на NodeJS едва ли с полгода. И в качестве единственного (ну ладно, не единственного, но единственного технического) вопроса по git задаю именно этот. Почему именно его? Потому что ответ на этот вопрос сразу поведает мне о том, насколько глубоко кандидат копался в git. И ответов тут может быть несколько, от «я не знаю» до «а diff-то в git динамический!». После собеседования неплохо бы оставлять кандидатам обратную связь, но вот незадача — я не смог через полчаса гугления смог! найти удовлетворяющую меня статью по этому вопросу. Надо бы это исправить дополнить. Давайте попробуем разобраться в возможный ответах и дойдём до самого ультимативного Неинтересные варианты ответов «Я не знаю» Пожалуй, тут особо и нечего комментировать. Если рассказать по вопросу “в чём разница между git merge и git rebase” нечего, то нужно идти учить матчасть. Например прочитать вот эту статью. «Merge соединяет код, а rebase как бы его поверх делает» Если совсем вольно трактовать поведение git — да, можно считать это верным ответом, ведь, действительно, merge пытается “соединить” две ветки в одну за счёт создания merge-коммита, а rebase применяет коммиты одной ветки поверх другой. «Rebase изменяет историю» Так-то да, но если вы противник изменения истории — используйте Mercurial. Да и без последующих комментариев это на вопрос не отвечает. «Merge объединяет код сразу, а rebase по одному коммиту» Это уже интереснее, хотя суть проблемы никак не выявляет. Действительно, при разрешении конфликтов git для merge вычисляет конфликты между последними состояними (коммитами, если хотите) веток, а rebase делает это для каждого коммита (из ветки, которую мы rebase’им). «Diff строится по-разному для merge и rebase: merge разрешает все конфликты в merge-коммите, а rebase разрешает их для каждого коммита» А вот это уже гораздо ближе к истине. Правда, есть нюанс (ahem, вы меня поняли), но про “нюанс” я уточняю вопросом “а к чему это приводит”? «А к чему это приводит?» «К различиям в git blame» Итак, первый ответ на вопрос “А к чему это приводит”. Объяснение тут довольно простое (но не для всех очевидное): при наличии конфликтов — даже при их автоматическом разрешении — само изменение, разрешающее конфликт будет относиться к merge-коммиту в случае merge, в то время как при rebase изменение, относящееся к разрешению конфликта будет относиться к тому коммиту, для которого разрешался конфликт. Для демонстрации сего на двухчасовом мероприятии я даже собрал небольшой репозиторий с примером. Если есть время, рекомендую ознакомиться. А так как я являюсь яростным сторонником git-blame-driven подхода, то мне бы очень не хотелось по какому-то спорному изменению видеть в git blame имя коммита Merge branch &#39;feature/fix-some-bug&#39; into &#39;master&#39;, а хотелось бы видеть непосредственно тот коммит, к которому логически это изменение относится. Кстати, это делает меня сторонником крайне спорного подхода: прежде, чем мержить свою ветку в master, неплохо бы её отребейзить на тот же master, чтобы и получить логическое преимущество наличия merge-коммита и при этом не потерять корректный git blame. «К различиям в коде» А вот тут самое интересное. Потому как остальные различия не относятся к результату в коде, а только к истории. Можно что-то и поломать. Давайте посмотрим. Я приведу полный листинг bash-команд без комментариев, а дальше вы уж как-нибудь сами разберётесь. # Создаём репозиторий git init . # Создаём первый коммит с единственным файлом echo &quot;some string&quot; &gt; file.txt git add file.txt git commit -m &quot;Initial commit&quot; # Создаём две ветки, в которых будем играться изменениями git branch branch-1 git branch branch-2 # Изменяем единственную строку в ветке branch-1 git checkout branch-1 echo &quot;some string // changed&quot; &gt; file.txt git add file.txt git commit -m &quot;Changed line 2 on branch 1&quot; # Изменяем единственную строку в ветке branch-2 git checkout branch-2 echo &quot;some string // changed&quot; &gt; file.txt git add file.txt git commit -m &quot;Changed line 2 on branch 2&quot; # Откатываем единственную строку в файле branch-2 echo &quot;some string&quot; &gt; file.txt git add file.txt git commit -m &quot;Reverted line 2 on branch 2&quot; # Создаём копию ветки для того, чтобы попробовать и merge и rebase git branch branch-2-non-modified # Делаем git merge git merge --no-edit branch-1 cat file.txt # Получаем some string // changed # Возвращаем branch-2 к до-merge-состоянию git reset --hard branch-2-non-modified # Делаем git rebase git rebase branch-1 cat file.txt # Получаем some string Интересно получилось? Вот и мне интересно. Особенно если кандидат про это расскажет (без листинга и подробностей, конечно) на собеседовании. Почему так происходит? Думайте, гуглите, дальше мне лень простыню писать. Особенно с учётом того, что при описании такого последствия кандидатом дальнейших объяснений не потребуется — и так понятно, что кандидат с git работал достаточно глубоко." />
<meta property="og:description" content="Введение Для начала я отвечу на вопрос «зачем этот пост?» Ну, во-первых, я уже давно обещал Виталию из Evrone написать хоть что-то в блог. Обещаного, как говорится, лучше вообще не ждать, а то расстроишься. А во-вторых вот уже полтора года как я провожу собеседования на позицию Señor NodeJS developer, при этом на момент первого собеседования я сам писал на NodeJS едва ли с полгода. И в качестве единственного (ну ладно, не единственного, но единственного технического) вопроса по git задаю именно этот. Почему именно его? Потому что ответ на этот вопрос сразу поведает мне о том, насколько глубоко кандидат копался в git. И ответов тут может быть несколько, от «я не знаю» до «а diff-то в git динамический!». После собеседования неплохо бы оставлять кандидатам обратную связь, но вот незадача — я не смог через полчаса гугления смог! найти удовлетворяющую меня статью по этому вопросу. Надо бы это исправить дополнить. Давайте попробуем разобраться в возможный ответах и дойдём до самого ультимативного Неинтересные варианты ответов «Я не знаю» Пожалуй, тут особо и нечего комментировать. Если рассказать по вопросу “в чём разница между git merge и git rebase” нечего, то нужно идти учить матчасть. Например прочитать вот эту статью. «Merge соединяет код, а rebase как бы его поверх делает» Если совсем вольно трактовать поведение git — да, можно считать это верным ответом, ведь, действительно, merge пытается “соединить” две ветки в одну за счёт создания merge-коммита, а rebase применяет коммиты одной ветки поверх другой. «Rebase изменяет историю» Так-то да, но если вы противник изменения истории — используйте Mercurial. Да и без последующих комментариев это на вопрос не отвечает. «Merge объединяет код сразу, а rebase по одному коммиту» Это уже интереснее, хотя суть проблемы никак не выявляет. Действительно, при разрешении конфликтов git для merge вычисляет конфликты между последними состояними (коммитами, если хотите) веток, а rebase делает это для каждого коммита (из ветки, которую мы rebase’им). «Diff строится по-разному для merge и rebase: merge разрешает все конфликты в merge-коммите, а rebase разрешает их для каждого коммита» А вот это уже гораздо ближе к истине. Правда, есть нюанс (ahem, вы меня поняли), но про “нюанс” я уточняю вопросом “а к чему это приводит”? «А к чему это приводит?» «К различиям в git blame» Итак, первый ответ на вопрос “А к чему это приводит”. Объяснение тут довольно простое (но не для всех очевидное): при наличии конфликтов — даже при их автоматическом разрешении — само изменение, разрешающее конфликт будет относиться к merge-коммиту в случае merge, в то время как при rebase изменение, относящееся к разрешению конфликта будет относиться к тому коммиту, для которого разрешался конфликт. Для демонстрации сего на двухчасовом мероприятии я даже собрал небольшой репозиторий с примером. Если есть время, рекомендую ознакомиться. А так как я являюсь яростным сторонником git-blame-driven подхода, то мне бы очень не хотелось по какому-то спорному изменению видеть в git blame имя коммита Merge branch &#39;feature/fix-some-bug&#39; into &#39;master&#39;, а хотелось бы видеть непосредственно тот коммит, к которому логически это изменение относится. Кстати, это делает меня сторонником крайне спорного подхода: прежде, чем мержить свою ветку в master, неплохо бы её отребейзить на тот же master, чтобы и получить логическое преимущество наличия merge-коммита и при этом не потерять корректный git blame. «К различиям в коде» А вот тут самое интересное. Потому как остальные различия не относятся к результату в коде, а только к истории. Можно что-то и поломать. Давайте посмотрим. Я приведу полный листинг bash-команд без комментариев, а дальше вы уж как-нибудь сами разберётесь. # Создаём репозиторий git init . # Создаём первый коммит с единственным файлом echo &quot;some string&quot; &gt; file.txt git add file.txt git commit -m &quot;Initial commit&quot; # Создаём две ветки, в которых будем играться изменениями git branch branch-1 git branch branch-2 # Изменяем единственную строку в ветке branch-1 git checkout branch-1 echo &quot;some string // changed&quot; &gt; file.txt git add file.txt git commit -m &quot;Changed line 2 on branch 1&quot; # Изменяем единственную строку в ветке branch-2 git checkout branch-2 echo &quot;some string // changed&quot; &gt; file.txt git add file.txt git commit -m &quot;Changed line 2 on branch 2&quot; # Откатываем единственную строку в файле branch-2 echo &quot;some string&quot; &gt; file.txt git add file.txt git commit -m &quot;Reverted line 2 on branch 2&quot; # Создаём копию ветки для того, чтобы попробовать и merge и rebase git branch branch-2-non-modified # Делаем git merge git merge --no-edit branch-1 cat file.txt # Получаем some string // changed # Возвращаем branch-2 к до-merge-состоянию git reset --hard branch-2-non-modified # Делаем git rebase git rebase branch-1 cat file.txt # Получаем some string Интересно получилось? Вот и мне интересно. Особенно если кандидат про это расскажет (без листинга и подробностей, конечно) на собеседовании. Почему так происходит? Думайте, гуглите, дальше мне лень простыню писать. Особенно с учётом того, что при описании такого последствия кандидатом дальнейших объяснений не потребуется — и так понятно, что кандидат с git работал достаточно глубоко." />
<link rel="canonical" href="https://ivalentinee.github.io/ru/programming/2024/02/06/git-merge-vs-git-rebase.html" />
<meta property="og:url" content="https://ivalentinee.github.io/ru/programming/2024/02/06/git-merge-vs-git-rebase.html" />
<meta property="og:site_name" content="ivalentinee" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-02-06T00:00:00+00:00" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"https://ivalentinee.github.io/ru/programming/2024/02/06/git-merge-vs-git-rebase.html"},"description":"Введение Для начала я отвечу на вопрос «зачем этот пост?» Ну, во-первых, я уже давно обещал Виталию из Evrone написать хоть что-то в блог. Обещаного, как говорится, лучше вообще не ждать, а то расстроишься. А во-вторых вот уже полтора года как я провожу собеседования на позицию Señor NodeJS developer, при этом на момент первого собеседования я сам писал на NodeJS едва ли с полгода. И в качестве единственного (ну ладно, не единственного, но единственного технического) вопроса по git задаю именно этот. Почему именно его? Потому что ответ на этот вопрос сразу поведает мне о том, насколько глубоко кандидат копался в git. И ответов тут может быть несколько, от «я не знаю» до «а diff-то в git динамический!». После собеседования неплохо бы оставлять кандидатам обратную связь, но вот незадача — я не смог через полчаса гугления смог! найти удовлетворяющую меня статью по этому вопросу. Надо бы это исправить дополнить. Давайте попробуем разобраться в возможный ответах и дойдём до самого ультимативного Неинтересные варианты ответов «Я не знаю» Пожалуй, тут особо и нечего комментировать. Если рассказать по вопросу “в чём разница между git merge и git rebase” нечего, то нужно идти учить матчасть. Например прочитать вот эту статью. «Merge соединяет код, а rebase как бы его поверх делает» Если совсем вольно трактовать поведение git — да, можно считать это верным ответом, ведь, действительно, merge пытается “соединить” две ветки в одну за счёт создания merge-коммита, а rebase применяет коммиты одной ветки поверх другой. «Rebase изменяет историю» Так-то да, но если вы противник изменения истории — используйте Mercurial. Да и без последующих комментариев это на вопрос не отвечает. «Merge объединяет код сразу, а rebase по одному коммиту» Это уже интереснее, хотя суть проблемы никак не выявляет. Действительно, при разрешении конфликтов git для merge вычисляет конфликты между последними состояними (коммитами, если хотите) веток, а rebase делает это для каждого коммита (из ветки, которую мы rebase’им). «Diff строится по-разному для merge и rebase: merge разрешает все конфликты в merge-коммите, а rebase разрешает их для каждого коммита» А вот это уже гораздо ближе к истине. Правда, есть нюанс (ahem, вы меня поняли), но про “нюанс” я уточняю вопросом “а к чему это приводит”? «А к чему это приводит?» «К различиям в git blame» Итак, первый ответ на вопрос “А к чему это приводит”. Объяснение тут довольно простое (но не для всех очевидное): при наличии конфликтов — даже при их автоматическом разрешении — само изменение, разрешающее конфликт будет относиться к merge-коммиту в случае merge, в то время как при rebase изменение, относящееся к разрешению конфликта будет относиться к тому коммиту, для которого разрешался конфликт. Для демонстрации сего на двухчасовом мероприятии я даже собрал небольшой репозиторий с примером. Если есть время, рекомендую ознакомиться. А так как я являюсь яростным сторонником git-blame-driven подхода, то мне бы очень не хотелось по какому-то спорному изменению видеть в git blame имя коммита Merge branch &#39;feature/fix-some-bug&#39; into &#39;master&#39;, а хотелось бы видеть непосредственно тот коммит, к которому логически это изменение относится. Кстати, это делает меня сторонником крайне спорного подхода: прежде, чем мержить свою ветку в master, неплохо бы её отребейзить на тот же master, чтобы и получить логическое преимущество наличия merge-коммита и при этом не потерять корректный git blame. «К различиям в коде» А вот тут самое интересное. Потому как остальные различия не относятся к результату в коде, а только к истории. Можно что-то и поломать. Давайте посмотрим. Я приведу полный листинг bash-команд без комментариев, а дальше вы уж как-нибудь сами разберётесь. # Создаём репозиторий git init . # Создаём первый коммит с единственным файлом echo &quot;some string&quot; &gt; file.txt git add file.txt git commit -m &quot;Initial commit&quot; # Создаём две ветки, в которых будем играться изменениями git branch branch-1 git branch branch-2 # Изменяем единственную строку в ветке branch-1 git checkout branch-1 echo &quot;some string // changed&quot; &gt; file.txt git add file.txt git commit -m &quot;Changed line 2 on branch 1&quot; # Изменяем единственную строку в ветке branch-2 git checkout branch-2 echo &quot;some string // changed&quot; &gt; file.txt git add file.txt git commit -m &quot;Changed line 2 on branch 2&quot; # Откатываем единственную строку в файле branch-2 echo &quot;some string&quot; &gt; file.txt git add file.txt git commit -m &quot;Reverted line 2 on branch 2&quot; # Создаём копию ветки для того, чтобы попробовать и merge и rebase git branch branch-2-non-modified # Делаем git merge git merge --no-edit branch-1 cat file.txt # Получаем some string // changed # Возвращаем branch-2 к до-merge-состоянию git reset --hard branch-2-non-modified # Делаем git rebase git rebase branch-1 cat file.txt # Получаем some string Интересно получилось? Вот и мне интересно. Особенно если кандидат про это расскажет (без листинга и подробностей, конечно) на собеседовании. Почему так происходит? Думайте, гуглите, дальше мне лень простыню писать. Особенно с учётом того, что при описании такого последствия кандидатом дальнейших объяснений не потребуется — и так понятно, что кандидат с git работал достаточно глубоко.","@type":"BlogPosting","url":"https://ivalentinee.github.io/ru/programming/2024/02/06/git-merge-vs-git-rebase.html","headline":"В чём разница между git merge и git rebase?","dateModified":"2024-02-06T00:00:00+00:00","datePublished":"2024-02-06T00:00:00+00:00","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://ivalentinee.github.io/feed.xml" title="ivalentinee" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/ru/">ivalentinee</a>

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
            
          
            
            
              
                <a class="page-link" href="/ru/about/">Обо мне</a>
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
          
            
            
          
            
            
              
            
          
            
            
          
            
            
              
            
          
            
            
              
            
          
            
            
          
            
            
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">В чём разница между git merge и git rebase?</h1>
    <p class="post-meta">
      <time datetime="2024-02-06T00:00:00+00:00" itemprop="datePublished">
        
        Feb 6, 2024
      </time>
      </p>
  </header>

          <div class="language-selector">
          <a href="/en/programming/2024/02/06/git-merge-vs-git-rebase.html" class="language-selector-link">English</a><span class="language-selector-separator">|</span><span class="language-selector-link">Русский</span>
        </div>


  <div class="post-content" itemprop="articleBody">
    <h2 id="введение">Введение</h2>
<p>Для начала я отвечу на вопрос «зачем этот пост?»</p>

<p>Ну, во-первых, я уже давно обещал Виталию из Evrone написать хоть что-то в блог. Обещаного, как говорится, <em>лучше вообще не ждать, а то расстроишься</em>.</p>

<p>А во-вторых вот уже полтора года как я провожу собеседования на позицию <em>Señor NodeJS developer</em>, при этом на момент первого собеседования я сам писал на NodeJS едва ли с полгода. И в качестве единственного (ну ладно, не единственного, но единственного технического) вопроса по git задаю именно этот.</p>

<p>Почему именно его? Потому что ответ на этот вопрос сразу поведает мне о том, насколько глубоко кандидат копался в git. И ответов тут может быть несколько, от «я не знаю» до «а diff-то в git динамический!».</p>

<p>После собеседования неплохо бы оставлять кандидатам обратную связь, но вот незадача — я <del>не смог</del> <a href="https://www.edwardthomson.com/blog/merge_vs_rebase.html">через полчаса гугления смог!</a> найти удовлетворяющую меня статью по этому вопросу. Надо бы это <del>исправить</del> дополнить.</p>

<p>Давайте попробуем разобраться в возможный ответах и дойдём до самого ультимативного</p>

<h2 id="неинтересные-варианты-ответов">Неинтересные варианты ответов</h2>

<h3 id="я-не-знаю">«Я не знаю»</h3>
<p>Пожалуй, тут особо и нечего комментировать. Если рассказать по вопросу “в чём разница между git merge и git rebase” нечего, то нужно идти учить матчасть. Например прочитать вот эту статью.</p>

<h3 id="merge-соединяет-код-а-rebase-как-бы-его-поверх-делает">«Merge соединяет код, а rebase как бы его поверх делает»</h3>
<p>Если совсем вольно трактовать поведение git — да, можно считать это верным ответом, ведь, действительно, <code class="highlighter-rouge">merge</code> пытается “соединить” две ветки в одну за счёт создания merge-коммита, а <code class="highlighter-rouge">rebase</code> <strong>применяет</strong> коммиты одной ветки <em>поверх</em> другой.</p>

<h3 id="rebase-изменяет-историю">«Rebase изменяет историю»</h3>
<p>Так-то да, но если вы противник изменения истории — используйте <a href="https://en.wikipedia.org/wiki/Mercurial">Mercurial</a>. Да и без последующих комментариев это на вопрос не отвечает.</p>

<h3 id="merge-объединяет-код-сразу-а-rebase-по-одному-коммиту">«Merge объединяет код сразу, а rebase по одному коммиту»</h3>
<p>Это уже интереснее, хотя суть проблемы никак не выявляет. Действительно, при разрешении конфликтов git для <code class="highlighter-rouge">merge</code> вычисляет конфликты между <strong>последними состояними</strong> (коммитами, если хотите) веток, а <code class="highlighter-rouge">rebase</code> делает это <strong>для каждого коммита</strong> (из ветки, которую мы rebase’им).</p>

<h2 id="diff-строится-по-разному-для-merge-и-rebase-merge-разрешает-все-конфликты-в-merge-коммите-а-rebase-разрешает-их-для-каждого-коммита">«Diff строится по-разному для <code class="highlighter-rouge">merge</code> и <code class="highlighter-rouge">rebase</code>: <code class="highlighter-rouge">merge</code> разрешает все конфликты в merge-коммите, а rebase разрешает их для каждого коммита»</h2>
<p>А вот это уже гораздо ближе к <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D1%8B%D0%B5_%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D1%8B">истине</a>. Правда, есть <em>нюанс</em> (<em>ahem, вы меня поняли</em>), но про “<em>нюанс</em>” я уточняю вопросом “а к чему это приводит”?</p>

<h3 id="а-к-чему-это-приводит">«А к чему это приводит?»</h3>

<h4 id="к-различиям-в-git-blame">«К различиям в git blame»</h4>
<p>Итак, первый ответ на вопрос “А к чему это приводит”.</p>

<p>Объяснение тут довольно простое (но не для всех очевидное): при наличии конфликтов — <strong>даже при их автоматическом разрешении</strong> — само изменение, разрешающее конфликт будет относиться к merge-коммиту в случае <code class="highlighter-rouge">merge</code>, в то время как при <code class="highlighter-rouge">rebase</code> изменение, относящееся к разрешению конфликта будет относиться к тому коммиту, для которого разрешался конфликт.</p>

<p>Для демонстрации сего на двухчасовом мероприятии я даже собрал <a href="https://github.com/ivalentinee/git-workshop/blob/master/manual/INDEX.md">небольшой репозиторий с примером</a>. Если есть время, рекомендую ознакомиться.</p>

<p>А так как я являюсь яростным сторонником <strong>git-blame-driven подхода</strong>, то мне бы очень не хотелось по какому-то спорному изменению видеть в git blame имя коммита <code class="highlighter-rouge">Merge branch 'feature/fix-some-bug' into 'master'</code>, а хотелось бы видеть непосредственно тот коммит, к которому логически это изменение относится.</p>

<p>Кстати, это делает меня сторонником крайне спорного подхода: прежде, чем <em>мержить</em> свою ветку в <code class="highlighter-rouge">master</code>, неплохо бы её отребейзить на тот же <code class="highlighter-rouge">master</code>, чтобы и получить логическое преимущество наличия merge-коммита и при этом не потерять корректный git blame.</p>

<h4 id="к-различиям-в-коде">«К различиям в коде»</h4>
<p>А вот тут самое интересное. Потому как остальные различия не относятся к результату <em>в коде</em>, а только к истории.</p>

<p>Можно что-то и поломать. Давайте посмотрим.<br />
Я приведу полный листинг bash-команд без комментариев, а дальше вы уж как-нибудь сами разберётесь.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Создаём репозиторий</span>
git init <span class="nb">.</span>

<span class="c"># Создаём первый коммит с единственным файлом</span>
<span class="nb">echo</span> <span class="s2">"some string"</span> <span class="o">&gt;</span> file.txt
git add file.txt
git commit <span class="nt">-m</span> <span class="s2">"Initial commit"</span>

<span class="c"># Создаём две ветки, в которых будем играться изменениями</span>
git branch branch-1
git branch branch-2

<span class="c"># Изменяем единственную строку в ветке branch-1</span>
git checkout branch-1
<span class="nb">echo</span> <span class="s2">"some string // changed"</span> <span class="o">&gt;</span> file.txt
git add file.txt
git commit <span class="nt">-m</span> <span class="s2">"Changed line 2 on branch 1"</span>

<span class="c"># Изменяем единственную строку в ветке branch-2</span>
git checkout branch-2
<span class="nb">echo</span> <span class="s2">"some string // changed"</span> <span class="o">&gt;</span> file.txt
git add file.txt
git commit <span class="nt">-m</span> <span class="s2">"Changed line 2 on branch 2"</span>

<span class="c"># Откатываем единственную строку в файле branch-2</span>
<span class="nb">echo</span> <span class="s2">"some string"</span> <span class="o">&gt;</span> file.txt
git add file.txt
git commit <span class="nt">-m</span> <span class="s2">"Reverted line 2 on branch 2"</span>

<span class="c"># Создаём копию ветки для того, чтобы попробовать и merge и rebase</span>
git branch branch-2-non-modified

<span class="c"># Делаем git merge</span>
git merge <span class="nt">--no-edit</span> branch-1
<span class="nb">cat </span>file.txt
<span class="c"># Получаем some string // changed</span>

<span class="c"># Возвращаем branch-2 к до-merge-состоянию</span>
git reset <span class="nt">--hard</span> branch-2-non-modified

<span class="c"># Делаем git rebase</span>
git rebase branch-1
<span class="nb">cat </span>file.txt
<span class="c"># Получаем some string</span>
</code></pre></div></div>

<p>Интересно получилось? Вот и мне интересно. Особенно если кандидат про это расскажет (без листинга и подробностей, конечно) на собеседовании.</p>

<p>Почему так происходит? Думайте, гуглите, дальше мне лень простыню писать. Особенно с учётом того, что при описании такого последствия кандидатом дальнейших объяснений не потребуется — и так понятно, что кандидат с git работал достаточно глубоко.</p>

  </div>

  

  
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">ivalentinee</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">ivalentinee</li><li><a class="u-email" href="mailto:valentine.emperor@gmail.com">valentine.emperor@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ivalentinee"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ivalentinee</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
