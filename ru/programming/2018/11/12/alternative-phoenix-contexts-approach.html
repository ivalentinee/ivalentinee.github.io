<!DOCTYPE html>
<html lang="ru"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Используем контексты из Phoenix по-другому | ivalentinee</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Используем контексты из Phoenix по-другому" />
<meta property="og:locale" content="ru" />
<meta name="description" content="Предисловие Обычно в предисловии я рассказываю, что меня привело к появлению текста статьи. Этот раз — не исключение. Для тех, кто не знает, что такое контексты в phoenix, вот ссылка. А побудило меня то, что понадобилось мне в некоторых контекстах использовать одну и ту же модель. Можно использовать подход вида alias MyApp.AnotherContext.MyModel, но выглядит это как костыль. Описанный мной подход делает небольшой шаг в сторону разделения архитектурных слоёв. Не то чтобы мы уже там были, но ведь и Рим не один день строился. Описаний будет мало, в основном листинги. Так как с момента написания оригинального текста статьи прошло несколько лет, могу с уверенностью сказать, что все описанные подходы работают хорошо. Верхнеуровнево Контексты уезжают в папку contexts, модели уезжают в папку models, в ту же папку models складываем всё, что связано с Ecto.Query. Это слишком коротко, поэтому сейчас я начну пояснять подробнее приводить примеры. Увозим модели в models Пожалуй, самый важный пункт. Остальное — следствия. Под моделями в данном случае подразумеваются файлы, содержащие схемы данных (Ecto.Schema) и changeset’ы (про changeset’ы подробно расписано ниже): # lib/my_app/models/pizza.ex defmodule MyApp.Models.Pizza do use Ecto.Schema import Ecto.Changeset schema &quot;pizzas&quot; do field(:name, :string) field(:description, :string) field(:discounted, :boolean) timestamps() end def changeset(struct, params) do struct |&gt; cast(attrs, [:name, :description]) |&gt; validate_required([:name]) end end Такой переезд позволяет нам выделить слой работы с хранилищем данных (то есть описания, требуемые для ORM). И заодно решает проблему использования одной модели в нескольких контекстах. Создаём файл для функций выборки Раз уж увозим слой хранения, то увозим его полностью: # lib/my_app/models/pizza/query.ex defmodule MyApp.Models.Pizza.Query do import Ecto.Query, warn: false require Ecto.Query def discounted(query) do from(q in query, where: discounted == true) end def non_discounted(query) do from(q in query, where: discounted != true) end def by_id(query) do from(q in query, order_by: [desc: q.id]) end end Тут же про changeset’ы Changeset’ы тоже можно увезти в отдельный файл (или даже несколько), чтобы не засорять файл со схемой. Например в lib/my_app/models/pizza/changesets.ex. Используем это всё в контексте Контексты же уезжают в свою отдельную папку, формируя слой обработки данных. Назвать это бизнес-логикой у меня язык клавиатура не поворачивается не даёт. # lib/my_app/contexts/pizzas.ex defmodule MyApp.Contexts.Pizzas do alias MyApp.Models.Pizza alias MyApp.Models.Pizza.Query alias MyApp.Repo def list do list_query() |&gt; Query.non_discounted() |&gt; Repo.all() end def get!(id) do Pizza |&gt; Query.non_discounted() |&gt; Repo.get!(id) end def get_by!(clauses) do Pizza |&gt; Query.non_discounted() |&gt; Repo.get_by!(clauses) end def create(params) do changeset = Pizza.changeset(%Pizza{}, params) Repo.insert(changeset) end def update(%Pizza{} = pizza, params) do pizza |&gt; Pizza.changeset(params) |&gt; Repo.update() end end Про changeset’ы (UPD 2021.10.05) Если не трогать schemaless changeset’ы, то мой опыт общения с Ecto позволяет выделить два вида changeset’ов: для хранения и для обработки. Changeset’ы для хранения Эти changeset’ы нужны по большей части для того, чтобы ошибки СУБД возвращались не исключениями, а ошибками в changeset’ах. Это место для того, чтобы делать validate_required для полей, которые помечены как обязательные в схеме БД и делать обработки вроде unique_constraint, check_constraint и foreign_key_constraint. Нужно ли в этих changeset’ах делать какие-либо cast’ы? Для меня это открытый вопрос, потому что было бы нелогично требовать обязательность полей, но при этом эти поля ничем не заполнять. Однако при обязательном комбинировании обоих видов changeset’ов можно ничего здесь не кастовать. Эти changeset’ы должны быть по одному на “модель”, принимать на вход только другие changeset’ы (что позволяет нам явно указать на то, что cast должен делаться где-то в другом месте) и, очевидно, описываться внутри файлов модели. Пример: # lib/my_app/models/pizza.ex defmodule MyApp.Models.Pizza do use Ecto.Schema alias Ecto.Changeset import Ecto.Changeset schema &quot;pizzas&quot; do field(:name, :string) field(:description, :string) field(:discounted, :boolean) timestamps() end def db_changeset(%Changeset{} = changeset) do changeset |&gt; validate_required([:name]) |&gt; unique_constraint(:name, name: :unique_name_index) end end Changeset’ы для обработки Вот тут всё интереснее. Эти changeset’ы должны описываться в контестах и использоваться как входные для changeset’ов хранения. Допустим, в одном месте мы можем редактировать название и описание, а в другом — только описание. В соответствующих контекстах у нас будет следующий (гипотетический) код: defmodule MyApp.Contexts.Admin.Pizzas do alias Ecto.Changeset alias MyApp.Models.Pizza alias MyApp.Repo def update(%Pizza{} = pizza, params) do pizza |&gt; changeset(params) |&gt; Repo.update() end def changeset(%Pizza{} = pizza, params) do pizza |&gt; Changeset.cast(params, [:name, :description]) |&gt; Pizza.db_changeset() end end defmodule MyApp.Contexts.Manager.Pizzas do alias Ecto.Changeset alias MyApp.Models.Pizza alias MyApp.Repo def update(%Pizza{} = pizza, params) do pizza |&gt; changeset(params) |&gt; Repo.update() end def changeset(%Pizza{} = pizza, params) do pizza |&gt; Changeset.cast(params, [:description]) |&gt; Changeset.validate_required([:description]) |&gt; Pizza.db_changeset() end end В результате вместо того, чтобы плодить в области хранения данных их обработку в виде def admin_changeset(struct, params) и def manager_changeset(struct, params) мы пишем специфичные для каждого пользовательского сценария changeset’ы в том месте, где описываем сам сценарий. Выглядит это так себе Потому что одним и тем же словом “changeset” (да и механизмом, если смотреть под капот) мы описываем два совершенно разных действия: работу с базой данных и работу с пользовательским вводом. Единственное, что я могу придумать в данной ситуации — делать такие названия changeset’ам, чтобы было понятно, какие относятся к БД, а какие — к обработке пользовательских сценариев. Шлюзы (UPD 2021-10-10) Ещё немного про структуру проекта. Многие сервисы взаимодействуют с другими сервисами (HTTP, MQ и т.п.). Такой слой “взаимодействия” должен быть отделён от всего прочего (по моему мнению). Обычно я использую для этого директорию “lib/my_app/gateways”. Пример: # lib/my_app/gateways/some_other_service.ex defmodule MyApp.Gateways.SomeOtherService do @items_url &quot;http://example.com/items&quot; def get_items do request = {@items_url, []} with {:ok, { {_, 200, _}, _, raw_response}} &lt;- :httpc.request(:get, request, [], []), {:ok, response} &lt;- Jason.decode(raw_response) do response[&quot;items&quot;] end end end # lib/my_app/contexts/items.ex defmodule MyApp.Contexts.Items do alias MyApp.Gateways.SomeOtherService, as: SomeOtherServiceGateway def load_items do case SomeOtherServiceGateway.get_items() do {:ok, items} -&gt; save_items(items) error -&gt; error end end def save_items do # save items to DB end end Инверсия зависимостей Ну, почти. Чаще всего сторонний сервис недоступен с локальной машины, поэтому приходится использовать “подставной” сервис. В таком случае вместо использования модулей шлюзов напрямую могут быть получены модули в зависимости от конфигурации через вызов функции. Пример: # config/dev.exs # ... config :my_app, :use_fake_other_service, true # ... # lib/my_app/gateways.ex defmodule MyApp.Gateways do alias MyApp.Gateways.OtherService alias MyApp.Gateways.OtherService.Fake, as: FakeOtherService def other_service do if Application.get_env(:my_app, :use_fake_other_service) do FakeOtherService else OtherService end end end # lib/my_app/gateways/other_service/fake.ex defmodule MyApp.Gateways.OtherService.Fake do def get_items, do: {:ok, [1, 2, 3, 4, 5]} end # lib/my_app/contexts/items.ex defmodule MyApp.Contexts.Items do alias MyApp.Gateways def load_items do case Gateways.other_service().get_items() do {:ok, items} -&gt; save_items(items) error -&gt; error end end def save_items do # save items to DB end end" />
<meta property="og:description" content="Предисловие Обычно в предисловии я рассказываю, что меня привело к появлению текста статьи. Этот раз — не исключение. Для тех, кто не знает, что такое контексты в phoenix, вот ссылка. А побудило меня то, что понадобилось мне в некоторых контекстах использовать одну и ту же модель. Можно использовать подход вида alias MyApp.AnotherContext.MyModel, но выглядит это как костыль. Описанный мной подход делает небольшой шаг в сторону разделения архитектурных слоёв. Не то чтобы мы уже там были, но ведь и Рим не один день строился. Описаний будет мало, в основном листинги. Так как с момента написания оригинального текста статьи прошло несколько лет, могу с уверенностью сказать, что все описанные подходы работают хорошо. Верхнеуровнево Контексты уезжают в папку contexts, модели уезжают в папку models, в ту же папку models складываем всё, что связано с Ecto.Query. Это слишком коротко, поэтому сейчас я начну пояснять подробнее приводить примеры. Увозим модели в models Пожалуй, самый важный пункт. Остальное — следствия. Под моделями в данном случае подразумеваются файлы, содержащие схемы данных (Ecto.Schema) и changeset’ы (про changeset’ы подробно расписано ниже): # lib/my_app/models/pizza.ex defmodule MyApp.Models.Pizza do use Ecto.Schema import Ecto.Changeset schema &quot;pizzas&quot; do field(:name, :string) field(:description, :string) field(:discounted, :boolean) timestamps() end def changeset(struct, params) do struct |&gt; cast(attrs, [:name, :description]) |&gt; validate_required([:name]) end end Такой переезд позволяет нам выделить слой работы с хранилищем данных (то есть описания, требуемые для ORM). И заодно решает проблему использования одной модели в нескольких контекстах. Создаём файл для функций выборки Раз уж увозим слой хранения, то увозим его полностью: # lib/my_app/models/pizza/query.ex defmodule MyApp.Models.Pizza.Query do import Ecto.Query, warn: false require Ecto.Query def discounted(query) do from(q in query, where: discounted == true) end def non_discounted(query) do from(q in query, where: discounted != true) end def by_id(query) do from(q in query, order_by: [desc: q.id]) end end Тут же про changeset’ы Changeset’ы тоже можно увезти в отдельный файл (или даже несколько), чтобы не засорять файл со схемой. Например в lib/my_app/models/pizza/changesets.ex. Используем это всё в контексте Контексты же уезжают в свою отдельную папку, формируя слой обработки данных. Назвать это бизнес-логикой у меня язык клавиатура не поворачивается не даёт. # lib/my_app/contexts/pizzas.ex defmodule MyApp.Contexts.Pizzas do alias MyApp.Models.Pizza alias MyApp.Models.Pizza.Query alias MyApp.Repo def list do list_query() |&gt; Query.non_discounted() |&gt; Repo.all() end def get!(id) do Pizza |&gt; Query.non_discounted() |&gt; Repo.get!(id) end def get_by!(clauses) do Pizza |&gt; Query.non_discounted() |&gt; Repo.get_by!(clauses) end def create(params) do changeset = Pizza.changeset(%Pizza{}, params) Repo.insert(changeset) end def update(%Pizza{} = pizza, params) do pizza |&gt; Pizza.changeset(params) |&gt; Repo.update() end end Про changeset’ы (UPD 2021.10.05) Если не трогать schemaless changeset’ы, то мой опыт общения с Ecto позволяет выделить два вида changeset’ов: для хранения и для обработки. Changeset’ы для хранения Эти changeset’ы нужны по большей части для того, чтобы ошибки СУБД возвращались не исключениями, а ошибками в changeset’ах. Это место для того, чтобы делать validate_required для полей, которые помечены как обязательные в схеме БД и делать обработки вроде unique_constraint, check_constraint и foreign_key_constraint. Нужно ли в этих changeset’ах делать какие-либо cast’ы? Для меня это открытый вопрос, потому что было бы нелогично требовать обязательность полей, но при этом эти поля ничем не заполнять. Однако при обязательном комбинировании обоих видов changeset’ов можно ничего здесь не кастовать. Эти changeset’ы должны быть по одному на “модель”, принимать на вход только другие changeset’ы (что позволяет нам явно указать на то, что cast должен делаться где-то в другом месте) и, очевидно, описываться внутри файлов модели. Пример: # lib/my_app/models/pizza.ex defmodule MyApp.Models.Pizza do use Ecto.Schema alias Ecto.Changeset import Ecto.Changeset schema &quot;pizzas&quot; do field(:name, :string) field(:description, :string) field(:discounted, :boolean) timestamps() end def db_changeset(%Changeset{} = changeset) do changeset |&gt; validate_required([:name]) |&gt; unique_constraint(:name, name: :unique_name_index) end end Changeset’ы для обработки Вот тут всё интереснее. Эти changeset’ы должны описываться в контестах и использоваться как входные для changeset’ов хранения. Допустим, в одном месте мы можем редактировать название и описание, а в другом — только описание. В соответствующих контекстах у нас будет следующий (гипотетический) код: defmodule MyApp.Contexts.Admin.Pizzas do alias Ecto.Changeset alias MyApp.Models.Pizza alias MyApp.Repo def update(%Pizza{} = pizza, params) do pizza |&gt; changeset(params) |&gt; Repo.update() end def changeset(%Pizza{} = pizza, params) do pizza |&gt; Changeset.cast(params, [:name, :description]) |&gt; Pizza.db_changeset() end end defmodule MyApp.Contexts.Manager.Pizzas do alias Ecto.Changeset alias MyApp.Models.Pizza alias MyApp.Repo def update(%Pizza{} = pizza, params) do pizza |&gt; changeset(params) |&gt; Repo.update() end def changeset(%Pizza{} = pizza, params) do pizza |&gt; Changeset.cast(params, [:description]) |&gt; Changeset.validate_required([:description]) |&gt; Pizza.db_changeset() end end В результате вместо того, чтобы плодить в области хранения данных их обработку в виде def admin_changeset(struct, params) и def manager_changeset(struct, params) мы пишем специфичные для каждого пользовательского сценария changeset’ы в том месте, где описываем сам сценарий. Выглядит это так себе Потому что одним и тем же словом “changeset” (да и механизмом, если смотреть под капот) мы описываем два совершенно разных действия: работу с базой данных и работу с пользовательским вводом. Единственное, что я могу придумать в данной ситуации — делать такие названия changeset’ам, чтобы было понятно, какие относятся к БД, а какие — к обработке пользовательских сценариев. Шлюзы (UPD 2021-10-10) Ещё немного про структуру проекта. Многие сервисы взаимодействуют с другими сервисами (HTTP, MQ и т.п.). Такой слой “взаимодействия” должен быть отделён от всего прочего (по моему мнению). Обычно я использую для этого директорию “lib/my_app/gateways”. Пример: # lib/my_app/gateways/some_other_service.ex defmodule MyApp.Gateways.SomeOtherService do @items_url &quot;http://example.com/items&quot; def get_items do request = {@items_url, []} with {:ok, { {_, 200, _}, _, raw_response}} &lt;- :httpc.request(:get, request, [], []), {:ok, response} &lt;- Jason.decode(raw_response) do response[&quot;items&quot;] end end end # lib/my_app/contexts/items.ex defmodule MyApp.Contexts.Items do alias MyApp.Gateways.SomeOtherService, as: SomeOtherServiceGateway def load_items do case SomeOtherServiceGateway.get_items() do {:ok, items} -&gt; save_items(items) error -&gt; error end end def save_items do # save items to DB end end Инверсия зависимостей Ну, почти. Чаще всего сторонний сервис недоступен с локальной машины, поэтому приходится использовать “подставной” сервис. В таком случае вместо использования модулей шлюзов напрямую могут быть получены модули в зависимости от конфигурации через вызов функции. Пример: # config/dev.exs # ... config :my_app, :use_fake_other_service, true # ... # lib/my_app/gateways.ex defmodule MyApp.Gateways do alias MyApp.Gateways.OtherService alias MyApp.Gateways.OtherService.Fake, as: FakeOtherService def other_service do if Application.get_env(:my_app, :use_fake_other_service) do FakeOtherService else OtherService end end end # lib/my_app/gateways/other_service/fake.ex defmodule MyApp.Gateways.OtherService.Fake do def get_items, do: {:ok, [1, 2, 3, 4, 5]} end # lib/my_app/contexts/items.ex defmodule MyApp.Contexts.Items do alias MyApp.Gateways def load_items do case Gateways.other_service().get_items() do {:ok, items} -&gt; save_items(items) error -&gt; error end end def save_items do # save items to DB end end" />
<link rel="canonical" href="https://ivalentinee.github.io/ru/programming/2018/11/12/alternative-phoenix-contexts-approach.html" />
<meta property="og:url" content="https://ivalentinee.github.io/ru/programming/2018/11/12/alternative-phoenix-contexts-approach.html" />
<meta property="og:site_name" content="ivalentinee" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-11-12T00:00:00+00:00" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"https://ivalentinee.github.io/ru/programming/2018/11/12/alternative-phoenix-contexts-approach.html"},"description":"Предисловие Обычно в предисловии я рассказываю, что меня привело к появлению текста статьи. Этот раз — не исключение. Для тех, кто не знает, что такое контексты в phoenix, вот ссылка. А побудило меня то, что понадобилось мне в некоторых контекстах использовать одну и ту же модель. Можно использовать подход вида alias MyApp.AnotherContext.MyModel, но выглядит это как костыль. Описанный мной подход делает небольшой шаг в сторону разделения архитектурных слоёв. Не то чтобы мы уже там были, но ведь и Рим не один день строился. Описаний будет мало, в основном листинги. Так как с момента написания оригинального текста статьи прошло несколько лет, могу с уверенностью сказать, что все описанные подходы работают хорошо. Верхнеуровнево Контексты уезжают в папку contexts, модели уезжают в папку models, в ту же папку models складываем всё, что связано с Ecto.Query. Это слишком коротко, поэтому сейчас я начну пояснять подробнее приводить примеры. Увозим модели в models Пожалуй, самый важный пункт. Остальное — следствия. Под моделями в данном случае подразумеваются файлы, содержащие схемы данных (Ecto.Schema) и changeset’ы (про changeset’ы подробно расписано ниже): # lib/my_app/models/pizza.ex defmodule MyApp.Models.Pizza do use Ecto.Schema import Ecto.Changeset schema &quot;pizzas&quot; do field(:name, :string) field(:description, :string) field(:discounted, :boolean) timestamps() end def changeset(struct, params) do struct |&gt; cast(attrs, [:name, :description]) |&gt; validate_required([:name]) end end Такой переезд позволяет нам выделить слой работы с хранилищем данных (то есть описания, требуемые для ORM). И заодно решает проблему использования одной модели в нескольких контекстах. Создаём файл для функций выборки Раз уж увозим слой хранения, то увозим его полностью: # lib/my_app/models/pizza/query.ex defmodule MyApp.Models.Pizza.Query do import Ecto.Query, warn: false require Ecto.Query def discounted(query) do from(q in query, where: discounted == true) end def non_discounted(query) do from(q in query, where: discounted != true) end def by_id(query) do from(q in query, order_by: [desc: q.id]) end end Тут же про changeset’ы Changeset’ы тоже можно увезти в отдельный файл (или даже несколько), чтобы не засорять файл со схемой. Например в lib/my_app/models/pizza/changesets.ex. Используем это всё в контексте Контексты же уезжают в свою отдельную папку, формируя слой обработки данных. Назвать это бизнес-логикой у меня язык клавиатура не поворачивается не даёт. # lib/my_app/contexts/pizzas.ex defmodule MyApp.Contexts.Pizzas do alias MyApp.Models.Pizza alias MyApp.Models.Pizza.Query alias MyApp.Repo def list do list_query() |&gt; Query.non_discounted() |&gt; Repo.all() end def get!(id) do Pizza |&gt; Query.non_discounted() |&gt; Repo.get!(id) end def get_by!(clauses) do Pizza |&gt; Query.non_discounted() |&gt; Repo.get_by!(clauses) end def create(params) do changeset = Pizza.changeset(%Pizza{}, params) Repo.insert(changeset) end def update(%Pizza{} = pizza, params) do pizza |&gt; Pizza.changeset(params) |&gt; Repo.update() end end Про changeset’ы (UPD 2021.10.05) Если не трогать schemaless changeset’ы, то мой опыт общения с Ecto позволяет выделить два вида changeset’ов: для хранения и для обработки. Changeset’ы для хранения Эти changeset’ы нужны по большей части для того, чтобы ошибки СУБД возвращались не исключениями, а ошибками в changeset’ах. Это место для того, чтобы делать validate_required для полей, которые помечены как обязательные в схеме БД и делать обработки вроде unique_constraint, check_constraint и foreign_key_constraint. Нужно ли в этих changeset’ах делать какие-либо cast’ы? Для меня это открытый вопрос, потому что было бы нелогично требовать обязательность полей, но при этом эти поля ничем не заполнять. Однако при обязательном комбинировании обоих видов changeset’ов можно ничего здесь не кастовать. Эти changeset’ы должны быть по одному на “модель”, принимать на вход только другие changeset’ы (что позволяет нам явно указать на то, что cast должен делаться где-то в другом месте) и, очевидно, описываться внутри файлов модели. Пример: # lib/my_app/models/pizza.ex defmodule MyApp.Models.Pizza do use Ecto.Schema alias Ecto.Changeset import Ecto.Changeset schema &quot;pizzas&quot; do field(:name, :string) field(:description, :string) field(:discounted, :boolean) timestamps() end def db_changeset(%Changeset{} = changeset) do changeset |&gt; validate_required([:name]) |&gt; unique_constraint(:name, name: :unique_name_index) end end Changeset’ы для обработки Вот тут всё интереснее. Эти changeset’ы должны описываться в контестах и использоваться как входные для changeset’ов хранения. Допустим, в одном месте мы можем редактировать название и описание, а в другом — только описание. В соответствующих контекстах у нас будет следующий (гипотетический) код: defmodule MyApp.Contexts.Admin.Pizzas do alias Ecto.Changeset alias MyApp.Models.Pizza alias MyApp.Repo def update(%Pizza{} = pizza, params) do pizza |&gt; changeset(params) |&gt; Repo.update() end def changeset(%Pizza{} = pizza, params) do pizza |&gt; Changeset.cast(params, [:name, :description]) |&gt; Pizza.db_changeset() end end defmodule MyApp.Contexts.Manager.Pizzas do alias Ecto.Changeset alias MyApp.Models.Pizza alias MyApp.Repo def update(%Pizza{} = pizza, params) do pizza |&gt; changeset(params) |&gt; Repo.update() end def changeset(%Pizza{} = pizza, params) do pizza |&gt; Changeset.cast(params, [:description]) |&gt; Changeset.validate_required([:description]) |&gt; Pizza.db_changeset() end end В результате вместо того, чтобы плодить в области хранения данных их обработку в виде def admin_changeset(struct, params) и def manager_changeset(struct, params) мы пишем специфичные для каждого пользовательского сценария changeset’ы в том месте, где описываем сам сценарий. Выглядит это так себе Потому что одним и тем же словом “changeset” (да и механизмом, если смотреть под капот) мы описываем два совершенно разных действия: работу с базой данных и работу с пользовательским вводом. Единственное, что я могу придумать в данной ситуации — делать такие названия changeset’ам, чтобы было понятно, какие относятся к БД, а какие — к обработке пользовательских сценариев. Шлюзы (UPD 2021-10-10) Ещё немного про структуру проекта. Многие сервисы взаимодействуют с другими сервисами (HTTP, MQ и т.п.). Такой слой “взаимодействия” должен быть отделён от всего прочего (по моему мнению). Обычно я использую для этого директорию “lib/my_app/gateways”. Пример: # lib/my_app/gateways/some_other_service.ex defmodule MyApp.Gateways.SomeOtherService do @items_url &quot;http://example.com/items&quot; def get_items do request = {@items_url, []} with {:ok, { {_, 200, _}, _, raw_response}} &lt;- :httpc.request(:get, request, [], []), {:ok, response} &lt;- Jason.decode(raw_response) do response[&quot;items&quot;] end end end # lib/my_app/contexts/items.ex defmodule MyApp.Contexts.Items do alias MyApp.Gateways.SomeOtherService, as: SomeOtherServiceGateway def load_items do case SomeOtherServiceGateway.get_items() do {:ok, items} -&gt; save_items(items) error -&gt; error end end def save_items do # save items to DB end end Инверсия зависимостей Ну, почти. Чаще всего сторонний сервис недоступен с локальной машины, поэтому приходится использовать “подставной” сервис. В таком случае вместо использования модулей шлюзов напрямую могут быть получены модули в зависимости от конфигурации через вызов функции. Пример: # config/dev.exs # ... config :my_app, :use_fake_other_service, true # ... # lib/my_app/gateways.ex defmodule MyApp.Gateways do alias MyApp.Gateways.OtherService alias MyApp.Gateways.OtherService.Fake, as: FakeOtherService def other_service do if Application.get_env(:my_app, :use_fake_other_service) do FakeOtherService else OtherService end end end # lib/my_app/gateways/other_service/fake.ex defmodule MyApp.Gateways.OtherService.Fake do def get_items, do: {:ok, [1, 2, 3, 4, 5]} end # lib/my_app/contexts/items.ex defmodule MyApp.Contexts.Items do alias MyApp.Gateways def load_items do case Gateways.other_service().get_items() do {:ok, items} -&gt; save_items(items) error -&gt; error end end def save_items do # save items to DB end end","@type":"BlogPosting","url":"https://ivalentinee.github.io/ru/programming/2018/11/12/alternative-phoenix-contexts-approach.html","headline":"Используем контексты из Phoenix по-другому","dateModified":"2018-11-12T00:00:00+00:00","datePublished":"2018-11-12T00:00:00+00:00","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://ivalentinee.github.io/feed.xml" title="ivalentinee" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/ru/">ivalentinee</a>

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
            
          
            
            
              
                <a class="page-link" href="/ru/about/">Обо мне</a>
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
          
            
            
          
            
            
              
            
          
            
            
          
            
            
              
            
          
            
            
              
            
          
            
            
          
            
            
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Используем контексты из Phoenix по-другому</h1>
    <p class="post-meta">
      <time datetime="2018-11-12T00:00:00+00:00" itemprop="datePublished">
        
        Nov 12, 2018
      </time>
      </p>
  </header>

          <div class="language-selector">
          <a href="/en/programming/2018/11/12/alternative-phoenix-contexts-approach.html" class="language-selector-link">English</a><span class="language-selector-separator">|</span><span class="language-selector-link">Русский</span>
        </div>


  <div class="post-content" itemprop="articleBody">
    <h2 id="предисловие">Предисловие</h2>
<p>Обычно в предисловии я рассказываю, что меня привело к появлению текста статьи. Этот раз — не исключение.</p>

<p>Для тех, кто не знает, что такое <em>контексты</em> в phoenix, вот <a href="https://hexdocs.pm/phoenix/contexts.html">ссылка</a>.</p>

<p>А побудило меня то, что понадобилось мне в некоторых контекстах использовать одну и ту же модель. Можно использовать подход вида <code class="highlighter-rouge">alias MyApp.AnotherContext.MyModel</code>, но выглядит это как костыль.</p>

<p>Описанный мной подход делает небольшой шаг в сторону <a href="http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">разделения архитектурных слоёв</a>. Не то чтобы мы уже там были, но ведь и Рим не один день строился.</p>

<p>Описаний будет мало, в основном листинги.</p>

<p>Так как с момента написания оригинального текста статьи прошло несколько лет, могу с уверенностью сказать, что все описанные подходы работают хорошо.</p>

<h2 id="верхнеуровнево">Верхнеуровнево</h2>
<p>Контексты уезжают в папку <code class="highlighter-rouge">contexts</code>, модели уезжают в папку <code class="highlighter-rouge">models</code>, в ту же папку <code class="highlighter-rouge">models</code> складываем всё, что связано с <code class="highlighter-rouge">Ecto.Query</code>.</p>

<p>Это слишком коротко, поэтому сейчас я начну <del>пояснять подробнее</del> приводить примеры.</p>

<h2 id="увозим-модели-в-models">Увозим модели в <code class="highlighter-rouge">models</code></h2>
<p>Пожалуй, самый важный пункт. Остальное — следствия.</p>

<p>Под моделями в данном случае подразумеваются файлы, содержащие <strong>схемы данных</strong> (<code class="highlighter-rouge">Ecto.Schema</code>) и <strong>changeset’ы</strong> (про changeset’ы подробно расписано ниже):</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/my_app/models/pizza.ex</span>

<span class="k">defmodule</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Models</span><span class="o">.</span><span class="no">Pizza</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Schema</span>

  <span class="kn">import</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Changeset</span>

  <span class="n">schema</span> <span class="sd">"</span><span class="s2">pizzas"</span> <span class="k">do</span>
    <span class="n">field</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:string</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="ss">:description</span><span class="p">,</span> <span class="ss">:string</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="ss">:discounted</span><span class="p">,</span> <span class="ss">:boolean</span><span class="p">)</span>
    <span class="n">timestamps</span><span class="p">()</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">changeset</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">struct</span>
    <span class="o">|&gt;</span> <span class="n">cast</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="p">[</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:description</span><span class="p">])</span>
    <span class="o">|&gt;</span> <span class="n">validate_required</span><span class="p">([</span><span class="ss">:name</span><span class="p">])</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Такой переезд позволяет нам выделить слой работы с хранилищем данных (то есть описания, требуемые для ORM). И заодно решает проблему использования одной модели в нескольких контекстах.</p>

<h3 id="создаём-файл-для-функций-выборки">Создаём файл для функций выборки</h3>
<p>Раз уж увозим <strong>слой хранения</strong>, то увозим его полностью:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/my_app/models/pizza/query.ex</span>

<span class="k">defmodule</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Models</span><span class="o">.</span><span class="no">Pizza</span><span class="o">.</span><span class="no">Query</span> <span class="k">do</span>
  <span class="kn">import</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Query</span><span class="p">,</span> <span class="ss">warn:</span> <span class="no">false</span>
  <span class="kn">require</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Query</span>

  <span class="k">def</span> <span class="n">discounted</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">from</span><span class="p">(</span><span class="n">q</span> <span class="ow">in</span> <span class="n">query</span><span class="p">,</span> <span class="ss">where:</span> <span class="n">discounted</span> <span class="o">==</span> <span class="no">true</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">non_discounted</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">from</span><span class="p">(</span><span class="n">q</span> <span class="ow">in</span> <span class="n">query</span><span class="p">,</span> <span class="ss">where:</span> <span class="n">discounted</span> <span class="o">!=</span> <span class="no">true</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">by_id</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">from</span><span class="p">(</span><span class="n">q</span> <span class="ow">in</span> <span class="n">query</span><span class="p">,</span> <span class="ss">order_by:</span> <span class="p">[</span><span class="ss">desc:</span> <span class="n">q</span><span class="o">.</span><span class="n">id</span><span class="p">])</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="тут-же-про-changesetы">Тут же про changeset’ы</h3>
<p>Changeset’ы тоже можно увезти в отдельный файл (или даже несколько), чтобы не засорять файл со схемой. Например в <code class="highlighter-rouge">lib/my_app/models/pizza/changesets.ex</code>.</p>

<h2 id="используем-это-всё-в-контексте">Используем это всё в контексте</h2>
<p>Контексты же уезжают в свою отдельную папку, формируя слой <em>обработки данных</em>. Назвать это <em>бизнес-логикой</em> у меня <del>язык</del> клавиатура <del>не поворачивается</del> не даёт.</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/my_app/contexts/pizzas.ex</span>

<span class="k">defmodule</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Contexts</span><span class="o">.</span><span class="no">Pizzas</span> <span class="k">do</span>
  <span class="n">alias</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Models</span><span class="o">.</span><span class="no">Pizza</span>
  <span class="n">alias</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Models</span><span class="o">.</span><span class="no">Pizza</span><span class="o">.</span><span class="no">Query</span>
  <span class="n">alias</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Repo</span>

  <span class="k">def</span> <span class="n">list</span> <span class="k">do</span>
    <span class="n">list_query</span><span class="p">()</span>
    <span class="o">|&gt;</span> <span class="no">Query</span><span class="o">.</span><span class="n">non_discounted</span><span class="p">()</span>
    <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">get!</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">Pizza</span>
    <span class="o">|&gt;</span> <span class="no">Query</span><span class="o">.</span><span class="n">non_discounted</span><span class="p">()</span>
    <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">get!</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">get_by!</span><span class="p">(</span><span class="n">clauses</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">Pizza</span>
    <span class="o">|&gt;</span> <span class="no">Query</span><span class="o">.</span><span class="n">non_discounted</span><span class="p">()</span>
    <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">get_by!</span><span class="p">(</span><span class="n">clauses</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">create</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">changeset</span> <span class="o">=</span> <span class="no">Pizza</span><span class="o">.</span><span class="n">changeset</span><span class="p">(%</span><span class="no">Pizza</span><span class="p">{},</span> <span class="n">params</span><span class="p">)</span>
    <span class="no">Repo</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">changeset</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">update</span><span class="p">(%</span><span class="no">Pizza</span><span class="p">{}</span> <span class="o">=</span> <span class="n">pizza</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">pizza</span>
    <span class="o">|&gt;</span> <span class="no">Pizza</span><span class="o">.</span><span class="n">changeset</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="про-changesetы-upd-20211005">Про changeset’ы (UPD 2021.10.05)</h2>
<p>Если не трогать schemaless changeset’ы, то мой опыт общения с Ecto позволяет выделить два вида changeset’ов: для <em>хранения</em> и для <em>обработки</em>.</p>

<h3 id="changesetы-для-хранения">Changeset’ы для хранения</h3>
<p>Эти changeset’ы нужны по большей части для того, чтобы ошибки СУБД возвращались не исключениями, а ошибками в changeset’ах.</p>

<p>Это место для того, чтобы делать <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html#validate_required/3"><code class="highlighter-rouge">validate_required</code></a> для полей, которые помечены как обязательные в схеме БД и делать обработки вроде <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html#unique_constraint/3"><code class="highlighter-rouge">unique_constraint</code></a>, <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html#check_constraint/3"><code class="highlighter-rouge">check_constraint</code></a> и <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html#foreign_key_constraint/3"><code class="highlighter-rouge">foreign_key_constraint</code></a>.</p>

<p>Нужно ли в этих changeset’ах делать какие-либо cast’ы? Для меня это открытый вопрос, потому что было бы нелогично требовать обязательность полей, но при этом эти поля ничем не заполнять. Однако при обязательном комбинировании обоих видов changeset’ов можно ничего здесь не кастовать.</p>

<p>Эти changeset’ы должны быть по одному на “модель”, принимать на вход только другие changeset’ы (что позволяет нам <strong>явно</strong> указать на то, что <code class="highlighter-rouge">cast</code> должен делаться где-то в другом месте) и, очевидно, описываться внутри файлов модели.</p>

<p>Пример:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/my_app/models/pizza.ex</span>

<span class="k">defmodule</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Models</span><span class="o">.</span><span class="no">Pizza</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Schema</span>

  <span class="n">alias</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Changeset</span>
  <span class="kn">import</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Changeset</span>

  <span class="n">schema</span> <span class="sd">"</span><span class="s2">pizzas"</span> <span class="k">do</span>
    <span class="n">field</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:string</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="ss">:description</span><span class="p">,</span> <span class="ss">:string</span><span class="p">)</span>
    <span class="n">field</span><span class="p">(</span><span class="ss">:discounted</span><span class="p">,</span> <span class="ss">:boolean</span><span class="p">)</span>
    <span class="n">timestamps</span><span class="p">()</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">db_changeset</span><span class="p">(%</span><span class="no">Changeset</span><span class="p">{}</span> <span class="o">=</span> <span class="n">changeset</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">changeset</span>
    <span class="o">|&gt;</span> <span class="n">validate_required</span><span class="p">([</span><span class="ss">:name</span><span class="p">])</span>
    <span class="o">|&gt;</span> <span class="n">unique_constraint</span><span class="p">(</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">name:</span> <span class="ss">:unique_name_index</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="changesetы-для-обработки">Changeset’ы для обработки</h3>
<p>Вот тут всё интереснее.</p>

<p>Эти changeset’ы должны описываться в контестах и использоваться как входные для changeset’ов хранения.</p>

<p>Допустим, в одном месте мы можем редактировать название и описание, а в другом — только описание. В соответствующих контекстах у нас будет следующий (гипотетический) код:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Contexts</span><span class="o">.</span><span class="no">Admin</span><span class="o">.</span><span class="no">Pizzas</span> <span class="k">do</span>
  <span class="n">alias</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Changeset</span>
  <span class="n">alias</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Models</span><span class="o">.</span><span class="no">Pizza</span>
  <span class="n">alias</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Repo</span>

  <span class="k">def</span> <span class="n">update</span><span class="p">(%</span><span class="no">Pizza</span><span class="p">{}</span> <span class="o">=</span> <span class="n">pizza</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">pizza</span>
    <span class="o">|&gt;</span> <span class="n">changeset</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">changeset</span><span class="p">(%</span><span class="no">Pizza</span><span class="p">{}</span> <span class="o">=</span> <span class="n">pizza</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">pizza</span>
    <span class="o">|&gt;</span> <span class="no">Changeset</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="p">[</span><span class="ss">:name</span><span class="p">,</span> <span class="ss">:description</span><span class="p">])</span>
    <span class="o">|&gt;</span> <span class="no">Pizza</span><span class="o">.</span><span class="n">db_changeset</span><span class="p">()</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Contexts</span><span class="o">.</span><span class="no">Manager</span><span class="o">.</span><span class="no">Pizzas</span> <span class="k">do</span>
  <span class="n">alias</span> <span class="no">Ecto</span><span class="o">.</span><span class="no">Changeset</span>
  <span class="n">alias</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Models</span><span class="o">.</span><span class="no">Pizza</span>
  <span class="n">alias</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Repo</span>

  <span class="k">def</span> <span class="n">update</span><span class="p">(%</span><span class="no">Pizza</span><span class="p">{}</span> <span class="o">=</span> <span class="n">pizza</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">pizza</span>
    <span class="o">|&gt;</span> <span class="n">changeset</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="no">Repo</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">changeset</span><span class="p">(%</span><span class="no">Pizza</span><span class="p">{}</span> <span class="o">=</span> <span class="n">pizza</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">pizza</span>
    <span class="o">|&gt;</span> <span class="no">Changeset</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="p">[</span><span class="ss">:description</span><span class="p">])</span>
    <span class="o">|&gt;</span> <span class="no">Changeset</span><span class="o">.</span><span class="n">validate_required</span><span class="p">([</span><span class="ss">:description</span><span class="p">])</span>
    <span class="o">|&gt;</span> <span class="no">Pizza</span><span class="o">.</span><span class="n">db_changeset</span><span class="p">()</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>В результате вместо того, чтобы плодить в области хранения данных их обработку в виде <code class="highlighter-rouge">def admin_changeset(struct, params)</code> и <code class="highlighter-rouge">def manager_changeset(struct, params)</code> мы пишем <strong>специфичные для каждого пользовательского сценария</strong> changeset’ы в том месте, где описываем сам сценарий.</p>

<h3 id="выглядит-это-так-себе">Выглядит это так себе</h3>
<p>Потому что одним и тем же словом “changeset” (да и механизмом, если смотреть под капот) мы описываем два совершенно разных действия: работу с базой данных и работу с пользовательским вводом.</p>

<p>Единственное, что я могу придумать в данной ситуации — делать такие названия changeset’ам, чтобы было понятно, какие относятся к БД, а какие — к обработке пользовательских сценариев.</p>

<h2 id="шлюзы-upd-2021-10-10">Шлюзы (UPD 2021-10-10)</h2>
<p>Ещё немного про структуру проекта.</p>

<p>Многие сервисы взаимодействуют с другими сервисами (HTTP, MQ и т.п.).</p>

<p>Такой слой “взаимодействия” должен быть отделён от всего прочего (по моему мнению). Обычно я использую для этого директорию “lib/my_app/gateways”.</p>

<p>Пример:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/my_app/gateways/some_other_service.ex</span>

<span class="k">defmodule</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Gateways</span><span class="o">.</span><span class="no">SomeOtherService</span> <span class="k">do</span>
  <span class="nv">@items_url</span> <span class="sd">"</span><span class="s2">http://example.com/items"</span>

  <span class="k">def</span> <span class="n">get_items</span> <span class="k">do</span>
    <span class="n">request</span> <span class="o">=</span> <span class="p">{</span><span class="nv">@items_url</span><span class="p">,</span> <span class="p">[]}</span>

    <span class="n">with</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">{</span> <span class="p">{</span><span class="n">_</span><span class="p">,</span> <span class="m">200</span><span class="p">,</span> <span class="n">_</span><span class="p">},</span> <span class="n">_</span><span class="p">,</span> <span class="n">raw_response</span><span class="p">}}</span> <span class="o">&lt;-</span> <span class="ss">:httpc</span><span class="o">.</span><span class="n">request</span><span class="p">(</span><span class="ss">:get</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[]),</span>
         <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">response</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="no">Jason</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">raw_response</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">response</span><span class="p">[</span><span class="sd">"</span><span class="s2">items"</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/my_app/contexts/items.ex</span>

<span class="k">defmodule</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Contexts</span><span class="o">.</span><span class="no">Items</span> <span class="k">do</span>
  <span class="n">alias</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Gateways</span><span class="o">.</span><span class="no">SomeOtherService</span><span class="p">,</span> <span class="ss">as:</span> <span class="no">SomeOtherServiceGateway</span>

  <span class="k">def</span> <span class="n">load_items</span> <span class="k">do</span>
    <span class="k">case</span> <span class="no">SomeOtherServiceGateway</span><span class="o">.</span><span class="n">get_items</span><span class="p">()</span> <span class="k">do</span>
      <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">items</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">save_items</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
      <span class="n">error</span> <span class="o">-&gt;</span> <span class="n">error</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">save_items</span> <span class="k">do</span>
    <span class="c1"># save items to DB</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="инверсия-зависимостей">Инверсия зависимостей</h3>
<p>Ну, почти.</p>

<p>Чаще всего сторонний сервис недоступен с локальной машины, поэтому приходится использовать “подставной” сервис. В таком случае вместо использования модулей шлюзов напрямую могут быть получены модули в зависимости от конфигурации через вызов функции.</p>

<p>Пример:</p>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config/dev.exs</span>
<span class="c1"># ...</span>
<span class="n">config</span> <span class="ss">:my_app</span><span class="p">,</span> <span class="ss">:use_fake_other_service</span><span class="p">,</span> <span class="no">true</span>
<span class="c1"># ...</span>
</code></pre></div></div>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/my_app/gateways.ex</span>

<span class="k">defmodule</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Gateways</span> <span class="k">do</span>
  <span class="n">alias</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Gateways</span><span class="o">.</span><span class="no">OtherService</span>
  <span class="n">alias</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Gateways</span><span class="o">.</span><span class="no">OtherService</span><span class="o">.</span><span class="no">Fake</span><span class="p">,</span> <span class="ss">as:</span> <span class="no">FakeOtherService</span>

  <span class="k">def</span> <span class="n">other_service</span> <span class="k">do</span>
    <span class="k">if</span> <span class="no">Application</span><span class="o">.</span><span class="n">get_env</span><span class="p">(</span><span class="ss">:my_app</span><span class="p">,</span> <span class="ss">:use_fake_other_service</span><span class="p">)</span> <span class="k">do</span>
      <span class="no">FakeOtherService</span>
    <span class="k">else</span>
      <span class="no">OtherService</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/my_app/gateways/other_service/fake.ex</span>

<span class="k">defmodule</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Gateways</span><span class="o">.</span><span class="no">OtherService</span><span class="o">.</span><span class="no">Fake</span> <span class="k">do</span>
  <span class="k">def</span> <span class="n">get_items</span><span class="p">,</span> <span class="k">do</span><span class="p">:</span> <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">]}</span>
<span class="k">end</span>
</code></pre></div></div>
<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># lib/my_app/contexts/items.ex</span>

<span class="k">defmodule</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Contexts</span><span class="o">.</span><span class="no">Items</span> <span class="k">do</span>
  <span class="n">alias</span> <span class="no">MyApp</span><span class="o">.</span><span class="no">Gateways</span>

  <span class="k">def</span> <span class="n">load_items</span> <span class="k">do</span>
    <span class="k">case</span> <span class="no">Gateways</span><span class="o">.</span><span class="n">other_service</span><span class="p">()</span><span class="o">.</span><span class="n">get_items</span><span class="p">()</span> <span class="k">do</span>
      <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">items</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">save_items</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
      <span class="n">error</span> <span class="o">-&gt;</span> <span class="n">error</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">save_items</span> <span class="k">do</span>
    <span class="c1"># save items to DB</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

  </div>

  

  
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">ivalentinee</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">ivalentinee</li><li><a class="u-email" href="mailto:valentine.emperor@gmail.com">valentine.emperor@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ivalentinee"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ivalentinee</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
