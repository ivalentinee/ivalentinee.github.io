<!DOCTYPE html>
<html lang="ru"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Что я ищу, когда провожу code-review | ivalentinee</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Что я ищу, когда провожу code-review" />
<meta property="og:locale" content="ru" />
<meta name="description" content="Предисловие Так случилось, что я работаю в конторе с достаточно высокой культурой разработки. И как раньше (когда я был новичком) старший разработчик проводил код-ревью моего кода, так теперь в нашем отделе мы проводим перекрёстный код-ревью. Я стараюсь никогда не упустить возможность “поревьюить”, потому что это даёт уникальный опыт. Посмотреть на код со стороны, вникнуть в него и подумать “почему я бы сделал по-другому” в конечном итоге улучшает и мой собственный код. Я решил выписать основные пункты, по которым провожу код-ревью. Для себя будущего и для всех остальных настоящих. Особенно если когда-нибудь я буду смотреть в ваш код. Буду очень сильно давить в сторону ruby/rails из-за того, что этими инструментами я пользуюсь постоянно. Заранее должен предупредить, что никаких книг на тему я не читал, так что смело можно это ставить мне в вину. Всё “на живом опыте”. Ну разве что когда-то давно читал “Чистый код” дядюшки Боба. По теме “поддерживаемого кода” рекомендую всем посмотреть доклад “Ментальное программирование”. Очень многие доводы в этом посте взяты из этого доклада (и личного опыта). Цель код-ревью Основной целью код-ревью я считаю поддерживаемость кода. Но не его работоспособность, которую должен обеспечивать сам разработчик и отдел QA/QC (кстати, кто-то понимает разницу?). Задачи код-ревью Соответственно, задачами код-ревью являются: Обеспечение читаемости кода Обеспечение модифицируемости кода Что я ищу во время код-ревью Корректное и полное именование Когда-то фразу “работа программиста — придумывать названия переменным” считал шуткой. Но давно уже перестал. А всякие “как корабль назовёшь — так он и поплывёт”… Не буду продолжать. А суть-то проблемы в следующем: Не надо стесняться длинных названий. Предел длины строки от 80 до 120 символов (в зависимости от соглашений), из которых можно где-то треть (30-40 символов) потратить на название переменной. И это нормально! Надо в названии переменной написать целое предложение — пишите. Лучше написать больше, чем меньше. Прямо сейчас. Не потом. Даже не через пять минут. Не надо бояться тратить время на придумывание названий. Это тоже работа программиста. Я бы даже сказал, что называть вещи своими именами — важнейший навык, который нужно применять везде и всегда. Нет нормальных однобуквенных названий. И не может быть. Даже счётчики i — это отстой. Их надо называть нормально. Приведу два примера. Пример про наименование переменной Вот за такое я не очень люблю императивный подход: @users = User.all @users = @users.map(:name) Я сторонник того, что нужно стараться работать с переменными так, будто они иммутабельны. И придумывать новые названия для новых значений, а не переписывать переменную по 10 раз. Нет, конечно ruby — не clojure. Но никто же не запрещает писать в иммутабельном стиле хоть на каком-то уровне? Например, так: @users = User.all @user_names = @users.map(:name) Почему это проблема именования? Потому что причина переназначения переменной чаще всего — лень и нежелание придумывать новые названия. Пример про наименование теста test &#39;should not allowed&#39; do Все поняли, о чём это? Вот и я не понял. А подразумевали на самом деле вот это: test &#39;should not let User with role &quot;guest&quot; create and update post&#39; do Тесты Несмотря на то, что я писал в посте про TDD, тесты всё-таки должны проверять корректность программы. Однако жизнь показывает, что проверить покрытие сценариев тестами во время ревью сложно. Просто потому, что держать в голове весь код невозможно. Поэтому я предпочитаю проверить наличие тестов (хоть каких-нибудь), и их содержимое. Основных критерия проверки конкретного теста два: хрупкость и осмысленность. Что я считаю хрупкими тестами? Ну, например, проверка вёрстки при рендере. И вообще, всё, что может поменяться не сломав при этом логику приложения. Вроде http-заголовков (кроме некоторых случаев). Осмысленность? Например тестирование стабов или mock-объектов. Ну и, конечно, тестирование библиотечного кода. Регулярно находятся люди (включая меня когда-то), которые любят потестировать работу валидаций в рельсовых моделях. Соблюдение модульности и уровней абстракции Пропустим любителей написания всего кода приложения или всех тестов в одном файле. А лучше напишу вот про это: каждый модуль должен иметь ограниченную но полную ответственность и не лезть в работу нижних уровней. Например, сырые sql-запросы в контроллере — сомнительная практика. Как и http-запросы в рельсовой модели. Многословность Пока лень описывать этот пункт. Хотя он — важнейший из списка (после, конечно, наименований) и при этом самый неочевидный. Потому и объяснять сложно. Отсутствие сомнительных практик Мета-программирование а-ля ruby Есть в ruby такие вещи как method_missing, определение методов на ходу и даже классов на ходу, которые наследуются от классов, созданных на ходу, и инклюдят модули, сгенерированные на ходу. Ну и в ту же степь переопределение классов, методов и прочего. Не считая того, что это всё будет выдавать непонятные ошибки прям как в Rails, так ещё и читается (и модифицируется) это всё тяжело. Так что когда я вижу подобные конструкции, использованные без особой необходимости, я говорю “нинада так”. Макросы Как-то я пробовал ковырять гниющий труп common-lisp’а. И решил я посмотреть содержимое библиотеки одной. Зачем-то мне нужно было понять, как конкретная функция работает. Так вот на разбор макроса в три строки (вместе с названием) у меня ушло полтора часа. Я понимаю, что это можно было сделать быстрее при наличии интеллекта. Но зачем? Гораздо проще было бы отказаться от макросов совсем. А если это невозможно, то делать их максимально топорными. Та же история у меня приключилась, когда я полез смотреть кишки Rails эликсировского Phoenix’а. Я был очень огорчён объёмными макросами, которые ссылались друг на друга. Императивщина some_variable = 1 if some_condition some_variable = 2 else some_variable = 3 end return some_variable Без комментариев. ООП ООП? В 2k17? Серьёзно? Во-первых, ООП сосёт. Во-вторых ООП тоже сосёт. А в третьих… Особенно ООП на классах (инкапсулируй, наследуй, полиморфи). Не зря группировка четырёх особо опасных личностей написала целую книгу по тому, как заставить ООП не сосать. Не то чтобы у них ничего не вышло, но выходом из ситуации я бы это не назвал… Так что обычно я стараюсь остановить любые попытки запиливать лютое ООП в проекте. Конечно, иногда ООП (на классах, чтоб их) — действительно неплохой выход из ситуации. Но чаще всего это только делает вполне понятные и очевидные идеи совершенно нечитаемыми, не говоря уже про модифицируемость. Злоупотребление ФП Ну здравствуйте, дороие мои любители анонимных функций. Как вам такое, а? maybe_iteration(some_variable, anonymous_function1(params1) { something(anonymous_function2(params2) { something_else(anonymous_function3(params3) { get_some_result(params1, params2, params3); }); }); }); Ну и примерный аналог для рубистов: some_variable.something do |param1| param1.something_else {|param2| param2.what_is_this?} end.another_fancy_method {|param3| param3.is_this_a_good_code?} Понравилось? Вот и мне не очень. Неявные code-conventions Не все соглашения можно проверить линтерами, увы. Так что приходится искать самому. Отсутствие дублирования Немного холиварная тема. Но всё же. Есть два уровня дублирования, которые можно опустить: дублирование на уровне кода и дублирование на уровне логики. Дублирование на уровне кода Ну, тут всё просто. Видим два использования одного и того же участка кода, константы, чего-угодно — выселяем в отдельную переменную/функцию. Не буду приводить примеры, ибо всё очевидно. Конечно, некоторые считают погоню за дублированием “предварительной оптимизацией”. Я сторонник “лучше сейчас вынести, чем потом где-то пропустить”. Дублирование на уровне логики Вот тут всё не так очевидно. Хотя проблему видел несколько раз. Простой (утрированный) пример на уровне Rails: # app/models/post.rb class Post &lt; ApplicationRecord validates :title, presence: true end # app/controllers/posts_controller.rb class PostsController &lt; ApplicationController def create @post = Post.new(params) if @post.title.present? &amp;&amp; @post.save redirect_to post_path(@post) else render :new end end Явное дублирование логики. Ведь мы уже поставили валидацию в модели. Зачем ещё и в контроллере проверять? Да, пример высосан из пальца, но аналогии провести не составит труда. Отсутствие ненужных велосипедов Достаточно специфичная для рубей тема, ибо обилие гемов. Но, думаю, в конечном итоге для всех языков применимо. А суть проста: если есть готовое решение (библиотека или даже готовое приложение), которое будет дешевле и быстрее, чем велосипед, то зачем пилить велосипед? Не, ну я понимаю, это весело. Но совершенно бессмысленно. Тем более, что поддерживать это изделие нужно будет своими руками, а не руками бесплатного опенсорца. Нужно ли ревьюить собственный код? Да. Определённо. Конечно, “сам себе ревьюер” — не решение проблемы собственного говнокода. Но это даёт возможность неплохо пошевелить шестерёнками в голове. Ну и всё-таки отсеивает часть говнокода. Методика определения корректности кода Когда я провожу код-ревью, я выполняю одновременно три действия: Проверяю код на соответствие всем пунктам (см. выше) “Компилирую” его в голове. Как бы мне ни хотелось, чтобы код был безошибочным, иногда избавиться от обидных ошибок можно только так. Пытаюсь понять, почему код был написан именно так, если что-то зацепило мой взгляд. Ведь, возможно, для конкретного костыля были причины. Особенно сложно выполнять этот пункт во время ревью своего кода." />
<meta property="og:description" content="Предисловие Так случилось, что я работаю в конторе с достаточно высокой культурой разработки. И как раньше (когда я был новичком) старший разработчик проводил код-ревью моего кода, так теперь в нашем отделе мы проводим перекрёстный код-ревью. Я стараюсь никогда не упустить возможность “поревьюить”, потому что это даёт уникальный опыт. Посмотреть на код со стороны, вникнуть в него и подумать “почему я бы сделал по-другому” в конечном итоге улучшает и мой собственный код. Я решил выписать основные пункты, по которым провожу код-ревью. Для себя будущего и для всех остальных настоящих. Особенно если когда-нибудь я буду смотреть в ваш код. Буду очень сильно давить в сторону ruby/rails из-за того, что этими инструментами я пользуюсь постоянно. Заранее должен предупредить, что никаких книг на тему я не читал, так что смело можно это ставить мне в вину. Всё “на живом опыте”. Ну разве что когда-то давно читал “Чистый код” дядюшки Боба. По теме “поддерживаемого кода” рекомендую всем посмотреть доклад “Ментальное программирование”. Очень многие доводы в этом посте взяты из этого доклада (и личного опыта). Цель код-ревью Основной целью код-ревью я считаю поддерживаемость кода. Но не его работоспособность, которую должен обеспечивать сам разработчик и отдел QA/QC (кстати, кто-то понимает разницу?). Задачи код-ревью Соответственно, задачами код-ревью являются: Обеспечение читаемости кода Обеспечение модифицируемости кода Что я ищу во время код-ревью Корректное и полное именование Когда-то фразу “работа программиста — придумывать названия переменным” считал шуткой. Но давно уже перестал. А всякие “как корабль назовёшь — так он и поплывёт”… Не буду продолжать. А суть-то проблемы в следующем: Не надо стесняться длинных названий. Предел длины строки от 80 до 120 символов (в зависимости от соглашений), из которых можно где-то треть (30-40 символов) потратить на название переменной. И это нормально! Надо в названии переменной написать целое предложение — пишите. Лучше написать больше, чем меньше. Прямо сейчас. Не потом. Даже не через пять минут. Не надо бояться тратить время на придумывание названий. Это тоже работа программиста. Я бы даже сказал, что называть вещи своими именами — важнейший навык, который нужно применять везде и всегда. Нет нормальных однобуквенных названий. И не может быть. Даже счётчики i — это отстой. Их надо называть нормально. Приведу два примера. Пример про наименование переменной Вот за такое я не очень люблю императивный подход: @users = User.all @users = @users.map(:name) Я сторонник того, что нужно стараться работать с переменными так, будто они иммутабельны. И придумывать новые названия для новых значений, а не переписывать переменную по 10 раз. Нет, конечно ruby — не clojure. Но никто же не запрещает писать в иммутабельном стиле хоть на каком-то уровне? Например, так: @users = User.all @user_names = @users.map(:name) Почему это проблема именования? Потому что причина переназначения переменной чаще всего — лень и нежелание придумывать новые названия. Пример про наименование теста test &#39;should not allowed&#39; do Все поняли, о чём это? Вот и я не понял. А подразумевали на самом деле вот это: test &#39;should not let User with role &quot;guest&quot; create and update post&#39; do Тесты Несмотря на то, что я писал в посте про TDD, тесты всё-таки должны проверять корректность программы. Однако жизнь показывает, что проверить покрытие сценариев тестами во время ревью сложно. Просто потому, что держать в голове весь код невозможно. Поэтому я предпочитаю проверить наличие тестов (хоть каких-нибудь), и их содержимое. Основных критерия проверки конкретного теста два: хрупкость и осмысленность. Что я считаю хрупкими тестами? Ну, например, проверка вёрстки при рендере. И вообще, всё, что может поменяться не сломав при этом логику приложения. Вроде http-заголовков (кроме некоторых случаев). Осмысленность? Например тестирование стабов или mock-объектов. Ну и, конечно, тестирование библиотечного кода. Регулярно находятся люди (включая меня когда-то), которые любят потестировать работу валидаций в рельсовых моделях. Соблюдение модульности и уровней абстракции Пропустим любителей написания всего кода приложения или всех тестов в одном файле. А лучше напишу вот про это: каждый модуль должен иметь ограниченную но полную ответственность и не лезть в работу нижних уровней. Например, сырые sql-запросы в контроллере — сомнительная практика. Как и http-запросы в рельсовой модели. Многословность Пока лень описывать этот пункт. Хотя он — важнейший из списка (после, конечно, наименований) и при этом самый неочевидный. Потому и объяснять сложно. Отсутствие сомнительных практик Мета-программирование а-ля ruby Есть в ruby такие вещи как method_missing, определение методов на ходу и даже классов на ходу, которые наследуются от классов, созданных на ходу, и инклюдят модули, сгенерированные на ходу. Ну и в ту же степь переопределение классов, методов и прочего. Не считая того, что это всё будет выдавать непонятные ошибки прям как в Rails, так ещё и читается (и модифицируется) это всё тяжело. Так что когда я вижу подобные конструкции, использованные без особой необходимости, я говорю “нинада так”. Макросы Как-то я пробовал ковырять гниющий труп common-lisp’а. И решил я посмотреть содержимое библиотеки одной. Зачем-то мне нужно было понять, как конкретная функция работает. Так вот на разбор макроса в три строки (вместе с названием) у меня ушло полтора часа. Я понимаю, что это можно было сделать быстрее при наличии интеллекта. Но зачем? Гораздо проще было бы отказаться от макросов совсем. А если это невозможно, то делать их максимально топорными. Та же история у меня приключилась, когда я полез смотреть кишки Rails эликсировского Phoenix’а. Я был очень огорчён объёмными макросами, которые ссылались друг на друга. Императивщина some_variable = 1 if some_condition some_variable = 2 else some_variable = 3 end return some_variable Без комментариев. ООП ООП? В 2k17? Серьёзно? Во-первых, ООП сосёт. Во-вторых ООП тоже сосёт. А в третьих… Особенно ООП на классах (инкапсулируй, наследуй, полиморфи). Не зря группировка четырёх особо опасных личностей написала целую книгу по тому, как заставить ООП не сосать. Не то чтобы у них ничего не вышло, но выходом из ситуации я бы это не назвал… Так что обычно я стараюсь остановить любые попытки запиливать лютое ООП в проекте. Конечно, иногда ООП (на классах, чтоб их) — действительно неплохой выход из ситуации. Но чаще всего это только делает вполне понятные и очевидные идеи совершенно нечитаемыми, не говоря уже про модифицируемость. Злоупотребление ФП Ну здравствуйте, дороие мои любители анонимных функций. Как вам такое, а? maybe_iteration(some_variable, anonymous_function1(params1) { something(anonymous_function2(params2) { something_else(anonymous_function3(params3) { get_some_result(params1, params2, params3); }); }); }); Ну и примерный аналог для рубистов: some_variable.something do |param1| param1.something_else {|param2| param2.what_is_this?} end.another_fancy_method {|param3| param3.is_this_a_good_code?} Понравилось? Вот и мне не очень. Неявные code-conventions Не все соглашения можно проверить линтерами, увы. Так что приходится искать самому. Отсутствие дублирования Немного холиварная тема. Но всё же. Есть два уровня дублирования, которые можно опустить: дублирование на уровне кода и дублирование на уровне логики. Дублирование на уровне кода Ну, тут всё просто. Видим два использования одного и того же участка кода, константы, чего-угодно — выселяем в отдельную переменную/функцию. Не буду приводить примеры, ибо всё очевидно. Конечно, некоторые считают погоню за дублированием “предварительной оптимизацией”. Я сторонник “лучше сейчас вынести, чем потом где-то пропустить”. Дублирование на уровне логики Вот тут всё не так очевидно. Хотя проблему видел несколько раз. Простой (утрированный) пример на уровне Rails: # app/models/post.rb class Post &lt; ApplicationRecord validates :title, presence: true end # app/controllers/posts_controller.rb class PostsController &lt; ApplicationController def create @post = Post.new(params) if @post.title.present? &amp;&amp; @post.save redirect_to post_path(@post) else render :new end end Явное дублирование логики. Ведь мы уже поставили валидацию в модели. Зачем ещё и в контроллере проверять? Да, пример высосан из пальца, но аналогии провести не составит труда. Отсутствие ненужных велосипедов Достаточно специфичная для рубей тема, ибо обилие гемов. Но, думаю, в конечном итоге для всех языков применимо. А суть проста: если есть готовое решение (библиотека или даже готовое приложение), которое будет дешевле и быстрее, чем велосипед, то зачем пилить велосипед? Не, ну я понимаю, это весело. Но совершенно бессмысленно. Тем более, что поддерживать это изделие нужно будет своими руками, а не руками бесплатного опенсорца. Нужно ли ревьюить собственный код? Да. Определённо. Конечно, “сам себе ревьюер” — не решение проблемы собственного говнокода. Но это даёт возможность неплохо пошевелить шестерёнками в голове. Ну и всё-таки отсеивает часть говнокода. Методика определения корректности кода Когда я провожу код-ревью, я выполняю одновременно три действия: Проверяю код на соответствие всем пунктам (см. выше) “Компилирую” его в голове. Как бы мне ни хотелось, чтобы код был безошибочным, иногда избавиться от обидных ошибок можно только так. Пытаюсь понять, почему код был написан именно так, если что-то зацепило мой взгляд. Ведь, возможно, для конкретного костыля были причины. Особенно сложно выполнять этот пункт во время ревью своего кода." />
<link rel="canonical" href="https://ivalentinee.github.io/ru/coding/2017/06/27/what-i-look-for-reviewing-code.html" />
<meta property="og:url" content="https://ivalentinee.github.io/ru/coding/2017/06/27/what-i-look-for-reviewing-code.html" />
<meta property="og:site_name" content="ivalentinee" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-06-27T00:00:00+00:00" />
<script type="application/ld+json">
{"description":"Предисловие Так случилось, что я работаю в конторе с достаточно высокой культурой разработки. И как раньше (когда я был новичком) старший разработчик проводил код-ревью моего кода, так теперь в нашем отделе мы проводим перекрёстный код-ревью. Я стараюсь никогда не упустить возможность “поревьюить”, потому что это даёт уникальный опыт. Посмотреть на код со стороны, вникнуть в него и подумать “почему я бы сделал по-другому” в конечном итоге улучшает и мой собственный код. Я решил выписать основные пункты, по которым провожу код-ревью. Для себя будущего и для всех остальных настоящих. Особенно если когда-нибудь я буду смотреть в ваш код. Буду очень сильно давить в сторону ruby/rails из-за того, что этими инструментами я пользуюсь постоянно. Заранее должен предупредить, что никаких книг на тему я не читал, так что смело можно это ставить мне в вину. Всё “на живом опыте”. Ну разве что когда-то давно читал “Чистый код” дядюшки Боба. По теме “поддерживаемого кода” рекомендую всем посмотреть доклад “Ментальное программирование”. Очень многие доводы в этом посте взяты из этого доклада (и личного опыта). Цель код-ревью Основной целью код-ревью я считаю поддерживаемость кода. Но не его работоспособность, которую должен обеспечивать сам разработчик и отдел QA/QC (кстати, кто-то понимает разницу?). Задачи код-ревью Соответственно, задачами код-ревью являются: Обеспечение читаемости кода Обеспечение модифицируемости кода Что я ищу во время код-ревью Корректное и полное именование Когда-то фразу “работа программиста — придумывать названия переменным” считал шуткой. Но давно уже перестал. А всякие “как корабль назовёшь — так он и поплывёт”… Не буду продолжать. А суть-то проблемы в следующем: Не надо стесняться длинных названий. Предел длины строки от 80 до 120 символов (в зависимости от соглашений), из которых можно где-то треть (30-40 символов) потратить на название переменной. И это нормально! Надо в названии переменной написать целое предложение — пишите. Лучше написать больше, чем меньше. Прямо сейчас. Не потом. Даже не через пять минут. Не надо бояться тратить время на придумывание названий. Это тоже работа программиста. Я бы даже сказал, что называть вещи своими именами — важнейший навык, который нужно применять везде и всегда. Нет нормальных однобуквенных названий. И не может быть. Даже счётчики i — это отстой. Их надо называть нормально. Приведу два примера. Пример про наименование переменной Вот за такое я не очень люблю императивный подход: @users = User.all @users = @users.map(:name) Я сторонник того, что нужно стараться работать с переменными так, будто они иммутабельны. И придумывать новые названия для новых значений, а не переписывать переменную по 10 раз. Нет, конечно ruby — не clojure. Но никто же не запрещает писать в иммутабельном стиле хоть на каком-то уровне? Например, так: @users = User.all @user_names = @users.map(:name) Почему это проблема именования? Потому что причина переназначения переменной чаще всего — лень и нежелание придумывать новые названия. Пример про наименование теста test &#39;should not allowed&#39; do Все поняли, о чём это? Вот и я не понял. А подразумевали на самом деле вот это: test &#39;should not let User with role &quot;guest&quot; create and update post&#39; do Тесты Несмотря на то, что я писал в посте про TDD, тесты всё-таки должны проверять корректность программы. Однако жизнь показывает, что проверить покрытие сценариев тестами во время ревью сложно. Просто потому, что держать в голове весь код невозможно. Поэтому я предпочитаю проверить наличие тестов (хоть каких-нибудь), и их содержимое. Основных критерия проверки конкретного теста два: хрупкость и осмысленность. Что я считаю хрупкими тестами? Ну, например, проверка вёрстки при рендере. И вообще, всё, что может поменяться не сломав при этом логику приложения. Вроде http-заголовков (кроме некоторых случаев). Осмысленность? Например тестирование стабов или mock-объектов. Ну и, конечно, тестирование библиотечного кода. Регулярно находятся люди (включая меня когда-то), которые любят потестировать работу валидаций в рельсовых моделях. Соблюдение модульности и уровней абстракции Пропустим любителей написания всего кода приложения или всех тестов в одном файле. А лучше напишу вот про это: каждый модуль должен иметь ограниченную но полную ответственность и не лезть в работу нижних уровней. Например, сырые sql-запросы в контроллере — сомнительная практика. Как и http-запросы в рельсовой модели. Многословность Пока лень описывать этот пункт. Хотя он — важнейший из списка (после, конечно, наименований) и при этом самый неочевидный. Потому и объяснять сложно. Отсутствие сомнительных практик Мета-программирование а-ля ruby Есть в ruby такие вещи как method_missing, определение методов на ходу и даже классов на ходу, которые наследуются от классов, созданных на ходу, и инклюдят модули, сгенерированные на ходу. Ну и в ту же степь переопределение классов, методов и прочего. Не считая того, что это всё будет выдавать непонятные ошибки прям как в Rails, так ещё и читается (и модифицируется) это всё тяжело. Так что когда я вижу подобные конструкции, использованные без особой необходимости, я говорю “нинада так”. Макросы Как-то я пробовал ковырять гниющий труп common-lisp’а. И решил я посмотреть содержимое библиотеки одной. Зачем-то мне нужно было понять, как конкретная функция работает. Так вот на разбор макроса в три строки (вместе с названием) у меня ушло полтора часа. Я понимаю, что это можно было сделать быстрее при наличии интеллекта. Но зачем? Гораздо проще было бы отказаться от макросов совсем. А если это невозможно, то делать их максимально топорными. Та же история у меня приключилась, когда я полез смотреть кишки Rails эликсировского Phoenix’а. Я был очень огорчён объёмными макросами, которые ссылались друг на друга. Императивщина some_variable = 1 if some_condition some_variable = 2 else some_variable = 3 end return some_variable Без комментариев. ООП ООП? В 2k17? Серьёзно? Во-первых, ООП сосёт. Во-вторых ООП тоже сосёт. А в третьих… Особенно ООП на классах (инкапсулируй, наследуй, полиморфи). Не зря группировка четырёх особо опасных личностей написала целую книгу по тому, как заставить ООП не сосать. Не то чтобы у них ничего не вышло, но выходом из ситуации я бы это не назвал… Так что обычно я стараюсь остановить любые попытки запиливать лютое ООП в проекте. Конечно, иногда ООП (на классах, чтоб их) — действительно неплохой выход из ситуации. Но чаще всего это только делает вполне понятные и очевидные идеи совершенно нечитаемыми, не говоря уже про модифицируемость. Злоупотребление ФП Ну здравствуйте, дороие мои любители анонимных функций. Как вам такое, а? maybe_iteration(some_variable, anonymous_function1(params1) { something(anonymous_function2(params2) { something_else(anonymous_function3(params3) { get_some_result(params1, params2, params3); }); }); }); Ну и примерный аналог для рубистов: some_variable.something do |param1| param1.something_else {|param2| param2.what_is_this?} end.another_fancy_method {|param3| param3.is_this_a_good_code?} Понравилось? Вот и мне не очень. Неявные code-conventions Не все соглашения можно проверить линтерами, увы. Так что приходится искать самому. Отсутствие дублирования Немного холиварная тема. Но всё же. Есть два уровня дублирования, которые можно опустить: дублирование на уровне кода и дублирование на уровне логики. Дублирование на уровне кода Ну, тут всё просто. Видим два использования одного и того же участка кода, константы, чего-угодно — выселяем в отдельную переменную/функцию. Не буду приводить примеры, ибо всё очевидно. Конечно, некоторые считают погоню за дублированием “предварительной оптимизацией”. Я сторонник “лучше сейчас вынести, чем потом где-то пропустить”. Дублирование на уровне логики Вот тут всё не так очевидно. Хотя проблему видел несколько раз. Простой (утрированный) пример на уровне Rails: # app/models/post.rb class Post &lt; ApplicationRecord validates :title, presence: true end # app/controllers/posts_controller.rb class PostsController &lt; ApplicationController def create @post = Post.new(params) if @post.title.present? &amp;&amp; @post.save redirect_to post_path(@post) else render :new end end Явное дублирование логики. Ведь мы уже поставили валидацию в модели. Зачем ещё и в контроллере проверять? Да, пример высосан из пальца, но аналогии провести не составит труда. Отсутствие ненужных велосипедов Достаточно специфичная для рубей тема, ибо обилие гемов. Но, думаю, в конечном итоге для всех языков применимо. А суть проста: если есть готовое решение (библиотека или даже готовое приложение), которое будет дешевле и быстрее, чем велосипед, то зачем пилить велосипед? Не, ну я понимаю, это весело. Но совершенно бессмысленно. Тем более, что поддерживать это изделие нужно будет своими руками, а не руками бесплатного опенсорца. Нужно ли ревьюить собственный код? Да. Определённо. Конечно, “сам себе ревьюер” — не решение проблемы собственного говнокода. Но это даёт возможность неплохо пошевелить шестерёнками в голове. Ну и всё-таки отсеивает часть говнокода. Методика определения корректности кода Когда я провожу код-ревью, я выполняю одновременно три действия: Проверяю код на соответствие всем пунктам (см. выше) “Компилирую” его в голове. Как бы мне ни хотелось, чтобы код был безошибочным, иногда избавиться от обидных ошибок можно только так. Пытаюсь понять, почему код был написан именно так, если что-то зацепило мой взгляд. Ведь, возможно, для конкретного костыля были причины. Особенно сложно выполнять этот пункт во время ревью своего кода.","mainEntityOfPage":{"@type":"WebPage","@id":"https://ivalentinee.github.io/ru/coding/2017/06/27/what-i-look-for-reviewing-code.html"},"@type":"BlogPosting","url":"https://ivalentinee.github.io/ru/coding/2017/06/27/what-i-look-for-reviewing-code.html","headline":"Что я ищу, когда провожу code-review","dateModified":"2017-06-27T00:00:00+00:00","datePublished":"2017-06-27T00:00:00+00:00","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://ivalentinee.github.io/feed.xml" title="ivalentinee" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/ru/">ivalentinee</a>

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
                <a class="page-link" href="/ru/about/">Обо мне</a>
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
          
            
            
          
            
            
          
            
            
              
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Что я ищу, когда провожу code-review</h1>
    <p class="post-meta">
      <time datetime="2017-06-27T00:00:00+00:00" itemprop="datePublished">
        
        Jun 27, 2017
      </time>
      </p>
  </header>

  

  <div class="post-content" itemprop="articleBody">
    <h2 id="предисловие">Предисловие</h2>
<p>Так случилось, что я работаю в конторе с достаточно высокой культурой разработки. И как раньше (когда я был новичком) старший разработчик проводил код-ревью моего кода, так теперь в нашем отделе мы проводим перекрёстный код-ревью.</p>

<p>Я стараюсь никогда не упустить возможность “поревьюить”, потому что это даёт уникальный опыт. Посмотреть на код со стороны, вникнуть в него и подумать “почему я бы сделал по-другому” в конечном итоге улучшает и мой собственный код.</p>

<p>Я решил выписать основные пункты, по которым провожу код-ревью. Для себя будущего и для всех остальных настоящих. Особенно если когда-нибудь я буду смотреть в ваш код.</p>

<p>Буду очень сильно давить в сторону ruby/rails из-за того, что этими инструментами я пользуюсь постоянно.</p>

<p>Заранее должен предупредить, что никаких книг на тему я не читал, так что смело можно это ставить мне в вину. Всё “на живом опыте”. Ну разве что когда-то давно читал <a href="https://www.ozon.ru/context/detail/id/5011068/">“Чистый код” дядюшки Боба</a>.</p>

<p>По теме “поддерживаемого кода” рекомендую всем посмотреть доклад <a href="https://youtu.be/eEEHWQNuCLQ">“Ментальное программирование”</a>. Очень многие доводы в этом посте взяты из этого доклада (и личного опыта).</p>

<h2 id="цель-код-ревью">Цель код-ревью</h2>
<p>Основной целью код-ревью я считаю <strong>поддерживаемость</strong> кода. Но не его <strong>работоспособность</strong>, которую должен обеспечивать сам разработчик и отдел QA/QC (кстати, кто-то понимает разницу?).</p>

<h2 id="задачи-код-ревью">Задачи код-ревью</h2>
<p>Соответственно, задачами код-ревью являются:</p>
<ol>
  <li>Обеспечение читаемости кода</li>
  <li>Обеспечение модифицируемости кода</li>
</ol>

<h2 id="что-я-ищу-во-время-код-ревью">Что я ищу во время код-ревью</h2>

<h3 id="корректное-и-полное-именование">Корректное и полное именование</h3>
<p>Когда-то фразу “работа программиста — придумывать названия переменным” считал шуткой. Но давно уже перестал. А всякие “как корабль назовёшь — так он и поплывёт”… Не буду продолжать.</p>

<p>А суть-то проблемы в следующем:</p>
<ol>
  <li>Не надо стесняться длинных названий. Предел длины строки от 80 до 120 символов (в зависимости от соглашений), из которых можно где-то треть (30-40 символов) потратить на название переменной. И это нормально! Надо в названии переменной написать целое предложение — пишите. Лучше написать больше, чем меньше. Прямо сейчас. Не потом. Даже не через пять минут.</li>
  <li>Не надо бояться тратить время на придумывание названий. Это тоже работа программиста. Я бы даже сказал, что называть вещи своими именами — важнейший навык, который нужно применять везде и всегда.</li>
  <li>Нет нормальных однобуквенных названий. И не может быть. Даже счётчики <code class="highlighter-rouge">i</code> — это отстой. Их надо называть нормально.</li>
</ol>

<p>Приведу два примера.</p>

<h4 id="пример-про-наименование-переменной">Пример про наименование переменной</h4>
<p>Вот за такое я не очень люблю императивный подход:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@users</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span>
<span class="vi">@users</span> <span class="o">=</span> <span class="vi">@users</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>
</code></pre></div></div>
<p>Я сторонник того, что нужно стараться работать с переменными так, будто они иммутабельны. И придумывать новые названия для новых значений, а не переписывать переменную по 10 раз. Нет, конечно ruby — не clojure. Но никто же не запрещает писать в иммутабельном стиле хоть на каком-то уровне?</p>

<p>Например, так:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@users</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span>
<span class="vi">@user_names</span> <span class="o">=</span> <span class="vi">@users</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>
</code></pre></div></div>

<p>Почему это проблема именования? Потому что причина переназначения переменной чаще всего — лень и нежелание придумывать новые названия.</p>

<h4 id="пример-про-наименование-теста">Пример про наименование теста</h4>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">test</span> <span class="s1">'should not allowed'</span> <span class="k">do</span>
</code></pre></div></div>
<p>Все поняли, о чём это? Вот и я не понял. А подразумевали на самом деле вот это:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">test</span> <span class="s1">'should not let User with role "guest" create and update post'</span> <span class="k">do</span>
</code></pre></div></div>

<h3 id="тесты">Тесты</h3>
<p>Несмотря на то, что я писал в <a href="/ru/programming/2017/06/05/TDD.html">посте про TDD</a>, тесты всё-таки должны проверять корректность программы.</p>

<p>Однако жизнь показывает, что проверить покрытие сценариев тестами во время ревью сложно. Просто потому, что держать в голове весь код невозможно.</p>

<p>Поэтому я предпочитаю проверить наличие тестов (хоть каких-нибудь), и их содержимое.</p>

<p>Основных критерия проверки конкретного теста два: хрупкость и осмысленность.</p>

<p>Что я считаю хрупкими тестами? Ну, например, проверка вёрстки при рендере. И вообще, всё, что может поменяться не сломав при этом логику приложения. Вроде http-заголовков (кроме некоторых случаев).</p>

<p>Осмысленность? Например тестирование стабов или mock-объектов. Ну и, конечно, тестирование библиотечного кода. Регулярно находятся люди (включая меня когда-то), которые любят потестировать работу валидаций в рельсовых моделях.</p>

<h3 id="соблюдение-модульности-и-уровней-абстракции">Соблюдение модульности и уровней абстракции</h3>
<p>Пропустим любителей написания всего кода приложения или всех тестов в одном файле.</p>

<p>А лучше напишу вот про это: каждый модуль должен иметь ограниченную но полную ответственность и не лезть в работу нижних уровней.</p>

<p>Например, сырые sql-запросы в контроллере — сомнительная практика. Как и http-запросы в рельсовой модели.</p>

<h3 id="многословность">Многословность</h3>
<p>Пока лень описывать этот пункт. Хотя он — важнейший из списка (после, конечно, наименований) и при этом самый неочевидный. Потому и объяснять сложно.</p>

<h3 id="отсутствие-сомнительных-практик">Отсутствие сомнительных практик</h3>

<h4 id="мета-программирование-а-ля-ruby">Мета-программирование а-ля ruby</h4>
<p>Есть в ruby такие вещи как <code class="highlighter-rouge">method_missing</code>, определение методов на ходу и даже классов на ходу, которые наследуются от классов, созданных на ходу, и инклюдят модули, сгенерированные на ходу. Ну и в ту же степь переопределение классов, методов и прочего.</p>

<p>Не считая того, что это всё будет выдавать непонятные ошибки <del>прям как в Rails</del>, так ещё и читается (и модифицируется) это всё тяжело. Так что когда я вижу подобные конструкции, использованные без особой необходимости, я говорю “нинада так”.</p>

<h4 id="макросы">Макросы</h4>
<p>Как-то я пробовал ковырять гниющий труп common-lisp’а. И решил я посмотреть содержимое библиотеки одной.<br />
Зачем-то мне нужно было понять, как конкретная функция работает. Так вот на разбор макроса в три строки (вместе с названием) у меня ушло полтора часа. Я понимаю, что это можно было сделать быстрее при наличии интеллекта. Но зачем? Гораздо проще было бы отказаться от макросов совсем. А если это невозможно, то делать их максимально топорными.</p>

<p>Та же история у меня приключилась, когда я полез смотреть кишки <del>Rails</del> <a href="http://www.phoenixframework.org/">эликсировского Phoenix’а</a>. Я был очень огорчён объёмными макросами, которые ссылались друг на друга.</p>

<h4 id="императивщина">Императивщина</h4>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">some_variable</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">if</span> <span class="n">some_condition</span>
  <span class="n">some_variable</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">else</span>
  <span class="n">some_variable</span> <span class="o">=</span> <span class="mi">3</span>
<span class="k">end</span>

<span class="k">return</span> <span class="n">some_variable</span>
</code></pre></div></div>

<p>Без комментариев.</p>

<h4 id="ооп">ООП</h4>
<p>ООП? В 2k17? Серьёзно?</p>

<p>Во-первых, ООП сосёт. Во-вторых ООП тоже сосёт. А в третьих…</p>

<p>Особенно ООП на классах (инкапсулируй, наследуй, полиморфи). Не зря группировка четырёх особо опасных личностей <a href="https://ru.wikipedia.org/wiki/Design_Patterns">написала целую книгу</a> по тому, как заставить ООП не сосать. Не то чтобы у них ничего не вышло, но выходом из ситуации я бы это не назвал…</p>

<p>Так что обычно я стараюсь остановить любые попытки запиливать лютое ООП в проекте.</p>

<p>Конечно, иногда ООП (на классах, чтоб их) — действительно неплохой выход из ситуации. Но чаще всего это только делает вполне понятные и очевидные идеи совершенно нечитаемыми, не говоря уже про модифицируемость.</p>

<h4 id="злоупотребление-фп">Злоупотребление ФП</h4>
<p>Ну здравствуйте, дороие мои любители анонимных функций. Как вам такое, а?</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">maybe_iteration</span><span class="p">(</span><span class="nx">some_variable</span><span class="p">,</span> <span class="nx">anonymous_function1</span><span class="p">(</span><span class="nx">params1</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">something</span><span class="p">(</span><span class="nx">anonymous_function2</span><span class="p">(</span><span class="nx">params2</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">something_else</span><span class="p">(</span><span class="nx">anonymous_function3</span><span class="p">(</span><span class="nx">params3</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">get_some_result</span><span class="p">(</span><span class="nx">params1</span><span class="p">,</span> <span class="nx">params2</span><span class="p">,</span> <span class="nx">params3</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div>
<p>Ну и примерный аналог для рубистов:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">some_variable</span><span class="p">.</span><span class="nf">something</span> <span class="k">do</span> <span class="o">|</span><span class="n">param1</span><span class="o">|</span>
  <span class="n">param1</span><span class="p">.</span><span class="nf">something_else</span> <span class="p">{</span><span class="o">|</span><span class="n">param2</span><span class="o">|</span> <span class="n">param2</span><span class="p">.</span><span class="nf">what_is_this?</span><span class="p">}</span>
<span class="k">end</span><span class="p">.</span><span class="nf">another_fancy_method</span> <span class="p">{</span><span class="o">|</span><span class="n">param3</span><span class="o">|</span> <span class="n">param3</span><span class="p">.</span><span class="nf">is_this_a_good_code?</span><span class="p">}</span>
</code></pre></div></div>
<p>Понравилось? Вот и мне не очень.</p>

<h3 id="неявные-code-conventions">Неявные code-conventions</h3>
<p>Не все соглашения можно проверить линтерами, увы. Так что приходится искать самому.</p>

<h3 id="отсутствие-дублирования">Отсутствие дублирования</h3>
<p>Немного холиварная тема. Но всё же.</p>

<p>Есть два уровня дублирования, которые можно опустить: дублирование на уровне кода и дублирование на уровне логики.</p>

<h4 id="дублирование-на-уровне-кода">Дублирование на уровне кода</h4>
<p>Ну, тут всё просто. Видим два использования одного и того же участка кода, константы, чего-угодно — выселяем в отдельную переменную/функцию. Не буду приводить примеры, ибо всё очевидно.</p>

<p>Конечно, некоторые считают погоню за дублированием “предварительной оптимизацией”. Я сторонник “лучше сейчас вынести, чем потом где-то пропустить”.</p>

<h4 id="дублирование-на-уровне-логики">Дублирование на уровне логики</h4>
<p>Вот тут всё не так очевидно. Хотя проблему видел несколько раз.</p>

<p>Простой (утрированный) пример на уровне Rails:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/models/post.rb</span>

<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>

  <span class="n">validates</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">presence: </span><span class="kp">true</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/controllers/posts_controller.rb</span>

<span class="k">class</span> <span class="nc">PostsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">create</span>
    <span class="vi">@post</span> <span class="o">=</span> <span class="no">Post</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">if</span> <span class="vi">@post</span><span class="p">.</span><span class="nf">title</span><span class="p">.</span><span class="nf">present?</span> <span class="o">&amp;&amp;</span> <span class="vi">@post</span><span class="p">.</span><span class="nf">save</span>
      <span class="n">redirect_to</span> <span class="n">post_path</span><span class="p">(</span><span class="vi">@post</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="n">render</span> <span class="ss">:new</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>Явное дублирование логики. Ведь мы уже поставили валидацию в модели. Зачем ещё и в контроллере проверять?</p>

<p>Да, пример высосан из пальца, но аналогии провести не составит труда.</p>

<h3 id="отсутствие-ненужных-велосипедов">Отсутствие ненужных велосипедов</h3>
<p>Достаточно специфичная для рубей тема, ибо обилие гемов. Но, думаю, в конечном итоге для всех языков применимо.</p>

<p>А суть проста: если есть готовое решение (библиотека или даже готовое приложение), которое будет дешевле и быстрее, чем велосипед, то зачем пилить велосипед?</p>

<p>Не, ну я понимаю, это весело. Но совершенно бессмысленно. Тем более, что поддерживать это изделие нужно будет своими руками, а не руками бесплатного опенсорца.</p>

<h2 id="нужно-ли-ревьюить-собственный-код">Нужно ли ревьюить собственный код?</h2>
<p>Да. Определённо.</p>

<p>Конечно, “сам себе ревьюер” — не решение проблемы собственного говнокода. Но это даёт возможность неплохо пошевелить шестерёнками в голове. Ну и всё-таки  отсеивает часть говнокода.</p>

<h2 id="методика-определения-корректности-кода">Методика определения корректности кода</h2>
<p>Когда я провожу код-ревью, я выполняю одновременно три действия:</p>
<ol>
  <li>Проверяю код на соответствие всем пунктам (см. выше)</li>
  <li>“Компилирую” его в голове. Как бы мне ни хотелось, чтобы код был безошибочным, иногда избавиться от обидных ошибок можно только так.</li>
  <li>Пытаюсь понять, почему код был написан именно так, если что-то зацепило мой взгляд. Ведь, возможно, для конкретного костыля были причины. Особенно сложно выполнять этот пункт во время ревью своего кода.</li>
</ol>

  </div>

  
  <div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://ivalentinee.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">ivalentinee</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">ivalentinee</li><li><a class="u-email" href="mailto:valentine.emperor@gmail.com">valentine.emperor@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ivalentinee"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ivalentinee</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
