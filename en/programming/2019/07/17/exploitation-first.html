<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Exploitation first! | ivalentinee</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Exploitation first!" />
<meta property="og:locale" content="en" />
<meta name="description" content="Introduction This post is mostly for those careless whisperers programmers who write code with no care for exploitation. What is exploitation? Wiktionary defines exploitation as “The act of utilizing something”. So how does one utilize programs? Sets it up, configures it and ensures that it runs as instruction specifies. In order to make your program exploitatable you need to provide documentation for every of these three steps. Truth is, it’s rare to see any documentation at all, so exploitation is done poorly. “It works somehow” approach. “Just reboot it” approach. All that stuff. He’re some tips on how to make web-services easy to exploitate. Here’s some well known paper on that matter, which is more declarative, formal and extensive. I do not discuss end-user installed programs, ‘cause it also requires a ton of information on distribution, which I’m not familiar with. Standardize it! By that I mean two things. Make exploitation documentation standard First, ask your exploitation department colleagues (DevOpses?). Especially if you already have some systems in exploitation (i.e. in production). What they use? What information they lack? Second, inspect your projects (both in exploitation and in early develoment). Think of all common bells and whistles to be configured, some situations that may occur. You may think your system is easy to understand for everybody. Truth is, it’s not. After all common information gathered write a template of exploitation docs and show it to everybody. Discuss it, improve it. But do not “carve this template in stone”. After every incident (especially post mortems) think of adding some things that could help exploitation team make it through harsh times without your help. Amend (but wisely!) it. Remove unused things. Make it mandatory for every developer This is a bit more difficult. If you’re on team lead/manager/big boss position, use your power to make documenting exploitation mandatory. If not, use social engineering, meritocracy, your boss, your reputation. Become an asshole. But force everybody to write that. Trust me, it will save your sleep at night (especially if you’re team lead/manager). Make your system exploitatable That’s complicated too. All that 12-factor apps stuff (and beyond) goes here. Environment configuration files First thing I encountered countless times is “environment configuration file”. God, please, get rid of it! If your config folder contains more than production and derived from it development and test configs, you’ve done bad. Just imagine, what could happen if at 1:00 am your DB server crashes without any chance to restore, but exploitation guys can quickly (within SLA time!) restore it with different IP address/domain name. How could you change your DB hostname on the go without redeploying your app if you have it (DB hostname) in git-controlled folder with no chance to change it “on the go”? Sleepless night will suddenly get into your life =) So, to make your system configurable “on the go” either use some sort of config provider, or simply put everything into ENV-variables with default values. And voila, more sleep for your really tired brain that night! Oh, and of course it (ENV-variables, config providers, etc.) well worth documenting. Trust me. Add readiness and liveness checks Or, as some call them, health checks. Why? Your server needs to know how when your app has loaded (readiness check) and when it crashed (liveness check). For web apps just / with 200 OK usually is enough for both. Then describe it in your exploitation documentation. Add custom monitoring endpoint Thing is, your exploitation team already has some tool to monitor your app. Help them! You’re unsure of some really weird errors? Push those events to monitoring system! Has external systems? Check them! We (on projects I developed) used /healthcheck with this content: db ok smtp ok rabbitmq ok Again, put that into exploitation documentation. Describe every service Use DBMS? Has web server? Send emails? Describe it! For every service you should describe: Where to get. Code? Docker/rkt images? RPM-packages? How to start: commands and arguments, flags, etc. What to do at first start. Like putting in some seed data with specific command. Dependencies. I bet you don’t want to start your app-server before DB. Scalability. It’s easy to (auto)scale web service, but (auto)scaling DBMS is a painfull experience. Resources required. Memory, CPU, hard drives, sockets, inodes. Backups. What and how to backup and how to restore it. Purpose. What that thing exactly do. So when something doesnt work one can just restart that exact service. And remember: what you may call an “app” within your development team is a service too. Yep, rails-loaded puma is an http service worth describing. Phoenix-loaded cowboy is an http service. Spring-loaded java instance is a bad idea java is bad get rid of it like right now. Networking What services are exposed to the world and what connectivity your services require (interconnections, infranet endpoints). That’s some important info for bootstrapping whatever you shitcoded for months. Handles Have script to wash it out? Internal buttons to rebuild caches? If not, make em. Then describe em. Some sort of conclusion Do that and beyond. Do not just write code — build exploitable services instead. Mkay?" />
<meta property="og:description" content="Introduction This post is mostly for those careless whisperers programmers who write code with no care for exploitation. What is exploitation? Wiktionary defines exploitation as “The act of utilizing something”. So how does one utilize programs? Sets it up, configures it and ensures that it runs as instruction specifies. In order to make your program exploitatable you need to provide documentation for every of these three steps. Truth is, it’s rare to see any documentation at all, so exploitation is done poorly. “It works somehow” approach. “Just reboot it” approach. All that stuff. He’re some tips on how to make web-services easy to exploitate. Here’s some well known paper on that matter, which is more declarative, formal and extensive. I do not discuss end-user installed programs, ‘cause it also requires a ton of information on distribution, which I’m not familiar with. Standardize it! By that I mean two things. Make exploitation documentation standard First, ask your exploitation department colleagues (DevOpses?). Especially if you already have some systems in exploitation (i.e. in production). What they use? What information they lack? Second, inspect your projects (both in exploitation and in early develoment). Think of all common bells and whistles to be configured, some situations that may occur. You may think your system is easy to understand for everybody. Truth is, it’s not. After all common information gathered write a template of exploitation docs and show it to everybody. Discuss it, improve it. But do not “carve this template in stone”. After every incident (especially post mortems) think of adding some things that could help exploitation team make it through harsh times without your help. Amend (but wisely!) it. Remove unused things. Make it mandatory for every developer This is a bit more difficult. If you’re on team lead/manager/big boss position, use your power to make documenting exploitation mandatory. If not, use social engineering, meritocracy, your boss, your reputation. Become an asshole. But force everybody to write that. Trust me, it will save your sleep at night (especially if you’re team lead/manager). Make your system exploitatable That’s complicated too. All that 12-factor apps stuff (and beyond) goes here. Environment configuration files First thing I encountered countless times is “environment configuration file”. God, please, get rid of it! If your config folder contains more than production and derived from it development and test configs, you’ve done bad. Just imagine, what could happen if at 1:00 am your DB server crashes without any chance to restore, but exploitation guys can quickly (within SLA time!) restore it with different IP address/domain name. How could you change your DB hostname on the go without redeploying your app if you have it (DB hostname) in git-controlled folder with no chance to change it “on the go”? Sleepless night will suddenly get into your life =) So, to make your system configurable “on the go” either use some sort of config provider, or simply put everything into ENV-variables with default values. And voila, more sleep for your really tired brain that night! Oh, and of course it (ENV-variables, config providers, etc.) well worth documenting. Trust me. Add readiness and liveness checks Or, as some call them, health checks. Why? Your server needs to know how when your app has loaded (readiness check) and when it crashed (liveness check). For web apps just / with 200 OK usually is enough for both. Then describe it in your exploitation documentation. Add custom monitoring endpoint Thing is, your exploitation team already has some tool to monitor your app. Help them! You’re unsure of some really weird errors? Push those events to monitoring system! Has external systems? Check them! We (on projects I developed) used /healthcheck with this content: db ok smtp ok rabbitmq ok Again, put that into exploitation documentation. Describe every service Use DBMS? Has web server? Send emails? Describe it! For every service you should describe: Where to get. Code? Docker/rkt images? RPM-packages? How to start: commands and arguments, flags, etc. What to do at first start. Like putting in some seed data with specific command. Dependencies. I bet you don’t want to start your app-server before DB. Scalability. It’s easy to (auto)scale web service, but (auto)scaling DBMS is a painfull experience. Resources required. Memory, CPU, hard drives, sockets, inodes. Backups. What and how to backup and how to restore it. Purpose. What that thing exactly do. So when something doesnt work one can just restart that exact service. And remember: what you may call an “app” within your development team is a service too. Yep, rails-loaded puma is an http service worth describing. Phoenix-loaded cowboy is an http service. Spring-loaded java instance is a bad idea java is bad get rid of it like right now. Networking What services are exposed to the world and what connectivity your services require (interconnections, infranet endpoints). That’s some important info for bootstrapping whatever you shitcoded for months. Handles Have script to wash it out? Internal buttons to rebuild caches? If not, make em. Then describe em. Some sort of conclusion Do that and beyond. Do not just write code — build exploitable services instead. Mkay?" />
<link rel="canonical" href="https://ivalentinee.github.io/en/programming/2019/07/17/exploitation-first.html" />
<meta property="og:url" content="https://ivalentinee.github.io/en/programming/2019/07/17/exploitation-first.html" />
<meta property="og:site_name" content="ivalentinee" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-07-17T00:00:00+00:00" />
<script type="application/ld+json">
{"description":"Introduction This post is mostly for those careless whisperers programmers who write code with no care for exploitation. What is exploitation? Wiktionary defines exploitation as “The act of utilizing something”. So how does one utilize programs? Sets it up, configures it and ensures that it runs as instruction specifies. In order to make your program exploitatable you need to provide documentation for every of these three steps. Truth is, it’s rare to see any documentation at all, so exploitation is done poorly. “It works somehow” approach. “Just reboot it” approach. All that stuff. He’re some tips on how to make web-services easy to exploitate. Here’s some well known paper on that matter, which is more declarative, formal and extensive. I do not discuss end-user installed programs, ‘cause it also requires a ton of information on distribution, which I’m not familiar with. Standardize it! By that I mean two things. Make exploitation documentation standard First, ask your exploitation department colleagues (DevOpses?). Especially if you already have some systems in exploitation (i.e. in production). What they use? What information they lack? Second, inspect your projects (both in exploitation and in early develoment). Think of all common bells and whistles to be configured, some situations that may occur. You may think your system is easy to understand for everybody. Truth is, it’s not. After all common information gathered write a template of exploitation docs and show it to everybody. Discuss it, improve it. But do not “carve this template in stone”. After every incident (especially post mortems) think of adding some things that could help exploitation team make it through harsh times without your help. Amend (but wisely!) it. Remove unused things. Make it mandatory for every developer This is a bit more difficult. If you’re on team lead/manager/big boss position, use your power to make documenting exploitation mandatory. If not, use social engineering, meritocracy, your boss, your reputation. Become an asshole. But force everybody to write that. Trust me, it will save your sleep at night (especially if you’re team lead/manager). Make your system exploitatable That’s complicated too. All that 12-factor apps stuff (and beyond) goes here. Environment configuration files First thing I encountered countless times is “environment configuration file”. God, please, get rid of it! If your config folder contains more than production and derived from it development and test configs, you’ve done bad. Just imagine, what could happen if at 1:00 am your DB server crashes without any chance to restore, but exploitation guys can quickly (within SLA time!) restore it with different IP address/domain name. How could you change your DB hostname on the go without redeploying your app if you have it (DB hostname) in git-controlled folder with no chance to change it “on the go”? Sleepless night will suddenly get into your life =) So, to make your system configurable “on the go” either use some sort of config provider, or simply put everything into ENV-variables with default values. And voila, more sleep for your really tired brain that night! Oh, and of course it (ENV-variables, config providers, etc.) well worth documenting. Trust me. Add readiness and liveness checks Or, as some call them, health checks. Why? Your server needs to know how when your app has loaded (readiness check) and when it crashed (liveness check). For web apps just / with 200 OK usually is enough for both. Then describe it in your exploitation documentation. Add custom monitoring endpoint Thing is, your exploitation team already has some tool to monitor your app. Help them! You’re unsure of some really weird errors? Push those events to monitoring system! Has external systems? Check them! We (on projects I developed) used /healthcheck with this content: db ok smtp ok rabbitmq ok Again, put that into exploitation documentation. Describe every service Use DBMS? Has web server? Send emails? Describe it! For every service you should describe: Where to get. Code? Docker/rkt images? RPM-packages? How to start: commands and arguments, flags, etc. What to do at first start. Like putting in some seed data with specific command. Dependencies. I bet you don’t want to start your app-server before DB. Scalability. It’s easy to (auto)scale web service, but (auto)scaling DBMS is a painfull experience. Resources required. Memory, CPU, hard drives, sockets, inodes. Backups. What and how to backup and how to restore it. Purpose. What that thing exactly do. So when something doesnt work one can just restart that exact service. And remember: what you may call an “app” within your development team is a service too. Yep, rails-loaded puma is an http service worth describing. Phoenix-loaded cowboy is an http service. Spring-loaded java instance is a bad idea java is bad get rid of it like right now. Networking What services are exposed to the world and what connectivity your services require (interconnections, infranet endpoints). That’s some important info for bootstrapping whatever you shitcoded for months. Handles Have script to wash it out? Internal buttons to rebuild caches? If not, make em. Then describe em. Some sort of conclusion Do that and beyond. Do not just write code — build exploitable services instead. Mkay?","headline":"Exploitation first!","dateModified":"2019-07-17T00:00:00+00:00","datePublished":"2019-07-17T00:00:00+00:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ivalentinee.github.io/en/programming/2019/07/17/exploitation-first.html"},"url":"https://ivalentinee.github.io/en/programming/2019/07/17/exploitation-first.html","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://ivalentinee.github.io/feed.xml" title="ivalentinee" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/en/">ivalentinee</a>

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
              
            
          
            
            
              
                <a class="page-link" href="/en/about/">About</a>
              
            
          
            
            
              
            
          
            
            
              
            
          
            
            
          
            
            
          
            
            
          
            
            
              
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Exploitation first!</h1>
    <p class="post-meta">
      <time datetime="2019-07-17T00:00:00+00:00" itemprop="datePublished">
        
        Jul 17, 2019
      </time>
      </p>
  </header>

  

  <div class="post-content" itemprop="articleBody">
    <h2 id="introduction">Introduction</h2>

<p>This post is mostly for those careless <del><a href="https://youtu.be/izGwDsrQ1eQ">whisperers</a></del> programmers who write code with no care for exploitation.</p>

<p>What is <strong>exploitation</strong>? <a href="https://en.wiktionary.org/wiki/exploitation">Wiktionary defines exploitation</a> as “The act of utilizing something”. So how does one utilize programs? Sets it up, configures it and ensures that it runs as instruction specifies.</p>

<p>In order to make your program exploitatable you need to provide documentation for every of these three steps.</p>

<p>Truth is, it’s rare to see <strong>any</strong> documentation at all, so exploitation is done poorly. “It works somehow” approach. “Just reboot it” approach. All that stuff.</p>

<p>He’re some tips on how to make web-services easy to exploitate. Here’s <a href="https://12factor.net/">some well known paper</a> on that matter, which is more declarative, formal and extensive.</p>

<p>I do not discuss end-user installed programs, ‘cause it also requires a ton of information on distribution, which I’m not familiar with.</p>

<h2 id="standardize-it">Standardize it!</h2>

<p>By that I mean two things.</p>

<h3 id="make-exploitation-documentation-standard">Make exploitation documentation standard</h3>
<p>First, ask your exploitation department colleagues (DevOpses?). Especially if you already have some systems in exploitation (i.e. in production). What they use? What information they lack?</p>

<p>Second, inspect your projects (both in exploitation and in early develoment). Think of all common bells and whistles to be configured, some situations that may occur. You may think your system is easy to understand for everybody. Truth is, it’s not.</p>

<p>After all common information gathered write a template of exploitation docs and show it to everybody. Discuss it, improve it.</p>

<p>But do not “carve this template in stone”. After every incident (especially post mortems) think of adding some things that could help exploitation team make it through harsh times without your help. Amend (but wisely!) it. Remove unused things.</p>

<h3 id="make-it-mandatory-for-every-developer">Make it mandatory for every developer</h3>
<p>This is a bit more difficult. If you’re on team lead/manager/big boss position, use your power to make documenting exploitation mandatory. If not, use social engineering, meritocracy, your boss, your reputation. Become an asshole. But force everybody to write that. Trust me, it will save your sleep at night (especially if you’re team lead/manager).</p>

<h2 id="make-your-system-exploitatable">Make your system exploitatable</h2>
<p>That’s complicated too. All that 12-factor apps stuff (and beyond) goes here.</p>

<h3 id="environment-configuration-files">Environment configuration files</h3>
<p>First thing I encountered countless times is “environment configuration file”. God, please, get rid of it! If your <code class="highlighter-rouge">config</code> folder contains more than <code class="highlighter-rouge">production</code> and derived from it <code class="highlighter-rouge">development</code> and <code class="highlighter-rouge">test</code> configs, you’ve done bad. Just imagine, what could happen if at 1:00 am your DB server crashes without any chance to restore, but exploitation guys can quickly (within SLA time!) restore it with different IP address/domain name. How could you change your DB hostname on the go without redeploying your app if you have it (DB hostname) in git-controlled folder with no chance to change it “on the go”? Sleepless night will suddenly get into your life =)</p>

<p>So, to make your system configurable “on the go” either use some sort of config provider, or simply put everything into ENV-variables with default values. And voila, more sleep for your really tired brain that night!</p>

<p>Oh, and of course it (ENV-variables, config providers, etc.) well worth documenting. Trust me.</p>

<h3 id="add-readiness-and-liveness-checks">Add readiness and liveness checks</h3>
<p>Or, as some call them, health checks.
Why? Your server needs to know how when your app has loaded (readiness check) and when it crashed (liveness check).
For web apps just <code class="highlighter-rouge">/</code> with <code class="highlighter-rouge">200 OK</code> usually is enough for both.</p>

<p>Then describe it in your <strong>exploitation documentation</strong>.</p>

<h3 id="add-custom-monitoring-endpoint">Add custom monitoring endpoint</h3>
<p>Thing is, your exploitation team already has some tool to monitor your app. Help them!</p>

<p>You’re unsure of some really weird errors? Push those events to monitoring system! Has external systems? Check them!</p>

<p>We (on projects I developed) used <code class="highlighter-rouge">/healthcheck</code> with this content:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>db ok
smtp ok
rabbitmq ok
</code></pre></div></div>

<p>Again, put that into <strong>exploitation documentation</strong>.</p>

<h3 id="describe-every-service">Describe every service</h3>
<p>Use DBMS? Has web server? Send emails? Describe it!</p>

<p>For every service you should describe:</p>
<ol>
  <li>Where to get. Code? Docker/rkt images? RPM-packages?</li>
  <li>How to start: commands and arguments, flags, etc.</li>
  <li>What to do at first start. Like putting in some seed data with specific command.</li>
  <li>Dependencies. I bet you don’t want to start your app-server before DB.</li>
  <li>Scalability. It’s easy to (auto)scale web service, but (auto)scaling DBMS is a painfull experience.</li>
  <li>Resources required. Memory, CPU, hard drives, sockets, inodes.</li>
  <li>Backups. What and how to backup and how to restore it.</li>
  <li>Purpose. What that thing exactly do. So when something doesnt work one can just restart that exact service.</li>
</ol>

<p>And remember: what you may call an “app” within your development team is a service too. Yep, rails-loaded puma is <strong>an http service</strong> worth describing. Phoenix-loaded cowboy is <strong>an http service</strong>. <del>Spring-loaded java instance <em>is a bad idea java is bad get rid of it like right now</em></del>.</p>

<h3 id="networking">Networking</h3>
<p>What services are exposed to the world and what connectivity your services require (interconnections, infranet endpoints). That’s some important info for bootstrapping whatever you shitcoded for months.</p>

<h3 id="handles">Handles</h3>
<p>Have script to wash it out? Internal buttons to rebuild caches?<br />
If not, make em.<br />
Then describe em.</p>

<h2 id="some-sort-of-conclusion">Some sort of conclusion</h2>
<p>Do that and beyond. Do not just write code — build exploitable services instead. Mkay?</p>

  </div>

  
  <div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://ivalentinee.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>

  
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">ivalentinee</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">ivalentinee</li><li><a class="u-email" href="mailto:valentine.emperor@gmail.com">valentine.emperor@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ivalentinee"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ivalentinee</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
