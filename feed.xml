<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://ivalentinee.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ivalentinee.github.io/" rel="alternate" type="text/html" hreflang="ru" /><updated>2025-07-21T20:34:58+00:00</updated><id>https://ivalentinee.github.io/feed.xml</id><title type="html">ivalentinee</title><entry xml:lang="ru"><title type="html">Как я перестал быть формалистом (и материалистом)</title><link href="https://ivalentinee.github.io/ru/programming/2025/03/17/formalism-lost.html" rel="alternate" type="text/html" title="Как я перестал быть формалистом (и материалистом)" /><published>2025-03-17T00:00:00+00:00</published><updated>2025-03-17T00:00:00+00:00</updated><id>https://ivalentinee.github.io/ru/programming/2025/03/17/formalism-lost</id><content type="html" xml:base="https://ivalentinee.github.io/ru/programming/2025/03/17/formalism-lost.html">&lt;h2 id=&quot;предупреждение&quot;&gt;&lt;strong&gt;Предупреждение&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Даже несколько.&lt;/p&gt;

&lt;h3 id=&quot;я-не-пытаюсь-ничего-никому-доказать&quot;&gt;Я не пытаюсь ничего никому доказать&lt;/h3&gt;
&lt;p&gt;Строго говоря, относительно формальных систем &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D1%8B_%D0%93%D1%91%D0%B4%D0%B5%D0%BB%D1%8F_%D0%BE_%D0%BD%D0%B5%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D1%82%D0%B5&quot;&gt;всё уже давно доказано до меня&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ну и мне просто лень.&lt;/p&gt;

&lt;h3 id=&quot;здесь-нет-никакой-новизны&quot;&gt;Здесь нет никакой новизны&lt;/h3&gt;
&lt;p&gt;Да, какие-нибудь &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%94%D1%80%D0%B5%D0%B2%D0%BD%D0%B5%D0%B3%D1%80%D0%B5%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%84%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F&quot;&gt;древние греки&lt;/a&gt; или &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D0%BC%D0%B5%D1%86%D0%BA%D0%B8%D0%B9_%D0%B8%D0%B4%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%BC&quot;&gt;не-столь-древние немцы&lt;/a&gt; давно уже всё это рассказали, показали и объяснили (наверно, я-то в философии ничего не понимаю).&lt;/p&gt;

&lt;h3 id=&quot;зачем-это-всё&quot;&gt;Зачем это всё?&lt;/h3&gt;
&lt;p&gt;Эту историю я уже несколько раз рассказывал друзьям/знакомым, не потому что считаю, что это что-то суперценное (хотя для меня оно таким и является), а потому что это, пожалуй, самый резкий перелом моего мировоззрения, о котором я могу вспомнить.&lt;/p&gt;

&lt;p&gt;Всё остальное было либо не так значительно, либо не так резко.&lt;/p&gt;

&lt;p&gt;Ну и, раз уж я написал, что новизны никакой тут нет, то поясню, что всё нижеописанное я не получил как оторванное знание, а &lt;em&gt;осознал&lt;/em&gt; в свои Христовы 33 года (что забавно, за неделю до дня рождения это всё началось и длилось пару-тройку месяцев).&lt;br /&gt;
Потому и думаю, что ценность может быть не в самой информации, а в описании пути, которым я к этому пришёл.&lt;/p&gt;

&lt;p&gt;Ну и чтобы не рассказывать это всё по 10 кругу каждый раз, составлю сей опус, чтобы на него ссылку кидать.&lt;/p&gt;

&lt;h3 id=&quot;будет-длинно&quot;&gt;Будет длинно&lt;/h3&gt;
&lt;p&gt;Да, даже для меня. &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%80%D1%80%D0%B8%D0%BD%D0%B3%D1%82%D0%BE%D0%BD,_%D0%91%D0%B8%D0%BB%D0%BB%D0%B8&quot;&gt;Стоит держаться покрепче&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;почему-я-собственно-стал-формалистом&quot;&gt;Почему я, собственно, стал формалистом&lt;/h2&gt;
&lt;p&gt;Факторы в основном исторические (хотя, если подумать, а какими ещё они могут быть?).&lt;/p&gt;

&lt;p&gt;Первое — вырос я в семье инженеров (т.е. тех, чья деятельность непосредственно связана с формальными дисциплинами).&lt;/p&gt;

&lt;p&gt;После чего (обладая отрицательным талантом к математике) я попал на физ-мат в 10-11 классах.&lt;/p&gt;

&lt;p&gt;Затем (всё ещё обладая отрицательным талантом к математике) я &lt;del&gt;совершенно случайно&lt;/del&gt; попал на специальность «Информационные системы» в родном Политехе.&lt;br /&gt;
Конечно, не абсолютно случайно.&lt;br /&gt;
Нужно поблагодарить Юлию Александровну, благодаря которой я понял, что в этой жизни могу хотя бы что-то — писать программы школьного уровня.&lt;br /&gt;
И ещё Кириллу (еслы ты это читаешь, знай — я помню!), который по-приколу посоветовал мне закинуть документы на поступление именно на эту специальность.&lt;/p&gt;

&lt;p&gt;Потом я пошёл работать по специальности (не переставая отличаться отрицательным талантом к математике), которая целиком и полностью работает на формализме (хотя это, конечно, не совсем так — но об этом в другой раз).&lt;/p&gt;

&lt;p&gt;И так я в пиковой точке всей этой &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D1%8C%D0%B5%D1%80&quot;&gt;«карьерной»&lt;/a&gt; траектории оказался убеждённым формалистом (хотя я этого тогда и не осознавал).&lt;br /&gt;
Эх, весёлые были времена.&lt;/p&gt;

&lt;h2 id=&quot;моя-борьба-история-осознания&quot;&gt;Моя &lt;del&gt;борьба&lt;/del&gt; история осознания&lt;/h2&gt;
&lt;p&gt;Ну что, удачи (и мне и гипотетическому читателю).&lt;/p&gt;

&lt;h3 id=&quot;решил-я-однажды-поменять-работу&quot;&gt;Решил я однажды поменять работу&lt;/h3&gt;
&lt;p&gt;Причины указывать не буду — не стоит оно того. Оговорюсь только, что причины были сугубо личные (тараканы в голове). Сама работа была классная, и ребята — огонь.&lt;/p&gt;

&lt;p&gt;Попав на новое место работы я оказался на проекте, где нужен был примитивный компилятор/интерпретатор &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D0%B7%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5&quot;&gt;визуального языка программирования&lt;/a&gt;. Что привело меня к &lt;a href=&quot;https://en.wikipedia.org/wiki/Types_and_Programming_Languages&quot;&gt;книге Бенджакина Пирса «Типы в языках программирования»&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Предисловие в этой книге в частности указывало (пусть и немного косвенно) о том, что один из ранних (если не самый ранний) шагов к &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%92%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0&quot;&gt;вычислительной математике&lt;/a&gt; (и, в частности, &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9B%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5&quot;&gt;лямбда-исчислению&lt;/a&gt; и &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0_%D0%BE%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B8&quot;&gt;проблеме остановки&lt;/a&gt;) — &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%B0%D0%B3%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%B0%D1%80%D0%B3%D1%83%D0%BC%D0%B5%D0%BD%D1%82&quot;&gt;диагональный аргумент Кантора&lt;/a&gt; и &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%BE%D0%BA%D1%81_%D0%A0%D0%B0%D1%81%D1%81%D0%B5%D0%BB%D0%B0&quot;&gt;последующая реакция на это Бертрана Рассела&lt;/a&gt; (да-да, &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D0%B5%D0%BB,_%D0%91%D0%B5%D1%80%D1%82%D1%80%D0%B0%D0%BD&quot;&gt;того самого&lt;/a&gt;, с &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A7%D0%B0%D0%B9%D0%BD%D0%B8%D0%BA_%D0%A0%D0%B0%D1%81%D1%81%D0%B5%D0%BB%D0%B0&quot;&gt;чайником&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Когда я начал копаться во всех этих фамилиях (попутно безуспешно пытаясь разобраться в основах &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%89%D0%B0%D1%8F_%D0%B0%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0&quot;&gt;абстрактной алгебры&lt;/a&gt;), я наткнулся на то, что &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%BB%D1%8C%D0%B1%D0%B5%D1%80%D1%82,_%D0%94%D0%B0%D0%B2%D0%B8%D0%B4&quot;&gt;Давид Гильберт&lt;/a&gt; успешно провалил &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B_%D0%93%D0%B8%D0%BB%D1%8C%D0%B1%D0%B5%D1%80%D1%82%D0%B0&quot;&gt;свою миссию&lt;/a&gt; единомоментно (ну ладно, не провалил, я тут просто драматизма накрутил), когда &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%93%D1%91%D0%B4%D0%B5%D0%BB%D1%8C,_%D0%9A%D1%83%D1%80%D1%82&quot;&gt;Курт Гёдель&lt;/a&gt; выступил с формулировкой и доказательством &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D1%8B_%D0%93%D1%91%D0%B4%D0%B5%D0%BB%D1%8F_%D0%BE_%D0%BD%D0%B5%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D1%82%D0%B5&quot;&gt;своих теорем о неполноте&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Зачем я (успешно перевирая ради драматизма историю математики) пишу обо всём этом?&lt;br /&gt;
Потому что именно тогда я нарвался как на сами &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D1%8B_%D0%93%D1%91%D0%B4%D0%B5%D0%BB%D1%8F_%D0%BE_%D0%BD%D0%B5%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D1%82%D0%B5&quot;&gt;теоремы о неполноте&lt;/a&gt; (окончательно сформировавшие &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%B7%D0%B8%D1%81_%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B9_%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B8&quot;&gt;фундаментальный кризис математики&lt;/a&gt;), так и на появившийся (в явном виде) в конце XIX — начале XX вв. раздел &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B8&quot;&gt;оснований математики&lt;/a&gt;, что очень скоро собралось в снежный ком осознаний.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Мысль первая: если математика не является абсолютом и требует наличия недоказуемых аксиом для своей работы, так ли она универсальна?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Смирившись на некоторое время с тем, что математика — не универсальное описание &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A3%D0%BD%D0%B8%D0%B2%D0%B5%D1%80%D1%81%D1%83%D0%BC&quot;&gt;всего бытия&lt;/a&gt;, я был доволен собой, потому что (не смотря на отрицательный талант к математике) я как-то это всё смог осознать.&lt;/p&gt;

&lt;p&gt;Но это было только начало… &lt;em&gt;(Драматическая пауза)&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;платон-прокрастинация-и-бум-нейросетей&quot;&gt;Платон, прокрастинация и бум нейросетей&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Совершенно внезапный заголовок, и совершенно внезапный поворот событий.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Тут я должен немного (на год примерно) отмотать время назад, потому что именно тогда я стал засиживаться за долгими (иногда до 6 утра) разговорами об истории, философии, литературе и языке с одним моим хорошим другом. Буду его в этой статье именовать &lt;em&gt;Евгением&lt;/em&gt; &lt;em&gt;(&lt;a href=&quot;https://kino.rambler.ru/movies/46835661-chto-zastavilo-kinoshnikov-pisat-frazu-vse-sobytiya-vymyshleny-lyubye-sovpadeniya-sluchayny/&quot;&gt;любые совпадения случайны&lt;/a&gt;)&lt;/em&gt;.&lt;br /&gt;
Если быть совсем точным, то я (ввиду ограниченного кругозора) был слушателем, а &lt;em&gt;Евгений&lt;/em&gt; заворачивал мне в уши кулстори про исторических персонажей, знаковые литературные произведения, всякие &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%BD%D0%B5%D1%80%D0%BE%D0%BD&quot;&gt;фанероны&lt;/a&gt; и прочую философию. &lt;em&gt;Евгений&lt;/em&gt;, если ты это читаешь — я всё это помню и сильно тебе за это благодарен!&lt;br /&gt;
«А чем я хуже?» — подумал я, решив вместо 3 часов листания тик-тока полистать его 2 часа и послушать &lt;a href=&quot;https://music.yandex.ru/album/14285010/track/78982908&quot;&gt;часовой подкаст про «эйдосы» Платона&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(Тут лучше ознакомиться с оригиналом или с хорошей статьёй — следующий абзац для таких же ленивых, как я — остальным лучше пропустить)&lt;/em&gt;&lt;br /&gt;
Так вот, если коротко (и если я не ошибаюсь), по Платону у любой вещи есть 4 аспекта (представления):&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;сам объект&lt;/strong&gt;, который существует в объективной реальности&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;тень&lt;/strong&gt; — существующие в объективной реальности косвенные признаки существования/присутствия объекта&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;слово&lt;/strong&gt; — то, чем пользуются люди для передачи информации об объекте&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;эйдос&lt;/strong&gt; — некоторая непередаваемая идея об объекте, которая существует только в сознании конкретного человека, и которую невозможно никак &lt;em&gt;ahem&lt;/em&gt; экстернализировать (т.е. вынести за пределы конкретного сознания).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Этот случай наложился на то, что в последние несколько лет искусственные (на базе ЭВМ, &lt;a href=&quot;https://habr.com/ru/news/888414/&quot;&gt;но не только&lt;/a&gt;) нейросети внезапно стали основной темой почти любых обсуждений и &lt;em&gt;ahem&lt;/em&gt; технологических прорывов.&lt;br /&gt;
Ввиду чего я регулярно занимался тем, что — абсолютно не обладая знаниями по теме — объяснял какие-то базовые принципы работы нейросетей своим друзьям и знакомым.&lt;br /&gt;
Что приводило к тому, что я и сам задумывался об этом всём (в рамках своих нулевых знаний).&lt;/p&gt;

&lt;p&gt;Случайно объединив эти два фактора я натолкнулся на вторую мысль в этом списке.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Мысль вторая: получается, человек может мыслить как словами (то, что мы обычно и принимаем за сознание), так и эйдосами (без внутреннего монолога/диалога)?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;В тот момент я и осознал, что именно &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B3,_%D0%9A%D0%B0%D1%80%D0%BB_%D0%93%D1%83%D1%81%D1%82%D0%B0%D0%B2&quot;&gt;некоторые&lt;/a&gt; &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A4%D1%80%D0%B5%D0%B9%D0%B4,_%D0%97%D0%B8%D0%B3%D0%BC%D1%83%D0%BD%D0%B4&quot;&gt;люди&lt;/a&gt; имеют ввиду (при проецировании на мою траекторию из этого текста), когда делят человека на «сознательное» и «бессознательное»: «мышление словами» и «мышление эйдосами».&lt;br /&gt;
Что, соответственно, сформировало моё понимание «интуиции» — «мышление эйдосами — т.е. мышление без использования &lt;em&gt;экстернализируемых&lt;/em&gt; сущностей (слов, картинок, звуков и прочего, что можно перенести в реальный мир)».&lt;/p&gt;

&lt;p&gt;Конечно, после такого осознания меня на пару дней, что называется, «разорвало». Это уже ломало мою (радикально формалистскую до того дня) картину мира, потому что то, что я считал &lt;em&gt;единственным способом мышления&lt;/em&gt; оказалось не только не &lt;em&gt;единственным&lt;/em&gt;, так ещё и &lt;em&gt;вторичным&lt;/em&gt; (по времени появления).&lt;br /&gt;
А ведь всего через пару дней меня «разорвало» ещё сильнее…&lt;/p&gt;

&lt;h3 id=&quot;математика-и-языки&quot;&gt;Математика и языки&lt;/h3&gt;
&lt;p&gt;Что же случилось через пару дней?&lt;/p&gt;

&lt;p&gt;Да ничего нового: я как обычно принимал сложный выбор ввиду нежелания моего организма уходить в сон: думать о самых безболезненных способах суицида или продолжать думать про Платона и математику.&lt;br /&gt;
Судя по тому, что этот текст вышел в свет — Платон и математика победили (и не один раз).&lt;/p&gt;

&lt;p&gt;Не томя долгим ожиданием (потому как и сам добрался от предыдущей мысли всего за два дня) приведу третью мысль.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Мысль третья: если математика не является универсальным языком (т.е. языком вселенной), то, получается, она является &lt;em&gt;только&lt;/em&gt; языком &lt;em&gt;для людей&lt;/em&gt;?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Если после второй мысли меня «разорвало» всего на пару дней, то с этим «разрывом» я живу уже несколько месяцев. Пока не отпускает.&lt;/p&gt;

&lt;p&gt;Экстраполировав «математику» до «любой формальной системы» (потому что хочу и могу), получаем, что любая формальная система — это всего лишь &lt;em&gt;особый язык&lt;/em&gt;, который люди используют для &lt;em&gt;общения с собой и другими людьми&lt;/em&gt;?&lt;/p&gt;

&lt;h3 id=&quot;невнезапная-философия&quot;&gt;(Не)Внезапная философия&lt;/h3&gt;
&lt;p&gt;Так вот, так как в некотором ракурсе можно философию рассматривать как науку о мышлении (давайте, философы, унижайте меня), получается&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Мысль третья-с-половиной: математика — это не более чем один из разделов философии?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Да, в ту ночь меня одолевали многие осознания, полностью ломая мою формалистскую картину мира.&lt;/p&gt;

&lt;h2 id=&quot;разрыв-экзистенциального-anus-круга&quot;&gt;Разрыв экзистенциального &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D1%87%D0%B8%D0%BC%D1%83%D1%87%D0%B8&quot;&gt;&lt;del&gt;anus&lt;/del&gt;&lt;/a&gt; круга&lt;/h2&gt;
&lt;p&gt;Казалось бы, жизнь сломана, существующее мировоззрение не клеится с новыми откровениями, так всё зря?&lt;/p&gt;

&lt;p&gt;И тут нужно вспомнить про мой &lt;em&gt;отрицательный талант к математике&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ведь, получается, даже если у меня всё плохо с мышлением в рамках математики (и формальных дисциплин/подходов вцелом), это не означает, что у меня плохо с &lt;em&gt;любым&lt;/em&gt; мышлением.&lt;br /&gt;
Вполне может быть что как раз-таки мышление &lt;em&gt;без формализма&lt;/em&gt; и &lt;em&gt;без экстернализируемых сущностей (внутреннего монолога)&lt;/em&gt; у меня на что-то годится?&lt;/p&gt;

&lt;p&gt;Конечно, можно это считать оправданием моей безмерной лени — всё-таки, я мог бы с большим скрипом целыми днями тратить свою «батарейку» на безрезультатное штудирование учебников по математическим (и вообще научным) дисциплинам.&lt;br /&gt;
Но я себя успокаиваю и продолжаю бесцельно листать тик-токи долгими вечерами.&lt;/p&gt;

&lt;h2 id=&quot;но-в-чем-тогда-фишка-формальных-дисциплин&quot;&gt;Но в чем тогда фишка формальных дисциплин?&lt;/h2&gt;
&lt;p&gt;Почему значительная часть развития человечества связано именно с развитием формальных дисциплин (формальная логика, математика, физика и пр.)?&lt;br /&gt;
Почему из всех разделов философии именно математика стала самым, &lt;em&gt;ahem&lt;/em&gt;, глубоко проработанным?&lt;/p&gt;

&lt;p&gt;Я долго думал над этим вопросом.&lt;br /&gt;
И (для себя) я нашёл ответ.&lt;/p&gt;

&lt;p&gt;Для начала надо признать, что хоть научное/технологическое развитие и является наиболее видимым (потому как сильнее всего представлено в материальном мире), всё-таки не-технологическое развитие не менее важно (и не связано напрямую с &lt;em&gt;развитием формальных дисциплин&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Так вот, формальный подход (в отличии от всего остального) позволяет «договориться на берегу»: сначала договориться о тех вещах, на которых строится вся остальная система (аксиомы), а потом уже на основе этих аксиом обсуждать всё остальное, что приводит к однозначному разрешению любых споров — нет места &lt;em&gt;мнению&lt;/em&gt; и &lt;em&gt;точке зрения&lt;/em&gt;.&lt;br /&gt;
Конечно, в момент интерпретации результатов формальных исследований споры становятся жаркими, но это уже проблема не самого формализма, а использования его результатов.&lt;/p&gt;

&lt;h2 id=&quot;заключение&quot;&gt;Заключение&lt;/h2&gt;
&lt;p&gt;Получилась в некотором роде «публичная исповедь».&lt;br /&gt;
Поэтому я искренне надеюсь на то, что этот текст будет прочитан только теми, кому я скину прямую ссылку.&lt;br /&gt;
Но если кто-то наткнулся случайно и &lt;em&gt;этот кто-то&lt;/em&gt; хочет выразить своё негодование и несогласие — пожалуйста. Кто я такой, чтобы &lt;em&gt;кого-то&lt;/em&gt; от этого останавливать.&lt;br /&gt;
Тем более, что весь этот опус выходит за рамки любой формальной системы, а потому доказательством (в научном понимании) не может являться.&lt;/p&gt;

&lt;p&gt;Это просто описание моего неожиданного путешествия, которым я (возможно) захочу с кем-то делиться — не тратя на это два часа разговоров.&lt;/p&gt;

&lt;p&gt;Ну и ждите продолжения (где-то тут на него будет ссылка).&lt;/p&gt;</content><author><name></name></author><summary type="html">Предупреждение Даже несколько. Я не пытаюсь ничего никому доказать Строго говоря, относительно формальных систем всё уже давно доказано до меня. Ну и мне просто лень. Здесь нет никакой новизны Да, какие-нибудь древние греки или не-столь-древние немцы давно уже всё это рассказали, показали и объяснили (наверно, я-то в философии ничего не понимаю). Зачем это всё? Эту историю я уже несколько раз рассказывал друзьям/знакомым, не потому что считаю, что это что-то суперценное (хотя для меня оно таким и является), а потому что это, пожалуй, самый резкий перелом моего мировоззрения, о котором я могу вспомнить. Всё остальное было либо не так значительно, либо не так резко. Ну и, раз уж я написал, что новизны никакой тут нет, то поясню, что всё нижеописанное я не получил как оторванное знание, а осознал в свои Христовы 33 года (что забавно, за неделю до дня рождения это всё началось и длилось пару-тройку месяцев). Потому и думаю, что ценность может быть не в самой информации, а в описании пути, которым я к этому пришёл. Ну и чтобы не рассказывать это всё по 10 кругу каждый раз, составлю сей опус, чтобы на него ссылку кидать. Будет длинно Да, даже для меня. Стоит держаться покрепче. Почему я, собственно, стал формалистом Факторы в основном исторические (хотя, если подумать, а какими ещё они могут быть?). Первое — вырос я в семье инженеров (т.е. тех, чья деятельность непосредственно связана с формальными дисциплинами). После чего (обладая отрицательным талантом к математике) я попал на физ-мат в 10-11 классах. Затем (всё ещё обладая отрицательным талантом к математике) я совершенно случайно попал на специальность «Информационные системы» в родном Политехе. Конечно, не абсолютно случайно. Нужно поблагодарить Юлию Александровну, благодаря которой я понял, что в этой жизни могу хотя бы что-то — писать программы школьного уровня. И ещё Кириллу (еслы ты это читаешь, знай — я помню!), который по-приколу посоветовал мне закинуть документы на поступление именно на эту специальность. Потом я пошёл работать по специальности (не переставая отличаться отрицательным талантом к математике), которая целиком и полностью работает на формализме (хотя это, конечно, не совсем так — но об этом в другой раз). И так я в пиковой точке всей этой «карьерной» траектории оказался убеждённым формалистом (хотя я этого тогда и не осознавал). Эх, весёлые были времена. Моя борьба история осознания Ну что, удачи (и мне и гипотетическому читателю). Решил я однажды поменять работу Причины указывать не буду — не стоит оно того. Оговорюсь только, что причины были сугубо личные (тараканы в голове). Сама работа была классная, и ребята — огонь. Попав на новое место работы я оказался на проекте, где нужен был примитивный компилятор/интерпретатор визуального языка программирования. Что привело меня к книге Бенджакина Пирса «Типы в языках программирования». Предисловие в этой книге в частности указывало (пусть и немного косвенно) о том, что один из ранних (если не самый ранний) шагов к вычислительной математике (и, в частности, лямбда-исчислению и проблеме остановки) — диагональный аргумент Кантора и последующая реакция на это Бертрана Рассела (да-да, того самого, с чайником). Когда я начал копаться во всех этих фамилиях (попутно безуспешно пытаясь разобраться в основах абстрактной алгебры), я наткнулся на то, что Давид Гильберт успешно провалил свою миссию единомоментно (ну ладно, не провалил, я тут просто драматизма накрутил), когда Курт Гёдель выступил с формулировкой и доказательством своих теорем о неполноте. Зачем я (успешно перевирая ради драматизма историю математики) пишу обо всём этом? Потому что именно тогда я нарвался как на сами теоремы о неполноте (окончательно сформировавшие фундаментальный кризис математики), так и на появившийся (в явном виде) в конце XIX — начале XX вв. раздел оснований математики, что очень скоро собралось в снежный ком осознаний. Мысль первая: если математика не является абсолютом и требует наличия недоказуемых аксиом для своей работы, так ли она универсальна? Смирившись на некоторое время с тем, что математика — не универсальное описание всего бытия, я был доволен собой, потому что (не смотря на отрицательный талант к математике) я как-то это всё смог осознать. Но это было только начало… (Драматическая пауза) Платон, прокрастинация и бум нейросетей Совершенно внезапный заголовок, и совершенно внезапный поворот событий. Тут я должен немного (на год примерно) отмотать время назад, потому что именно тогда я стал засиживаться за долгими (иногда до 6 утра) разговорами об истории, философии, литературе и языке с одним моим хорошим другом. Буду его в этой статье именовать Евгением (любые совпадения случайны). Если быть совсем точным, то я (ввиду ограниченного кругозора) был слушателем, а Евгений заворачивал мне в уши кулстори про исторических персонажей, знаковые литературные произведения, всякие фанероны и прочую философию. Евгений, если ты это читаешь — я всё это помню и сильно тебе за это благодарен! «А чем я хуже?» — подумал я, решив вместо 3 часов листания тик-тока полистать его 2 часа и послушать часовой подкаст про «эйдосы» Платона. (Тут лучше ознакомиться с оригиналом или с хорошей статьёй — следующий абзац для таких же ленивых, как я — остальным лучше пропустить) Так вот, если коротко (и если я не ошибаюсь), по Платону у любой вещи есть 4 аспекта (представления): сам объект, который существует в объективной реальности тень — существующие в объективной реальности косвенные признаки существования/присутствия объекта слово — то, чем пользуются люди для передачи информации об объекте эйдос — некоторая непередаваемая идея об объекте, которая существует только в сознании конкретного человека, и которую невозможно никак ahem экстернализировать (т.е. вынести за пределы конкретного сознания). Этот случай наложился на то, что в последние несколько лет искусственные (на базе ЭВМ, но не только) нейросети внезапно стали основной темой почти любых обсуждений и ahem технологических прорывов. Ввиду чего я регулярно занимался тем, что — абсолютно не обладая знаниями по теме — объяснял какие-то базовые принципы работы нейросетей своим друзьям и знакомым. Что приводило к тому, что я и сам задумывался об этом всём (в рамках своих нулевых знаний). Случайно объединив эти два фактора я натолкнулся на вторую мысль в этом списке. Мысль вторая: получается, человек может мыслить как словами (то, что мы обычно и принимаем за сознание), так и эйдосами (без внутреннего монолога/диалога)? В тот момент я и осознал, что именно некоторые люди имеют ввиду (при проецировании на мою траекторию из этого текста), когда делят человека на «сознательное» и «бессознательное»: «мышление словами» и «мышление эйдосами». Что, соответственно, сформировало моё понимание «интуиции» — «мышление эйдосами — т.е. мышление без использования экстернализируемых сущностей (слов, картинок, звуков и прочего, что можно перенести в реальный мир)». Конечно, после такого осознания меня на пару дней, что называется, «разорвало». Это уже ломало мою (радикально формалистскую до того дня) картину мира, потому что то, что я считал единственным способом мышления оказалось не только не единственным, так ещё и вторичным (по времени появления). А ведь всего через пару дней меня «разорвало» ещё сильнее… Математика и языки Что же случилось через пару дней? Да ничего нового: я как обычно принимал сложный выбор ввиду нежелания моего организма уходить в сон: думать о самых безболезненных способах суицида или продолжать думать про Платона и математику. Судя по тому, что этот текст вышел в свет — Платон и математика победили (и не один раз). Не томя долгим ожиданием (потому как и сам добрался от предыдущей мысли всего за два дня) приведу третью мысль. Мысль третья: если математика не является универсальным языком (т.е. языком вселенной), то, получается, она является только языком для людей? Если после второй мысли меня «разорвало» всего на пару дней, то с этим «разрывом» я живу уже несколько месяцев. Пока не отпускает. Экстраполировав «математику» до «любой формальной системы» (потому что хочу и могу), получаем, что любая формальная система — это всего лишь особый язык, который люди используют для общения с собой и другими людьми? (Не)Внезапная философия Так вот, так как в некотором ракурсе можно философию рассматривать как науку о мышлении (давайте, философы, унижайте меня), получается Мысль третья-с-половиной: математика — это не более чем один из разделов философии? Да, в ту ночь меня одолевали многие осознания, полностью ломая мою формалистскую картину мира. Разрыв экзистенциального anus круга Казалось бы, жизнь сломана, существующее мировоззрение не клеится с новыми откровениями, так всё зря? И тут нужно вспомнить про мой отрицательный талант к математике. Ведь, получается, даже если у меня всё плохо с мышлением в рамках математики (и формальных дисциплин/подходов вцелом), это не означает, что у меня плохо с любым мышлением. Вполне может быть что как раз-таки мышление без формализма и без экстернализируемых сущностей (внутреннего монолога) у меня на что-то годится? Конечно, можно это считать оправданием моей безмерной лени — всё-таки, я мог бы с большим скрипом целыми днями тратить свою «батарейку» на безрезультатное штудирование учебников по математическим (и вообще научным) дисциплинам. Но я себя успокаиваю и продолжаю бесцельно листать тик-токи долгими вечерами. Но в чем тогда фишка формальных дисциплин? Почему значительная часть развития человечества связано именно с развитием формальных дисциплин (формальная логика, математика, физика и пр.)? Почему из всех разделов философии именно математика стала самым, ahem, глубоко проработанным? Я долго думал над этим вопросом. И (для себя) я нашёл ответ. Для начала надо признать, что хоть научное/технологическое развитие и является наиболее видимым (потому как сильнее всего представлено в материальном мире), всё-таки не-технологическое развитие не менее важно (и не связано напрямую с развитием формальных дисциплин). Так вот, формальный подход (в отличии от всего остального) позволяет «договориться на берегу»: сначала договориться о тех вещах, на которых строится вся остальная система (аксиомы), а потом уже на основе этих аксиом обсуждать всё остальное, что приводит к однозначному разрешению любых споров — нет места мнению и точке зрения. Конечно, в момент интерпретации результатов формальных исследований споры становятся жаркими, но это уже проблема не самого формализма, а использования его результатов. Заключение Получилась в некотором роде «публичная исповедь». Поэтому я искренне надеюсь на то, что этот текст будет прочитан только теми, кому я скину прямую ссылку. Но если кто-то наткнулся случайно и этот кто-то хочет выразить своё негодование и несогласие — пожалуйста. Кто я такой, чтобы кого-то от этого останавливать. Тем более, что весь этот опус выходит за рамки любой формальной системы, а потому доказательством (в научном понимании) не может являться. Это просто описание моего неожиданного путешествия, которым я (возможно) захочу с кем-то делиться — не тратя на это два часа разговоров. Ну и ждите продолжения (где-то тут на него будет ссылка).</summary></entry><entry xml:lang="ru"><title type="html">Кросс-сборка Elixir-релизов amd64→arm64</title><link href="https://ivalentinee.github.io/ru/programming/2025/03/04/cross-compile-elixir.html" rel="alternate" type="text/html" title="Кросс-сборка Elixir-релизов amd64→arm64" /><published>2025-03-04T00:00:00+00:00</published><updated>2025-03-04T00:00:00+00:00</updated><id>https://ivalentinee.github.io/ru/programming/2025/03/04/cross-compile-elixir</id><content type="html" xml:base="https://ivalentinee.github.io/ru/programming/2025/03/04/cross-compile-elixir.html">&lt;h2 id=&quot;введение&quot;&gt;Введение&lt;/h2&gt;
&lt;p&gt;Как обычно, начнём с «Зачем?»&lt;/p&gt;

&lt;p&gt;Всё очень просто: Elixir-приложение я пишу на машине с amd64, а запускать релиз я буду на arm64 (RaspberryPi).&lt;/p&gt;

&lt;p&gt;И — чтобы не потерять рецепт — оставлю тут заметочку.&lt;/p&gt;

&lt;h2 id=&quot;а-есть-простой-путь&quot;&gt;А есть простой путь?&lt;/h2&gt;
&lt;p&gt;Нет. Elixir сам в такое не умеет, а — учитывая тот факт, что в Elixir-релизе лежит весь Erlang/OTP — вариант как со скриптовыми языками не прокатит.&lt;/p&gt;

&lt;p&gt;Да, конечно, можно собирать релиз без бинарей и требовать установки Erlang/OTP на машине, где оно будет запускаться, но это не наш метод. Нам надо &lt;code class=&quot;highlighter-rouge&quot;&gt;tar -xf release.tar.gz &amp;amp;&amp;amp; ./bin/release start&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;а-как&quot;&gt;А как?&lt;/h2&gt;
&lt;p&gt;Тут нам на помощь приходят две технологии: &lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker&lt;/a&gt; и &lt;a href=&quot;https://www.qemu.org/&quot;&gt;qemu&lt;/a&gt;. Конечно, вместо докера можно использовать связку &lt;a href=&quot;https://buildah.io/&quot;&gt;Buildah&lt;/a&gt; и &lt;a href=&quot;https://podman.io/&quot;&gt;Podman&lt;/a&gt;, но я для такого уже староват.&lt;/p&gt;

&lt;h3 id=&quot;что-то-мешает&quot;&gt;Что-то мешает?&lt;/h3&gt;
&lt;p&gt;Да.&lt;/p&gt;

&lt;p&gt;Казалось бы, можно просто добавить &lt;code class=&quot;highlighter-rouge&quot;&gt;--platform=linux/arm64&lt;/code&gt; в образ &lt;code class=&quot;highlighter-rouge&quot;&gt;FROM elixir:_version_&lt;/code&gt;, но, увы, есть одна проблема: &lt;a href=&quot;https://stackoverflow.com/questions/73954808/how-to-run-erlang-in-arm64-docker-image-on-x86-64-host&quot;&gt;qemu не совместим с JIT-компилятором Erlang’а&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;А отключается JIT только &lt;em&gt;при сборке Erlang/OTP&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;что-делать&quot;&gt;Что делать?&lt;/h3&gt;
&lt;p&gt;Собирать руками Erlang/OTP и Elixir, принудительно отключив JIT.&lt;/p&gt;

&lt;p&gt;Получится что-то примерно такое:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Dockerfile&quot;&gt;FROM --platform=linux/arm64 ubuntu:jammy-20250126

## Build OTP + Elixir
RUN apt update &amp;amp;&amp;amp; \
    apt install --no-install-recommends -y apt-utils libncurses-dev libwxgtk3.0-gtk3-dev libssl-dev openssl ca-certificates inotify-tools build-essential wget &amp;amp;&amp;amp; \
    apt clean

ENV OTP_VERSION=&quot;27.2.4&quot; ELIXIR_VERSION=&quot;1.18.2&quot;

ENV BUILD_PATH=/root/elixir \
    OTP_URL=&quot;https://github.com/erlang/otp/releases/download/OTP-$OTP_VERSION/otp_src_$OTP_VERSION.tar.gz&quot; \
    ELIXIR_VERSION=&quot;1.18.2&quot; \
    ELIXIR_URL=&quot;https://github.com/elixir-lang/elixir/archive/v$ELIXIR_VERSION.tar.gz&quot;

RUN mkdir -p $BUILD_PATH &amp;amp;&amp;amp; \
    rm -rf $BUILD_PATH &amp;amp;&amp;amp; \
    mkdir -p $BUILD_PATH/

RUN cd $BUILD_PATH/ &amp;amp;&amp;amp; \
    wget &quot;$OTP_URL&quot; &amp;amp;&amp;amp; tar -xf &quot;otp_src_$OTP_VERSION.tar.gz&quot; &amp;amp;&amp;amp; \
    cd &quot;$BUILD_PATH/otp_src_$OTP_VERSION&quot; &amp;amp;&amp;amp; \
    ./configure --disable-jit &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install

RUN cd $BUILD_PATH/ &amp;amp;&amp;amp; \
    wget $ELIXIR_URL &amp;amp;&amp;amp; tar -xf &quot;v$ELIXIR_VERSION.tar.gz&quot; &amp;amp;&amp;amp; \
    cd &quot;$BUILD_PATH/elixir-$ELIXIR_VERSION&quot; &amp;amp;&amp;amp; \
    make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ну и дальше собираем релиз в этом образе&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;## Build the app
RUN mkdir /app
WORKDIR /app

ARG RELEASE_NAME=my_app
ENV MIX_ENV=prod RELEASE_NAME=${RELEASE_NAME}

COPY ./mix.exs ./mix.lock /app
RUN mix deps.get &amp;amp;&amp;amp; mix deps.compile
RUN mix esbuild.install &amp;amp;&amp;amp; mix tailwind.install

COPY . /app
RUN mix compile
RUN mix assets.deploy &amp;amp;&amp;amp; mix phx.digest
RUN mix release $RELEASE_NAME
RUN tar -C &quot;./_build/prod/rel/${RELEASE_NAME}&quot; -cf release.tar ./
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;собираем-образ-и-вытаскиваем-релиз-из-докера&quot;&gt;Собираем образ и вытаскиваем релиз из докера&lt;/h3&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker build &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; my_app_arm64 &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; Dockerfile.arm64
docker run &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;:/build my_app_arm64 bash &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;cp /app/release.tar /build/release.tar&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;работать-будет-долго&quot;&gt;Работать будет долго&lt;/h3&gt;
&lt;p&gt;Очень долго. Надо потерпеть. Или купить машинку для сборки вместо ноутбука.&lt;/p&gt;

&lt;h3 id=&quot;получилось-не-всё&quot;&gt;Получилось не всё&lt;/h3&gt;
&lt;p&gt;Шаг &lt;code class=&quot;highlighter-rouge&quot;&gt;RUN mix assets.deploy&lt;/code&gt; у меня застревает — думаю, проще ассеты будет собрать на родной платформе (там всё равно кроме css и js ничего нет) и скопировать в образ перед сборкой релиза.&lt;/p&gt;

&lt;p&gt;Для этого в контейнере с родной архитектурой делаем &lt;code class=&quot;highlighter-rouge&quot;&gt;MIX_ENV=prod mix do assets.deploy, mix phx.digest&lt;/code&gt;, а в Dockerfile.arm64 вместо &lt;code class=&quot;highlighter-rouge&quot;&gt;RUN mix assets.deploy&lt;/code&gt; делаем &lt;code class=&quot;highlighter-rouge&quot;&gt;COPY ./priv/static /app/priv/static&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Полная команда получается такая:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker build &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; my_app &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
docker run &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;:/app my_app bash &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;MIX_ENV=prod mix assets.deploy&quot;&lt;/span&gt;
docker build &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; my_app_arm64 &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; Dockerfile.arm64
docker run &lt;span class=&quot;nt&quot;&gt;--rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;:/build my_app_arm64 bash &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;cp /app/release.tar /build/release.tar&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">Введение Как обычно, начнём с «Зачем?» Всё очень просто: Elixir-приложение я пишу на машине с amd64, а запускать релиз я буду на arm64 (RaspberryPi). И — чтобы не потерять рецепт — оставлю тут заметочку. А есть простой путь? Нет. Elixir сам в такое не умеет, а — учитывая тот факт, что в Elixir-релизе лежит весь Erlang/OTP — вариант как со скриптовыми языками не прокатит. Да, конечно, можно собирать релиз без бинарей и требовать установки Erlang/OTP на машине, где оно будет запускаться, но это не наш метод. Нам надо tar -xf release.tar.gz &amp;amp;&amp;amp; ./bin/release start. А как? Тут нам на помощь приходят две технологии: Docker и qemu. Конечно, вместо докера можно использовать связку Buildah и Podman, но я для такого уже староват. Что-то мешает? Да. Казалось бы, можно просто добавить --platform=linux/arm64 в образ FROM elixir:_version_, но, увы, есть одна проблема: qemu не совместим с JIT-компилятором Erlang’а. А отключается JIT только при сборке Erlang/OTP. Что делать? Собирать руками Erlang/OTP и Elixir, принудительно отключив JIT. Получится что-то примерно такое: FROM --platform=linux/arm64 ubuntu:jammy-20250126 ## Build OTP + Elixir RUN apt update &amp;amp;&amp;amp; \ apt install --no-install-recommends -y apt-utils libncurses-dev libwxgtk3.0-gtk3-dev libssl-dev openssl ca-certificates inotify-tools build-essential wget &amp;amp;&amp;amp; \ apt clean ENV OTP_VERSION=&quot;27.2.4&quot; ELIXIR_VERSION=&quot;1.18.2&quot; ENV BUILD_PATH=/root/elixir \ OTP_URL=&quot;https://github.com/erlang/otp/releases/download/OTP-$OTP_VERSION/otp_src_$OTP_VERSION.tar.gz&quot; \ ELIXIR_VERSION=&quot;1.18.2&quot; \ ELIXIR_URL=&quot;https://github.com/elixir-lang/elixir/archive/v$ELIXIR_VERSION.tar.gz&quot; RUN mkdir -p $BUILD_PATH &amp;amp;&amp;amp; \ rm -rf $BUILD_PATH &amp;amp;&amp;amp; \ mkdir -p $BUILD_PATH/ RUN cd $BUILD_PATH/ &amp;amp;&amp;amp; \ wget &quot;$OTP_URL&quot; &amp;amp;&amp;amp; tar -xf &quot;otp_src_$OTP_VERSION.tar.gz&quot; &amp;amp;&amp;amp; \ cd &quot;$BUILD_PATH/otp_src_$OTP_VERSION&quot; &amp;amp;&amp;amp; \ ./configure --disable-jit &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install RUN cd $BUILD_PATH/ &amp;amp;&amp;amp; \ wget $ELIXIR_URL &amp;amp;&amp;amp; tar -xf &quot;v$ELIXIR_VERSION.tar.gz&quot; &amp;amp;&amp;amp; \ cd &quot;$BUILD_PATH/elixir-$ELIXIR_VERSION&quot; &amp;amp;&amp;amp; \ make &amp;amp;&amp;amp; make install Ну и дальше собираем релиз в этом образе ## Build the app RUN mkdir /app WORKDIR /app ARG RELEASE_NAME=my_app ENV MIX_ENV=prod RELEASE_NAME=${RELEASE_NAME} COPY ./mix.exs ./mix.lock /app RUN mix deps.get &amp;amp;&amp;amp; mix deps.compile RUN mix esbuild.install &amp;amp;&amp;amp; mix tailwind.install COPY . /app RUN mix compile RUN mix assets.deploy &amp;amp;&amp;amp; mix phx.digest RUN mix release $RELEASE_NAME RUN tar -C &quot;./_build/prod/rel/${RELEASE_NAME}&quot; -cf release.tar ./ Собираем образ и вытаскиваем релиз из докера docker build -t my_app_arm64 . -f Dockerfile.arm64 docker run --rm -v $(pwd):/build my_app_arm64 bash -c &quot;cp /app/release.tar /build/release.tar&quot; Работать будет долго Очень долго. Надо потерпеть. Или купить машинку для сборки вместо ноутбука. Получилось не всё Шаг RUN mix assets.deploy у меня застревает — думаю, проще ассеты будет собрать на родной платформе (там всё равно кроме css и js ничего нет) и скопировать в образ перед сборкой релиза. Для этого в контейнере с родной архитектурой делаем MIX_ENV=prod mix do assets.deploy, mix phx.digest, а в Dockerfile.arm64 вместо RUN mix assets.deploy делаем COPY ./priv/static /app/priv/static. Полная команда получается такая: docker build -t my_app . docker run --rm -v $(pwd):/app my_app bash -c &quot;MIX_ENV=prod mix assets.deploy&quot; docker build -t my_app_arm64 . -f Dockerfile.arm64 docker run --rm -v $(pwd):/build my_app_arm64 bash -c &quot;cp /app/release.tar /build/release.tar&quot;</summary></entry><entry xml:lang="ru"><title type="html">Пробиваем колдуном 4 стену</title><link href="https://ivalentinee.github.io/ru/dnd/2024/10/04/4-wall-warlock.html" rel="alternate" type="text/html" title="Пробиваем колдуном 4 стену" /><published>2024-10-04T00:00:00+00:00</published><updated>2024-10-04T00:00:00+00:00</updated><id>https://ivalentinee.github.io/ru/dnd/2024/10/04/4-wall-warlock</id><content type="html" xml:base="https://ivalentinee.github.io/ru/dnd/2024/10/04/4-wall-warlock.html">&lt;h2 id=&quot;это-не-самая-оригинальная-идея&quot;&gt;Это не самая оригинальная идея&lt;/h2&gt;
&lt;p&gt;Да, я об этом знаю, и что? В какой-то мере эта идея рассматривалась в известных мне &lt;a href=&quot;https://www.kinopoisk.ru/film/363587/?utm_referrer=www.google.com&quot;&gt;The Gamers&lt;/a&gt;, и, полагаю, есть ещё много более интересных подходов с тем же уклоном.&lt;br /&gt;
А уж если смотреть в сторону литературы и кино, то там-то точно есть куча хороших примеров. Но я не киноман и не литературовед.&lt;/p&gt;

&lt;p&gt;Идея мне нравится, однако, в текущей кампании у меня уже есть персонаж, который участвовал во многих играх, а потому обладает не только устоявшейся историей и образом, но и интересным инвентарём.&lt;/p&gt;

&lt;p&gt;Если вдруг Игорь (мой текущий персонаж) помрём или совсем надоест, я воспользуюсь описанной в данной записи идеей (и, надеюсь, не поеду кукухой).&lt;/p&gt;

&lt;h2 id=&quot;откуда-ноги-растут&quot;&gt;Откуда ноги растут&lt;/h2&gt;
&lt;p&gt;Полезли мысли про данного персонажа в мою голову с того, что у Игорёшки (текущего персонажа — жреца) проблема существования бога стоит остро (для меня, как для игрока).&lt;br /&gt;
Потому я подумал: «А почему бы мне (игроку) не стать богом собственного персонажа?»&lt;/p&gt;

&lt;p&gt;Мысли интересные, но кроме забавного описания игровых особенностей не особо много (хотя тоже можно 4 стену пробить, если договориться с &lt;a href=&quot;/assets/img/posts/2024-10-04-4-wall-warlock/DM.jpg&quot;&gt;Мастером&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&quot;действующие-лица&quot;&gt;Действующие лица&lt;/h2&gt;
&lt;p&gt;Для того, чтобы играть этим персонажем, нужно 3 (1 + 1 + 0.5 + 0.5) «действующих лица».&lt;/p&gt;

&lt;p&gt;Двум из них я дам имя или название, чтобы проще было писать текст.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Действующее лицо 1: непосредственная личность персонажа. Я дам ему имя Няшесла́в Исека́евич (или Няшия́ Исека́евна для женского персонажа).&lt;/li&gt;
  &lt;li&gt;Действующее лицо 2: Игрок (без имени, так и оставим).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;собираем&quot;&gt;Собираем&lt;/h2&gt;
&lt;p&gt;Итак, основная идея в том, что персонаж — &lt;a href=&quot;https://ttg.club/classes/warlock&quot;&gt;колдун (чернокнижник, warlock)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Вместо того, чтобы искать этому персонажу внутриигрового патрона, патроном становится сам игрок.&lt;/p&gt;

&lt;h3 id=&quot;биполярочка&quot;&gt;Биполяр/очка&lt;/h3&gt;
&lt;p&gt;Вписывается уже неплохо, потому что проклятием персонажа становится не какое-нибудь обещание сжечь весь мир дотла, а биполяр/очка: персонаж ведёт себя либо так, как он хочет сам, либо так, как хочет игрок.&lt;/p&gt;

&lt;p&gt;Плюсом к этому бипоряр/очку будет ещё то, что разрываемая двумя сознаниями голова иногда сбоит, что приводит к вспышкам безумия.&lt;/p&gt;

&lt;p&gt;В результате (с согласования Мастера) можно построить следующую систему: в момент принятия важного решения (или если скажет Мастер) нужно кинуть D6 (или D12 с удвоением диапазонов) и интерпретировать результат следующим образом:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;5-6&lt;/code&gt;: До следующего броска нужно отыгрывать персонажа как Няшеслава, все действия и (почти) все мысли контролируются им.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;3-4&lt;/code&gt;: До следующего броска нужно отыгрывать персонажа как Игрока, все действия и (почти) все мысли контролируются им (Няшеслав как личность может только наблюдать и страдать).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;: У персонажа едет крыша, возниет внезапная вспышка доброты (Neutral Good) — нужно кому-то помочь, посочувствовать, проявить доброту и смирение, поверить даже абсолютному лжецу. После этого действия контроль возвращается Няшеславу.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;: У персонажа едет крыша, вспышка безумия (Chaotic Evil) заставляет сделать что-нибудь деструктивное: выбить окно, воткнуть кому-нибудь &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B5%D0%BB%D0%B8%D0%BB%D0%B8_%D0%BA%D0%BE%D0%BB%D0%B5%D0%BD%D0%BE&quot;&gt;в колено&lt;/a&gt; нож, выдать какую-нибудь оскорбляющую тираду тому, кто оказался ближе всего, проявить абсолютное недоверие и гнев собеседнику. После этого действия контроль возвращается Няшеславу.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Такая система позволяет большую часть времени отыгрывать Няшеслава, но иногда играть за персонажа как Игрок. Ну и вспышки безумия добавляют топлива в огонь.&lt;br /&gt;
Если Няшеслава будет мало, можно просто расширить его диапазон до &lt;code class=&quot;highlighter-rouge&quot;&gt;4-6&lt;/code&gt;, оставив Игроку одну только &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Бонусом будет, если Игрока тоже отыгрывать как вымышленную личность, сделав таким образом второго персонажа (Игрока), которого контролирует &lt;em&gt;тот, кто играет&lt;/em&gt;. Главное, чтобы от такого не поехала крыша.&lt;br /&gt;
Например, можно этого Игрока сделать типичным представителем группы «мне нужно всё сжечь и всех изнасиловать».&lt;/p&gt;

&lt;h3 id=&quot;что-по-патрону&quot;&gt;Что по патрону?&lt;/h3&gt;
&lt;p&gt;Лучше всего (и по описанию и по механикам) подходит «The Great Old One» («Великий Древний»). Доказывать не буду — почитайте сами.&lt;/p&gt;

&lt;p&gt;Механически «Awakened Mind» («Пробуждённый разум») — буквально общение персонажа через цепочку Персонаж→Игрок→Мастер→Существо. Вообще бомба получается.&lt;br /&gt;
Как и «Thought Shield» («Ментальный щит»): ни одно существо из игры не может прочитать мысли Игрока.&lt;/p&gt;

&lt;h3 id=&quot;что-по-пактам-договорам&quot;&gt;Что по пактам (договорам)?&lt;/h3&gt;
&lt;p&gt;Тут я рассматриваю два основных варианта: «Pact of the Chain» («Договор цепи») и «Pact of the Tome» («Договор гримуара»).&lt;/p&gt;

&lt;h4 id=&quot;pact-of-the-chain-договор-цепи&quot;&gt;«Pact of the Chain» («Договор цепи»)&lt;/h4&gt;
&lt;p&gt;Самый лютый вариант в отношении отыгрыша, потому что (по &lt;a href=&quot;https://en.wikipedia.org/wiki/Player%27s_Handbook&quot;&gt;PHB&lt;/a&gt;) фамильяр является скорее манифестацией патрона (Игрока), чем прислужником персонажа (Няшеслава).&lt;br /&gt;
Что приводит к забавной ситуации: у фамильяра с Няшеславом может возникнуть конфликт, что даёт возможность отыгрыша спора самого с собой.&lt;br /&gt;
И можно участвовать в партийных спорах с двумя точками зрения на проблему. Бррр.&lt;/p&gt;

&lt;p&gt;Конечно, это жуткое перетягивание одеяла на себя, поэтому тут нужно быть поосторожнее.&lt;/p&gt;

&lt;h4 id=&quot;pact-of-the-tome-договор-гримуара&quot;&gt;«Pact of the Tome» («Договор гримуара»)&lt;/h4&gt;
&lt;p&gt;Чуть менее лютый вариант. В данном случае подразумевается, что Игрок общается с Няшеславом через &lt;a href=&quot;https://harrypotter.fandom.com/ru/wiki/%D0%A2%D0%BE%D0%BC_%D0%A0%D0%B5%D0%B4%D0%B4%D0%BB&quot;&gt;возникающие в книге записи&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Плюсом этому варианту то, что &lt;a href=&quot;https://www.reddit.com/r/dndnext/comments/75lhyg/what_is_a_tomelock/?rdt=46283&quot;&gt;tomelock&lt;/a&gt; (книжкоколдун) — более интересный в плане механических возможностей вариант. Тут тебе и куча заговоров, и ритуалы (в том числе и &lt;a href=&quot;https://ttg.club/spells/find_familiar&quot;&gt;призыв фамильяра&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&quot;что-то-похожее-на-заключение&quot;&gt;Что-то похожее на заключение&lt;/h2&gt;
&lt;p&gt;Конечно, ввиду того, что постоянные броски кубиков напрямую указывают направление отыгрыша играть за такого персонажа может быть немного скучновато в долгой кампании — сильно меньше свободы.&lt;br /&gt;
С другой стороны, многие говорят, что креативность требует ограничений. Не могу не согласиться.&lt;/p&gt;

&lt;p&gt;Ну и, конечно, изображение на развороте описания Warlock’а в книге мне теперь сильно напоминает Няшию́ в состоянии безумия (или под контролем Игрока):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/2024-10-04-4-wall-warlock/PHB_Warlock.jpg&quot; alt=&quot;PHB Warlock&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Это не самая оригинальная идея Да, я об этом знаю, и что? В какой-то мере эта идея рассматривалась в известных мне The Gamers, и, полагаю, есть ещё много более интересных подходов с тем же уклоном. А уж если смотреть в сторону литературы и кино, то там-то точно есть куча хороших примеров. Но я не киноман и не литературовед. Идея мне нравится, однако, в текущей кампании у меня уже есть персонаж, который участвовал во многих играх, а потому обладает не только устоявшейся историей и образом, но и интересным инвентарём. Если вдруг Игорь (мой текущий персонаж) помрём или совсем надоест, я воспользуюсь описанной в данной записи идеей (и, надеюсь, не поеду кукухой). Откуда ноги растут Полезли мысли про данного персонажа в мою голову с того, что у Игорёшки (текущего персонажа — жреца) проблема существования бога стоит остро (для меня, как для игрока). Потому я подумал: «А почему бы мне (игроку) не стать богом собственного персонажа?» Мысли интересные, но кроме забавного описания игровых особенностей не особо много (хотя тоже можно 4 стену пробить, если договориться с Мастером). Действующие лица Для того, чтобы играть этим персонажем, нужно 3 (1 + 1 + 0.5 + 0.5) «действующих лица». Двум из них я дам имя или название, чтобы проще было писать текст. Действующее лицо 1: непосредственная личность персонажа. Я дам ему имя Няшесла́в Исека́евич (или Няшия́ Исека́евна для женского персонажа). Действующее лицо 2: Игрок (без имени, так и оставим). Собираем Итак, основная идея в том, что персонаж — колдун (чернокнижник, warlock). Вместо того, чтобы искать этому персонажу внутриигрового патрона, патроном становится сам игрок. Биполяр/очка Вписывается уже неплохо, потому что проклятием персонажа становится не какое-нибудь обещание сжечь весь мир дотла, а биполяр/очка: персонаж ведёт себя либо так, как он хочет сам, либо так, как хочет игрок. Плюсом к этому бипоряр/очку будет ещё то, что разрываемая двумя сознаниями голова иногда сбоит, что приводит к вспышкам безумия. В результате (с согласования Мастера) можно построить следующую систему: в момент принятия важного решения (или если скажет Мастер) нужно кинуть D6 (или D12 с удвоением диапазонов) и интерпретировать результат следующим образом: 5-6: До следующего броска нужно отыгрывать персонажа как Няшеслава, все действия и (почти) все мысли контролируются им. 3-4: До следующего броска нужно отыгрывать персонажа как Игрока, все действия и (почти) все мысли контролируются им (Няшеслав как личность может только наблюдать и страдать). 2: У персонажа едет крыша, возниет внезапная вспышка доброты (Neutral Good) — нужно кому-то помочь, посочувствовать, проявить доброту и смирение, поверить даже абсолютному лжецу. После этого действия контроль возвращается Няшеславу. 1: У персонажа едет крыша, вспышка безумия (Chaotic Evil) заставляет сделать что-нибудь деструктивное: выбить окно, воткнуть кому-нибудь в колено нож, выдать какую-нибудь оскорбляющую тираду тому, кто оказался ближе всего, проявить абсолютное недоверие и гнев собеседнику. После этого действия контроль возвращается Няшеславу. Такая система позволяет большую часть времени отыгрывать Няшеслава, но иногда играть за персонажа как Игрок. Ну и вспышки безумия добавляют топлива в огонь. Если Няшеслава будет мало, можно просто расширить его диапазон до 4-6, оставив Игроку одну только 3. Бонусом будет, если Игрока тоже отыгрывать как вымышленную личность, сделав таким образом второго персонажа (Игрока), которого контролирует тот, кто играет. Главное, чтобы от такого не поехала крыша. Например, можно этого Игрока сделать типичным представителем группы «мне нужно всё сжечь и всех изнасиловать». Что по патрону? Лучше всего (и по описанию и по механикам) подходит «The Great Old One» («Великий Древний»). Доказывать не буду — почитайте сами. Механически «Awakened Mind» («Пробуждённый разум») — буквально общение персонажа через цепочку Персонаж→Игрок→Мастер→Существо. Вообще бомба получается. Как и «Thought Shield» («Ментальный щит»): ни одно существо из игры не может прочитать мысли Игрока. Что по пактам (договорам)? Тут я рассматриваю два основных варианта: «Pact of the Chain» («Договор цепи») и «Pact of the Tome» («Договор гримуара»). «Pact of the Chain» («Договор цепи») Самый лютый вариант в отношении отыгрыша, потому что (по PHB) фамильяр является скорее манифестацией патрона (Игрока), чем прислужником персонажа (Няшеслава). Что приводит к забавной ситуации: у фамильяра с Няшеславом может возникнуть конфликт, что даёт возможность отыгрыша спора самого с собой. И можно участвовать в партийных спорах с двумя точками зрения на проблему. Бррр. Конечно, это жуткое перетягивание одеяла на себя, поэтому тут нужно быть поосторожнее. «Pact of the Tome» («Договор гримуара») Чуть менее лютый вариант. В данном случае подразумевается, что Игрок общается с Няшеславом через возникающие в книге записи. Плюсом этому варианту то, что tomelock (книжкоколдун) — более интересный в плане механических возможностей вариант. Тут тебе и куча заговоров, и ритуалы (в том числе и призыв фамильяра). Что-то похожее на заключение Конечно, ввиду того, что постоянные броски кубиков напрямую указывают направление отыгрыша играть за такого персонажа может быть немного скучновато в долгой кампании — сильно меньше свободы. С другой стороны, многие говорят, что креативность требует ограничений. Не могу не согласиться. Ну и, конечно, изображение на развороте описания Warlock’а в книге мне теперь сильно напоминает Няшию́ в состоянии безумия (или под контролем Игрока):</summary></entry><entry xml:lang="en"><title type="html">What’s the difference between git merge and git rebase?</title><link href="https://ivalentinee.github.io/en/programming/2024/02/06/git-merge-vs-git-rebase.html" rel="alternate" type="text/html" title="What's the difference between git merge and git rebase?" /><published>2024-02-06T00:00:00+00:00</published><updated>2024-02-06T00:00:00+00:00</updated><id>https://ivalentinee.github.io/en/programming/2024/02/06/git-merge-vs-git-rebase</id><content type="html" xml:base="https://ivalentinee.github.io/en/programming/2024/02/06/git-merge-vs-git-rebase.html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Let me first give an answer to “Why?”&lt;/p&gt;

&lt;p&gt;Well, I’m interviewing &lt;em&gt;Señor NodeJS developers&lt;/em&gt; for about 1.5 years (about half a year after I started using NodeJS myself, &lt;em&gt;oh, the irony&lt;/em&gt;). And the only (well, not the only, but the only one technical) git-related question I ask is this one.&lt;/p&gt;

&lt;p&gt;Why this question? Because the answer tells me exactly how deep a candidate went into a rabbit hole of “git”. And there’s more than one possible answer from “I don’t know” to “Actually git makes diffs dynamically”.&lt;/p&gt;

&lt;p&gt;So, to provide some feedback on this topic to candidates I need to have some prepared text, but I &lt;del&gt;failed to&lt;/del&gt; &lt;a href=&quot;https://www.edwardthomson.com/blog/merge_vs_rebase.html&quot;&gt;I managed in a half an hour of googling!&lt;/a&gt; to find a proper article. Thus I think I should &lt;del&gt;fix&lt;/del&gt; elaborate on this topic a bit.&lt;/p&gt;

&lt;p&gt;Let’s go through some possible answers and get to the ultimate one.&lt;/p&gt;

&lt;h2 id=&quot;weak-answers&quot;&gt;Weak answers&lt;/h2&gt;

&lt;h3 id=&quot;i-dont-know&quot;&gt;“I don’t know”&lt;/h3&gt;
&lt;p&gt;“Move along, there’s nothing to see here”. If you don’t know – you should go and find out. Maybe read this article (yeah, I’m hilarious, I know).&lt;/p&gt;

&lt;h3 id=&quot;merge-combines-the-code-while-rebase-applies-it-on-top&quot;&gt;“Merge combines the code while rebase applies it on top”&lt;/h3&gt;
&lt;p&gt;Well, yep, that’s technically correct since &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt; tries to, well, &lt;em&gt;merge&lt;/em&gt; (do you still remember I’m hilarious?) two branches into one, while &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt; &lt;strong&gt;applies&lt;/strong&gt; (not &lt;em&gt;re-bases&lt;/em&gt;, got ya!) commits on top of another branch. Still not enough of an explanation.&lt;/p&gt;

&lt;h3 id=&quot;rebase-changes-history&quot;&gt;“Rebase changes history”&lt;/h3&gt;
&lt;p&gt;If only it could undo &lt;em&gt;that particular embarassing moment you think everyone still remembers&lt;/em&gt;.&lt;br /&gt;
Jokes aside this answer is, again, technically correct, but if you care about non-changing commit history just go use &lt;a href=&quot;https://en.wikipedia.org/wiki/Mercurial&quot;&gt;Mercurial&lt;/a&gt;. Still not enough of an explanation.&lt;/p&gt;

&lt;h3 id=&quot;merge-combines-the-code-once-while-rebase-applies-commits-one-by-one&quot;&gt;“Merge combines the code once while rebase applies commits one-by-one”&lt;/h3&gt;
&lt;p&gt;That one is way more interesting but still does not point to, &lt;em&gt;ahem&lt;/em&gt;, pain points &lt;em&gt;pointed&lt;/em&gt; by the question (I’m still funny, a’right?).&lt;/p&gt;

&lt;p&gt;But that is waaaay closer to the real problem. Indeed, git does calculate diff &lt;strong&gt;only once&lt;/strong&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt; by comparing &lt;strong&gt;the latest state&lt;/strong&gt; for both branches, while &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt; does this &lt;strong&gt;for every commit&lt;/strong&gt; of a branch you’re rebasing.&lt;/p&gt;

&lt;h2 id=&quot;diff-is-calculated-differently-for-merge-and-rebase-merge-resolves-conflicts-in-a-merge-commit-while-rebase-resolves-em-for-every-commit-one-by-one&quot;&gt;“Diff is calculated differently for &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt; resolves conflicts in a merge-commit, while rebase resolves ‘em for every commit &lt;a href=&quot;https://youtu.be/gUaFD4JFU8c&quot;&gt;one-by-one&lt;/a&gt;”&lt;/h2&gt;
&lt;p&gt;Well, we’re miles closer to &lt;a href=&quot;https://en.wikipedia.org/wiki/The_X-Files&quot;&gt;&lt;em&gt;the truth&lt;/em&gt;&lt;/a&gt;. But there’s a nuance, which makes me to ask the next question: “What does that lead to?”&lt;/p&gt;

&lt;h3 id=&quot;what-does-that-lead-to&quot;&gt;“What does that lead to?”&lt;/h3&gt;

&lt;h4 id=&quot;different-git-blame&quot;&gt;“Different git blame”&lt;/h4&gt;
&lt;p&gt;So, the first answer to “What does that lead to?”.&lt;/p&gt;

&lt;p&gt;Explanation is pretty simple here (but not like evebody knows that): if there’re any conflicts, resolved code (&lt;strong&gt;even an automatically calculated one&lt;/strong&gt;) would be placed into a merge commit for &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt;, but will stay in related commits for &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To demonstrate this fact on a 2-hour workshop I made &lt;a href=&quot;https://github.com/ivalentinee/git-workshop/blob/master/manual/INDEX.md&quot;&gt;a small repo with examples&lt;/a&gt;. Go take a look if you have some time.&lt;/p&gt;

&lt;p&gt;And (if you don’t know that fact) I’m a huge advocate for &lt;strong&gt;git-blame-driven&lt;/strong&gt; approach, so I’d like to see some questionable line git blame to trace to an actual commit it relates to instead of some meaningless &lt;code class=&quot;highlighter-rouge&quot;&gt;Merge branch 'feature/fix-some-bug' into 'master'&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This makes me an advocate for &lt;em&gt;another questionable approach&lt;/em&gt;: devs should &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt; their branch &lt;em&gt;onto&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; right before merging that branch &lt;em&gt;into&lt;/em&gt; master to both have proper history &lt;strong&gt;and&lt;/strong&gt; a merge-commit to denote the fact of merging a branch.&lt;/p&gt;

&lt;h4 id=&quot;different-code&quot;&gt;“Different code”&lt;/h4&gt;
&lt;p&gt;This one is mindblowing. Other “reasons” have nothing to do with an actual code, just git history. This one is really dangerous (no joke, but remember, I’m still funny).&lt;/p&gt;

&lt;p&gt;Let’s take a look.&lt;br /&gt;
I’ll provide a full listing so you can go and find out what’s going on yourself:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Initialize a git repo&lt;/span&gt;
git init &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Make the first commit with a single file&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;some string&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; file.txt
git add file.txt
git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Initial commit&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Create two branches to play with&lt;/span&gt;
git branch branch-1
git branch branch-2

&lt;span class=&quot;c&quot;&gt;# Change that one line in &quot;branch-1&quot;&lt;/span&gt;
git checkout branch-1
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;some string // changed&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; file.txt
git add file.txt
git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Changed line 2 on branch 1&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Change that one line in &quot;branch-2&quot;&lt;/span&gt;
git checkout branch-2
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;some string // changed&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; file.txt
git add file.txt
git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Changed line 2 on branch 2&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Rewind that one line in &quot;branch-2&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;some string&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; file.txt
git add file.txt
git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Reverted line 2 on branch 2&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Copy &quot;branch-2&quot; to try both merge and rebase&lt;/span&gt;
git branch branch-2-non-modified

&lt;span class=&quot;c&quot;&gt;# Try &quot;git merge&quot;&lt;/span&gt;
git merge &lt;span class=&quot;nt&quot;&gt;--no-edit&lt;/span&gt; branch-1
&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;file.txt
&lt;span class=&quot;c&quot;&gt;# Getting &quot;some string // changed&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Reset &quot;branch-2&quot; to non-merged state&lt;/span&gt;
git reset &lt;span class=&quot;nt&quot;&gt;--hard&lt;/span&gt; branch-2-non-modified

&lt;span class=&quot;c&quot;&gt;# Try &quot;git rebase&quot;&lt;/span&gt;
git rebase branch-1
&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;file.txt
&lt;span class=&quot;c&quot;&gt;# Getting &quot;some string&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Exciting? It is! Especially so if told by a candidate.&lt;/p&gt;

&lt;p&gt;Why that happens? Well, go think, google – I’m too lazy (but still hilarious!) to write an explanation. Especially considering that I do not ask for an explanation on an interview – if a candidate knows the fact then I know for a fact (yep, I’m still funny! &lt;del&gt;Double&lt;/del&gt; Triple fact!) they got deep enough digging git.&lt;/p&gt;</content><author><name></name></author><summary type="html">Introduction Let me first give an answer to “Why?” Well, I’m interviewing Señor NodeJS developers for about 1.5 years (about half a year after I started using NodeJS myself, oh, the irony). And the only (well, not the only, but the only one technical) git-related question I ask is this one. Why this question? Because the answer tells me exactly how deep a candidate went into a rabbit hole of “git”. And there’s more than one possible answer from “I don’t know” to “Actually git makes diffs dynamically”. So, to provide some feedback on this topic to candidates I need to have some prepared text, but I failed to I managed in a half an hour of googling! to find a proper article. Thus I think I should fix elaborate on this topic a bit. Let’s go through some possible answers and get to the ultimate one. Weak answers “I don’t know” “Move along, there’s nothing to see here”. If you don’t know – you should go and find out. Maybe read this article (yeah, I’m hilarious, I know). “Merge combines the code while rebase applies it on top” Well, yep, that’s technically correct since merge tries to, well, merge (do you still remember I’m hilarious?) two branches into one, while rebase applies (not re-bases, got ya!) commits on top of another branch. Still not enough of an explanation. “Rebase changes history” If only it could undo that particular embarassing moment you think everyone still remembers. Jokes aside this answer is, again, technically correct, but if you care about non-changing commit history just go use Mercurial. Still not enough of an explanation. “Merge combines the code once while rebase applies commits one-by-one” That one is way more interesting but still does not point to, ahem, pain points pointed by the question (I’m still funny, a’right?). But that is waaaay closer to the real problem. Indeed, git does calculate diff only once for merge by comparing the latest state for both branches, while rebase does this for every commit of a branch you’re rebasing. “Diff is calculated differently for merge and rebase: merge resolves conflicts in a merge-commit, while rebase resolves ‘em for every commit one-by-one” Well, we’re miles closer to the truth. But there’s a nuance, which makes me to ask the next question: “What does that lead to?” “What does that lead to?” “Different git blame” So, the first answer to “What does that lead to?”. Explanation is pretty simple here (but not like evebody knows that): if there’re any conflicts, resolved code (even an automatically calculated one) would be placed into a merge commit for merge, but will stay in related commits for rebase. To demonstrate this fact on a 2-hour workshop I made a small repo with examples. Go take a look if you have some time. And (if you don’t know that fact) I’m a huge advocate for git-blame-driven approach, so I’d like to see some questionable line git blame to trace to an actual commit it relates to instead of some meaningless Merge branch 'feature/fix-some-bug' into 'master'. This makes me an advocate for another questionable approach: devs should rebase their branch onto master right before merging that branch into master to both have proper history and a merge-commit to denote the fact of merging a branch. “Different code” This one is mindblowing. Other “reasons” have nothing to do with an actual code, just git history. This one is really dangerous (no joke, but remember, I’m still funny). Let’s take a look. I’ll provide a full listing so you can go and find out what’s going on yourself: # Initialize a git repo git init . # Make the first commit with a single file echo &quot;some string&quot; &amp;gt; file.txt git add file.txt git commit -m &quot;Initial commit&quot; # Create two branches to play with git branch branch-1 git branch branch-2 # Change that one line in &quot;branch-1&quot; git checkout branch-1 echo &quot;some string // changed&quot; &amp;gt; file.txt git add file.txt git commit -m &quot;Changed line 2 on branch 1&quot; # Change that one line in &quot;branch-2&quot; git checkout branch-2 echo &quot;some string // changed&quot; &amp;gt; file.txt git add file.txt git commit -m &quot;Changed line 2 on branch 2&quot; # Rewind that one line in &quot;branch-2&quot; echo &quot;some string&quot; &amp;gt; file.txt git add file.txt git commit -m &quot;Reverted line 2 on branch 2&quot; # Copy &quot;branch-2&quot; to try both merge and rebase git branch branch-2-non-modified # Try &quot;git merge&quot; git merge --no-edit branch-1 cat file.txt # Getting &quot;some string // changed&quot; # Reset &quot;branch-2&quot; to non-merged state git reset --hard branch-2-non-modified # Try &quot;git rebase&quot; git rebase branch-1 cat file.txt # Getting &quot;some string&quot; Exciting? It is! Especially so if told by a candidate. Why that happens? Well, go think, google – I’m too lazy (but still hilarious!) to write an explanation. Especially considering that I do not ask for an explanation on an interview – if a candidate knows the fact then I know for a fact (yep, I’m still funny! Double Triple fact!) they got deep enough digging git.</summary></entry><entry xml:lang="ru"><title type="html">В чём разница между git merge и git rebase?</title><link href="https://ivalentinee.github.io/ru/programming/2024/02/06/git-merge-vs-git-rebase.html" rel="alternate" type="text/html" title="В чём разница между git merge и git rebase?" /><published>2024-02-06T00:00:00+00:00</published><updated>2024-02-06T00:00:00+00:00</updated><id>https://ivalentinee.github.io/ru/programming/2024/02/06/git-merge-vs-git-rebase</id><content type="html" xml:base="https://ivalentinee.github.io/ru/programming/2024/02/06/git-merge-vs-git-rebase.html">&lt;h2 id=&quot;введение&quot;&gt;Введение&lt;/h2&gt;
&lt;p&gt;Для начала я отвечу на вопрос «зачем этот пост?»&lt;/p&gt;

&lt;p&gt;Ну, во-первых, я уже давно обещал Виталию из Evrone написать хоть что-то в блог. Обещаного, как говорится, &lt;em&gt;лучше вообще не ждать, а то расстроишься&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;А во-вторых вот уже полтора года как я провожу собеседования на позицию &lt;em&gt;Señor NodeJS developer&lt;/em&gt;, при этом на момент первого собеседования я сам писал на NodeJS едва ли с полгода. И в качестве единственного (ну ладно, не единственного, но единственного технического) вопроса по git задаю именно этот.&lt;/p&gt;

&lt;p&gt;Почему именно его? Потому что ответ на этот вопрос сразу поведает мне о том, насколько глубоко кандидат копался в git. И ответов тут может быть несколько, от «я не знаю» до «а diff-то в git динамический!».&lt;/p&gt;

&lt;p&gt;После собеседования неплохо бы оставлять кандидатам обратную связь, но вот незадача — я &lt;del&gt;не смог&lt;/del&gt; &lt;a href=&quot;https://www.edwardthomson.com/blog/merge_vs_rebase.html&quot;&gt;через полчаса гугления смог!&lt;/a&gt; найти удовлетворяющую меня статью по этому вопросу. Надо бы это &lt;del&gt;исправить&lt;/del&gt; дополнить.&lt;/p&gt;

&lt;p&gt;Давайте попробуем разобраться в возможный ответах и дойдём до самого ультимативного&lt;/p&gt;

&lt;h2 id=&quot;неинтересные-варианты-ответов&quot;&gt;Неинтересные варианты ответов&lt;/h2&gt;

&lt;h3 id=&quot;я-не-знаю&quot;&gt;«Я не знаю»&lt;/h3&gt;
&lt;p&gt;Пожалуй, тут особо и нечего комментировать. Если рассказать по вопросу “в чём разница между git merge и git rebase” нечего, то нужно идти учить матчасть. Например прочитать вот эту статью.&lt;/p&gt;

&lt;h3 id=&quot;merge-соединяет-код-а-rebase-как-бы-его-поверх-делает&quot;&gt;«Merge соединяет код, а rebase как бы его поверх делает»&lt;/h3&gt;
&lt;p&gt;Если совсем вольно трактовать поведение git — да, можно считать это верным ответом, ведь, действительно, &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt; пытается “соединить” две ветки в одну за счёт создания merge-коммита, а &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt; &lt;strong&gt;применяет&lt;/strong&gt; коммиты одной ветки &lt;em&gt;поверх&lt;/em&gt; другой.&lt;/p&gt;

&lt;h3 id=&quot;rebase-изменяет-историю&quot;&gt;«Rebase изменяет историю»&lt;/h3&gt;
&lt;p&gt;Так-то да, но если вы противник изменения истории — используйте &lt;a href=&quot;https://en.wikipedia.org/wiki/Mercurial&quot;&gt;Mercurial&lt;/a&gt;. Да и без последующих комментариев это на вопрос не отвечает.&lt;/p&gt;

&lt;h3 id=&quot;merge-объединяет-код-сразу-а-rebase-по-одному-коммиту&quot;&gt;«Merge объединяет код сразу, а rebase по одному коммиту»&lt;/h3&gt;
&lt;p&gt;Это уже интереснее, хотя суть проблемы никак не выявляет. Действительно, при разрешении конфликтов git для &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt; вычисляет конфликты между &lt;strong&gt;последними состояними&lt;/strong&gt; (коммитами, если хотите) веток, а &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt; делает это &lt;strong&gt;для каждого коммита&lt;/strong&gt; (из ветки, которую мы rebase’им).&lt;/p&gt;

&lt;h2 id=&quot;diff-строится-по-разному-для-merge-и-rebase-merge-разрешает-все-конфликты-в-merge-коммите-а-rebase-разрешает-их-для-каждого-коммита&quot;&gt;«Diff строится по-разному для &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt; разрешает все конфликты в merge-коммите, а rebase разрешает их для каждого коммита»&lt;/h2&gt;
&lt;p&gt;А вот это уже гораздо ближе к &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D0%BA%D1%80%D0%B5%D1%82%D0%BD%D1%8B%D0%B5_%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D1%8B&quot;&gt;истине&lt;/a&gt;. Правда, есть &lt;em&gt;нюанс&lt;/em&gt; (&lt;em&gt;ahem, вы меня поняли&lt;/em&gt;), но про “&lt;em&gt;нюанс&lt;/em&gt;” я уточняю вопросом “а к чему это приводит”?&lt;/p&gt;

&lt;h3 id=&quot;а-к-чему-это-приводит&quot;&gt;«А к чему это приводит?»&lt;/h3&gt;

&lt;h4 id=&quot;к-различиям-в-git-blame&quot;&gt;«К различиям в git blame»&lt;/h4&gt;
&lt;p&gt;Итак, первый ответ на вопрос “А к чему это приводит”.&lt;/p&gt;

&lt;p&gt;Объяснение тут довольно простое (но не для всех очевидное): при наличии конфликтов — &lt;strong&gt;даже при их автоматическом разрешении&lt;/strong&gt; — само изменение, разрешающее конфликт будет относиться к merge-коммиту в случае &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt;, в то время как при &lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt; изменение, относящееся к разрешению конфликта будет относиться к тому коммиту, для которого разрешался конфликт.&lt;/p&gt;

&lt;p&gt;Для демонстрации сего на двухчасовом мероприятии я даже собрал &lt;a href=&quot;https://github.com/ivalentinee/git-workshop/blob/master/manual/INDEX.md&quot;&gt;небольшой репозиторий с примером&lt;/a&gt;. Если есть время, рекомендую ознакомиться.&lt;/p&gt;

&lt;p&gt;А так как я являюсь яростным сторонником &lt;strong&gt;git-blame-driven подхода&lt;/strong&gt;, то мне бы очень не хотелось по какому-то спорному изменению видеть в git blame имя коммита &lt;code class=&quot;highlighter-rouge&quot;&gt;Merge branch 'feature/fix-some-bug' into 'master'&lt;/code&gt;, а хотелось бы видеть непосредственно тот коммит, к которому логически это изменение относится.&lt;/p&gt;

&lt;p&gt;Кстати, это делает меня сторонником крайне спорного подхода: прежде, чем &lt;em&gt;мержить&lt;/em&gt; свою ветку в &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;, неплохо бы её отребейзить на тот же &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;, чтобы и получить логическое преимущество наличия merge-коммита и при этом не потерять корректный git blame.&lt;/p&gt;

&lt;h4 id=&quot;к-различиям-в-коде&quot;&gt;«К различиям в коде»&lt;/h4&gt;
&lt;p&gt;А вот тут самое интересное. Потому как остальные различия не относятся к результату &lt;em&gt;в коде&lt;/em&gt;, а только к истории.&lt;/p&gt;

&lt;p&gt;Можно что-то и поломать. Давайте посмотрим.&lt;br /&gt;
Я приведу полный листинг bash-команд без комментариев, а дальше вы уж как-нибудь сами разберётесь.&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Создаём репозиторий&lt;/span&gt;
git init &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Создаём первый коммит с единственным файлом&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;some string&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; file.txt
git add file.txt
git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Initial commit&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Создаём две ветки, в которых будем играться изменениями&lt;/span&gt;
git branch branch-1
git branch branch-2

&lt;span class=&quot;c&quot;&gt;# Изменяем единственную строку в ветке branch-1&lt;/span&gt;
git checkout branch-1
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;some string // changed&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; file.txt
git add file.txt
git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Changed line 2 on branch 1&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Изменяем единственную строку в ветке branch-2&lt;/span&gt;
git checkout branch-2
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;some string // changed&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; file.txt
git add file.txt
git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Changed line 2 on branch 2&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Откатываем единственную строку в файле branch-2&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;some string&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; file.txt
git add file.txt
git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Reverted line 2 on branch 2&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Создаём копию ветки для того, чтобы попробовать и merge и rebase&lt;/span&gt;
git branch branch-2-non-modified

&lt;span class=&quot;c&quot;&gt;# Делаем git merge&lt;/span&gt;
git merge &lt;span class=&quot;nt&quot;&gt;--no-edit&lt;/span&gt; branch-1
&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;file.txt
&lt;span class=&quot;c&quot;&gt;# Получаем some string // changed&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# Возвращаем branch-2 к до-merge-состоянию&lt;/span&gt;
git reset &lt;span class=&quot;nt&quot;&gt;--hard&lt;/span&gt; branch-2-non-modified

&lt;span class=&quot;c&quot;&gt;# Делаем git rebase&lt;/span&gt;
git rebase branch-1
&lt;span class=&quot;nb&quot;&gt;cat &lt;/span&gt;file.txt
&lt;span class=&quot;c&quot;&gt;# Получаем some string&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Интересно получилось? Вот и мне интересно. Особенно если кандидат про это расскажет (без листинга и подробностей, конечно) на собеседовании.&lt;/p&gt;

&lt;p&gt;Почему так происходит? Думайте, гуглите, дальше мне лень простыню писать. Особенно с учётом того, что при описании такого последствия кандидатом дальнейших объяснений не потребуется — и так понятно, что кандидат с git работал достаточно глубоко.&lt;/p&gt;</content><author><name></name></author><summary type="html">Введение Для начала я отвечу на вопрос «зачем этот пост?» Ну, во-первых, я уже давно обещал Виталию из Evrone написать хоть что-то в блог. Обещаного, как говорится, лучше вообще не ждать, а то расстроишься. А во-вторых вот уже полтора года как я провожу собеседования на позицию Señor NodeJS developer, при этом на момент первого собеседования я сам писал на NodeJS едва ли с полгода. И в качестве единственного (ну ладно, не единственного, но единственного технического) вопроса по git задаю именно этот. Почему именно его? Потому что ответ на этот вопрос сразу поведает мне о том, насколько глубоко кандидат копался в git. И ответов тут может быть несколько, от «я не знаю» до «а diff-то в git динамический!». После собеседования неплохо бы оставлять кандидатам обратную связь, но вот незадача — я не смог через полчаса гугления смог! найти удовлетворяющую меня статью по этому вопросу. Надо бы это исправить дополнить. Давайте попробуем разобраться в возможный ответах и дойдём до самого ультимативного Неинтересные варианты ответов «Я не знаю» Пожалуй, тут особо и нечего комментировать. Если рассказать по вопросу “в чём разница между git merge и git rebase” нечего, то нужно идти учить матчасть. Например прочитать вот эту статью. «Merge соединяет код, а rebase как бы его поверх делает» Если совсем вольно трактовать поведение git — да, можно считать это верным ответом, ведь, действительно, merge пытается “соединить” две ветки в одну за счёт создания merge-коммита, а rebase применяет коммиты одной ветки поверх другой. «Rebase изменяет историю» Так-то да, но если вы противник изменения истории — используйте Mercurial. Да и без последующих комментариев это на вопрос не отвечает. «Merge объединяет код сразу, а rebase по одному коммиту» Это уже интереснее, хотя суть проблемы никак не выявляет. Действительно, при разрешении конфликтов git для merge вычисляет конфликты между последними состояними (коммитами, если хотите) веток, а rebase делает это для каждого коммита (из ветки, которую мы rebase’им). «Diff строится по-разному для merge и rebase: merge разрешает все конфликты в merge-коммите, а rebase разрешает их для каждого коммита» А вот это уже гораздо ближе к истине. Правда, есть нюанс (ahem, вы меня поняли), но про “нюанс” я уточняю вопросом “а к чему это приводит”? «А к чему это приводит?» «К различиям в git blame» Итак, первый ответ на вопрос “А к чему это приводит”. Объяснение тут довольно простое (но не для всех очевидное): при наличии конфликтов — даже при их автоматическом разрешении — само изменение, разрешающее конфликт будет относиться к merge-коммиту в случае merge, в то время как при rebase изменение, относящееся к разрешению конфликта будет относиться к тому коммиту, для которого разрешался конфликт. Для демонстрации сего на двухчасовом мероприятии я даже собрал небольшой репозиторий с примером. Если есть время, рекомендую ознакомиться. А так как я являюсь яростным сторонником git-blame-driven подхода, то мне бы очень не хотелось по какому-то спорному изменению видеть в git blame имя коммита Merge branch 'feature/fix-some-bug' into 'master', а хотелось бы видеть непосредственно тот коммит, к которому логически это изменение относится. Кстати, это делает меня сторонником крайне спорного подхода: прежде, чем мержить свою ветку в master, неплохо бы её отребейзить на тот же master, чтобы и получить логическое преимущество наличия merge-коммита и при этом не потерять корректный git blame. «К различиям в коде» А вот тут самое интересное. Потому как остальные различия не относятся к результату в коде, а только к истории. Можно что-то и поломать. Давайте посмотрим. Я приведу полный листинг bash-команд без комментариев, а дальше вы уж как-нибудь сами разберётесь. # Создаём репозиторий git init . # Создаём первый коммит с единственным файлом echo &quot;some string&quot; &amp;gt; file.txt git add file.txt git commit -m &quot;Initial commit&quot; # Создаём две ветки, в которых будем играться изменениями git branch branch-1 git branch branch-2 # Изменяем единственную строку в ветке branch-1 git checkout branch-1 echo &quot;some string // changed&quot; &amp;gt; file.txt git add file.txt git commit -m &quot;Changed line 2 on branch 1&quot; # Изменяем единственную строку в ветке branch-2 git checkout branch-2 echo &quot;some string // changed&quot; &amp;gt; file.txt git add file.txt git commit -m &quot;Changed line 2 on branch 2&quot; # Откатываем единственную строку в файле branch-2 echo &quot;some string&quot; &amp;gt; file.txt git add file.txt git commit -m &quot;Reverted line 2 on branch 2&quot; # Создаём копию ветки для того, чтобы попробовать и merge и rebase git branch branch-2-non-modified # Делаем git merge git merge --no-edit branch-1 cat file.txt # Получаем some string // changed # Возвращаем branch-2 к до-merge-состоянию git reset --hard branch-2-non-modified # Делаем git rebase git rebase branch-1 cat file.txt # Получаем some string Интересно получилось? Вот и мне интересно. Особенно если кандидат про это расскажет (без листинга и подробностей, конечно) на собеседовании. Почему так происходит? Думайте, гуглите, дальше мне лень простыню писать. Особенно с учётом того, что при описании такого последствия кандидатом дальнейших объяснений не потребуется — и так понятно, что кандидат с git работал достаточно глубоко.</summary></entry><entry xml:lang="en"><title type="html">async/await exception handling</title><link href="https://ivalentinee.github.io/en/programming/2023/03/15/async-await-exception-handling.html" rel="alternate" type="text/html" title="async/await exception handling" /><published>2023-03-15T00:00:00+00:00</published><updated>2023-03-15T00:00:00+00:00</updated><id>https://ivalentinee.github.io/en/programming/2023/03/15/async-await-exception-handling</id><content type="html" xml:base="https://ivalentinee.github.io/en/programming/2023/03/15/async-await-exception-handling.html">&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;All of a sudden I started writing NodeJS code about a year ago. Didn’t want to, but there was no choice – code should cross-compile for both browser and server.&lt;/p&gt;

&lt;p&gt;It turned out that async/await in JS is a complicated topic for many. And if most problematic cases are highlighted by TypeScript, this situation is correct by both JS and TS, but the code fails when it should not.&lt;/p&gt;

&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;
&lt;p&gt;Problem happens when trying to catch errors in async functions.&lt;/p&gt;

&lt;h3 id=&quot;question&quot;&gt;Question&lt;/h3&gt;
&lt;p&gt;Two examples:&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// --- Example 1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;something&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;someOtherAsyncFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// --- Example 2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;something&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;someOtherAsyncFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Can you guess what’s wrong here?&lt;/p&gt;

&lt;p&gt;Even eslint marks example 1 code as incorrect. “Thank you eslint for that”.&lt;/p&gt;

&lt;h3 id=&quot;answer&quot;&gt;Answer&lt;/h3&gt;
&lt;p&gt;Now here’s some code which tells what’s wrong with example 2:&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Ultimate failure'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'The error was caught'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})();&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'The error was not caught'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;'The error was not caught'&lt;/code&gt; won’t be printed because the error is not caught in the second function.&lt;/p&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;
&lt;p&gt;To explain this I have to explain async/await a bit deeper (but not too much).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;Async/await&lt;/a&gt; is just a syntactic sugar for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;promises&lt;/a&gt; which on the other hand are just a syntactic sugar for callbacks. These two allows for asynchronous code to be written in “pseudo-synchronous” manner.&lt;/p&gt;

&lt;h4 id=&quot;async-functions&quot;&gt;Async functions&lt;/h4&gt;
&lt;p&gt;Marking function as &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; allows to use &lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt; in function definition.&lt;/p&gt;

&lt;p&gt;Aside from that, if async function returns non-promise, returned value is wrapped into a promise (with somethin like &lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.resolve(value)&lt;/code&gt;).&lt;br /&gt;
Example:&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;returnNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;returnNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Promise { 1 }&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And, finally, if async function throws an error that error is automatically wrapped into a promise too (with something like &lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.reject(exception)&lt;/code&gt;).&lt;br /&gt;
Example:&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Ultimate failure'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Promise { &amp;lt;rejected&amp;gt; Error: Ultimate failure }&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;await-and-promise-unwrapping&quot;&gt;Await and promise unwrapping&lt;/h4&gt;
&lt;p&gt;Await does promise unwrapping for other async-function returned values called with &lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;returnNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;returnNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And if returned promise is rejected that exception is rethrown (and then re-wrapped with &lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.reject&lt;/code&gt; if not catched with try-catch):&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Ultimate failure'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// console.log won't print anything, but 'Uncaught Error: Ultimate failure' will be displayed&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;whats-the-problem-and-how-to-solve-it&quot;&gt;What’s the problem and how to solve it?&lt;/h3&gt;
&lt;p&gt;So if the last (up the call stack) try-catch won’t have &lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt; when calling probably-exception-throwing-async-function promise will be returned as-is (rejected) and try-catch won’t get into &lt;code class=&quot;highlighter-rouge&quot;&gt;catch&lt;/code&gt; block. Successfully passing try-catch exception will then be fired by the system.&lt;/p&gt;

&lt;p&gt;And if unhandled exception in browser results in just a red line in dev-tools, server will have the entire NodeJS process down (well, if no wanky code like &lt;code class=&quot;highlighter-rouge&quot;&gt;process.on('uncaughtException', (error: Error) =&amp;gt; { /* ... */ });&lt;/code&gt; will be used) and if lucky will just be restarted (losing all the data).&lt;/p&gt;

&lt;p&gt;How to avoid that? Try to return all async function results through &lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt; in try-catch blocks even if it looks unnecessary:&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And call async function with &lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt; even if these functions do not return any actual value (&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&amp;lt;void&amp;gt;&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Yes, excessive promise wrapping/unwrapping will cause more event loop cycles to pass results, but that tiny overhead will stabilize the system at code level significantly.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;It turned out, problematic code is usually written by developers that have almost no experience with NodeJS – those who write code for browser or write so little code that such async-related problems never occur.&lt;/p&gt;

&lt;p&gt;Now I use this question (async/await with exceptions) on interviews to find out if candidate actually used NodeJS or just played with it.&lt;/p&gt;</content><author><name></name></author><summary type="html">Intro All of a sudden I started writing NodeJS code about a year ago. Didn’t want to, but there was no choice – code should cross-compile for both browser and server. It turned out that async/await in JS is a complicated topic for many. And if most problematic cases are highlighted by TypeScript, this situation is correct by both JS and TS, but the code fails when it should not. Problem Problem happens when trying to catch errors in async functions. Question Two examples: // --- Example 1 async function something() { // ... return await someOtherAsyncFunction(); // ... // --- Example 2 async function something() { // ... return someOtherAsyncFunction(); // ... Can you guess what’s wrong here? Even eslint marks example 1 code as incorrect. “Thank you eslint for that”. Answer Now here’s some code which tells what’s wrong with example 2: async function fail() { throw new Error('Ultimate failure'); } await (async () =&amp;gt; { try { return await fail(); } catch (error) { console.log('The error was caught'); } })(); await (async () =&amp;gt; { try { return fail(); } catch (error) { console.log('The error was not caught'); } })(); 'The error was not caught' won’t be printed because the error is not caught in the second function. Explanation To explain this I have to explain async/await a bit deeper (but not too much). Async/await is just a syntactic sugar for promises which on the other hand are just a syntactic sugar for callbacks. These two allows for asynchronous code to be written in “pseudo-synchronous” manner. Async functions Marking function as async allows to use await in function definition. Aside from that, if async function returns non-promise, returned value is wrapped into a promise (with somethin like Promise.resolve(value)). Example: async function returnNumber() { return 1; } console.log(returnNumber()); // Promise { 1 } And, finally, if async function throws an error that error is automatically wrapped into a promise too (with something like Promise.reject(exception)). Example: async function fail() { throw new Error('Ultimate failure'); } console.log(fail()); // Promise { &amp;lt;rejected&amp;gt; Error: Ultimate failure } Await and promise unwrapping Await does promise unwrapping for other async-function returned values called with await: async function returnNumber() { return 1; } console.log(await returnNumber()); // 1 And if returned promise is rejected that exception is rethrown (and then re-wrapped with Promise.reject if not catched with try-catch): async function fail() { throw new Error('Ultimate failure'); } console.log(await fail()); // console.log won't print anything, but 'Uncaught Error: Ultimate failure' will be displayed What’s the problem and how to solve it? So if the last (up the call stack) try-catch won’t have await when calling probably-exception-throwing-async-function promise will be returned as-is (rejected) and try-catch won’t get into catch block. Successfully passing try-catch exception will then be fired by the system. And if unhandled exception in browser results in just a red line in dev-tools, server will have the entire NodeJS process down (well, if no wanky code like process.on('uncaughtException', (error: Error) =&amp;gt; { /* ... */ }); will be used) and if lucky will just be restarted (losing all the data). How to avoid that? Try to return all async function results through await in try-catch blocks even if it looks unnecessary: try { const result = await fail(); return result; } catch (error) { logger.log(error); return undefined; } And call async function with await even if these functions do not return any actual value (Promise&amp;lt;void&amp;gt;): await fail(); Yes, excessive promise wrapping/unwrapping will cause more event loop cycles to pass results, but that tiny overhead will stabilize the system at code level significantly. Conclusion It turned out, problematic code is usually written by developers that have almost no experience with NodeJS – those who write code for browser or write so little code that such async-related problems never occur. Now I use this question (async/await with exceptions) on interviews to find out if candidate actually used NodeJS or just played with it.</summary></entry><entry xml:lang="ru"><title type="html">Обработка ошибок в async/await</title><link href="https://ivalentinee.github.io/ru/programming/2023/03/15/async-await-exception-handling.html" rel="alternate" type="text/html" title="Обработка ошибок в async/await" /><published>2023-03-15T00:00:00+00:00</published><updated>2023-03-15T00:00:00+00:00</updated><id>https://ivalentinee.github.io/ru/programming/2023/03/15/async-await-exception-handling</id><content type="html" xml:base="https://ivalentinee.github.io/ru/programming/2023/03/15/async-await-exception-handling.html">&lt;h2 id=&quot;введение&quot;&gt;Введение&lt;/h2&gt;
&lt;p&gt;Совершенно внезапно для себя около года назад я начал писать на NodeJS. Не очень хотелось, но выбор был небольшой — нужна кросс-сборка приложения и в браузер и на сервер.&lt;/p&gt;

&lt;p&gt;Оказалось, что для многих концепция async/await в JS — сложная тема. И, если в большинстве случаев TypeScript не даст совершить ошибку при работе с async/await, то в этой ситуации код получается корректный (с точки зрения синтаксиса и проверки типов), а программа работает не так, как задумывалось.&lt;/p&gt;

&lt;h2 id=&quot;проблема&quot;&gt;Проблема&lt;/h2&gt;
&lt;p&gt;Проблема возникает при отлове ошибки в async-функциях.&lt;/p&gt;

&lt;h3 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h3&gt;
&lt;p&gt;Приведу два примера:&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// --- Пример 1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;something&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;someOtherAsyncFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// --- Пример 2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;something&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;someOtherAsyncFunction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Можете попробовать угадать, что не так с этим кодом?&lt;/p&gt;

&lt;p&gt;Даже eslint помечает код в примере 1 как некорректный, за что eslint отдельное “спасибо”.&lt;/p&gt;

&lt;h3 id=&quot;ответ&quot;&gt;Ответ&lt;/h3&gt;
&lt;p&gt;Теперь приведу код, запустив который будет понятно, что не так со вторым примером:&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Ultimate failure'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'The error was caught'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})();&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'The error was not caught'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Как следует из кода выше, &lt;code class=&quot;highlighter-rouge&quot;&gt;'The error was not caught'&lt;/code&gt; не будет выведен, потому что во втором случае ошибка не будет поймана.&lt;/p&gt;

&lt;h3 id=&quot;объяснение&quot;&gt;Объяснение&lt;/h3&gt;
&lt;p&gt;Чтобы понять, почему так происходит, нужно немного копнуть вглубь async/await (но не слишком).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;Async/await&lt;/a&gt; — всего лишь обёртка над &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;промисами&lt;/a&gt;, которые в свою очередь являются всего лишь обёрткой над колбеками. Сумма этих двух обёрток позволяет писать асинхронный (с колбеками) код в превдо-синхронном стиле (без колбеков).&lt;/p&gt;

&lt;h4 id=&quot;async-функции&quot;&gt;Async-функции&lt;/h4&gt;
&lt;p&gt;Объявление функции с &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; позволяет в теле функции использовать &lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Кроме этого, если результатом async-функции является не промис, async-функция автоматически заворачивает значение в промис (что-то вроде &lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.resolve(value)&lt;/code&gt;).&lt;br /&gt;
Пример:&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;returnNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;returnNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Promise { 1 }&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;И, наконец, если в теле async-функции происходит выбрасывание исключения, это исключение тоже автоматически заворачивается в промис (что-то вроде &lt;code class=&quot;highlighter-rouge&quot;&gt;Promise.reject(exception)&lt;/code&gt;).&lt;br /&gt;
Пример:&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Ultimate failure'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Promise { &amp;lt;rejected&amp;gt; Error: Ultimate failure }&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;await-и-разворачивание-промисов&quot;&gt;Await и разворачивание промисов&lt;/h4&gt;
&lt;p&gt;Await-же занимается разворачиванием промисов, возвращённых из той функции, которая вызывалась с ключевым словом &lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;returnNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;returnNumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;И, если вернулся промис с &lt;code class=&quot;highlighter-rouge&quot;&gt;reject&lt;/code&gt;‘ом, ошибка из этого промиса заново бросается (и затем заново возвращается через Promise.reject, если не будет поймана в try-catch):&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Ultimate failure'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// console.log ничего не выведет, будет только 'Uncaught Error: Ultimate failure'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;кто-виноват-и-что-делать&quot;&gt;«Кто виноват?» и «Что делать?»&lt;/h3&gt;
&lt;p&gt;В результате, если в последнем try-catch (вверх по стеку) не написать await перед потенциально-выбрасывающей-исключение-функцией, промис (с &lt;code class=&quot;highlighter-rouge&quot;&gt;reject&lt;/code&gt;-ом) отправится как есть и блок try-catch не перейдёт в секцию catch. В таком случае исключение вместо обработки будет выброшено.&lt;/p&gt;

&lt;p&gt;И если в браузере выбрашенное исключение приведёт только к красной строчке в инспекторе, то в случае сервера весь процесс ляжет (если не пользоваться совсем неприличными способами вроде &lt;code class=&quot;highlighter-rouge&quot;&gt;process.on('uncaughtException', (error: Error) =&amp;gt; { /* ... */ });&lt;/code&gt;) и в лучшем случае будет автоматически перезапущен (потеряв все данные).&lt;/p&gt;

&lt;p&gt;Что делать? Стараться возвращать результаты асинхронных функций через &lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt; даже тогда, когда это кажется нелогичным внутри try-catch-блоков:&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;И всегда вызывать асинхронные функции через await — даже если те возвращают пустой промис (&lt;code class=&quot;highlighter-rouge&quot;&gt;Promise&amp;lt;void&amp;gt;&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Понятно, что на разворачивание/заворачивание промисов в таком случае будет тратиться как минимум один лишний цикл event loop, но ценой микроскопического оверхеда можно сильно стабилизировать систему на уровне подхода к коду.&lt;/p&gt;

&lt;h2 id=&quot;заключение&quot;&gt;Заключение&lt;/h2&gt;
&lt;p&gt;Как оказалось, ввиду малых последствий проблемный код пишут в основном те, кто не работал по-настоящему с NodeJS и встречались с JS только в браузере или очень небольшими кусками в NodeJS (без массового использования async/await).&lt;/p&gt;

&lt;p&gt;С тех пор как я осознал это, я использую вопрос про обработку ошибок и async/await на собеседованиях, что позволяет сразу понять: пользовался соискатель NodeJS по-настоящему или нет.&lt;/p&gt;</content><author><name></name></author><summary type="html">Введение Совершенно внезапно для себя около года назад я начал писать на NodeJS. Не очень хотелось, но выбор был небольшой — нужна кросс-сборка приложения и в браузер и на сервер. Оказалось, что для многих концепция async/await в JS — сложная тема. И, если в большинстве случаев TypeScript не даст совершить ошибку при работе с async/await, то в этой ситуации код получается корректный (с точки зрения синтаксиса и проверки типов), а программа работает не так, как задумывалось. Проблема Проблема возникает при отлове ошибки в async-функциях. Вопрос Приведу два примера: // --- Пример 1 async function something() { // ... return await someOtherAsyncFunction(); // ... // --- Пример 2 async function something() { // ... return someOtherAsyncFunction(); // ... Можете попробовать угадать, что не так с этим кодом? Даже eslint помечает код в примере 1 как некорректный, за что eslint отдельное “спасибо”. Ответ Теперь приведу код, запустив который будет понятно, что не так со вторым примером: async function fail() { throw new Error('Ultimate failure'); } await (async () =&amp;gt; { try { return await fail(); } catch (error) { console.log('The error was caught'); } })(); await (async () =&amp;gt; { try { return fail(); } catch (error) { console.log('The error was not caught'); } })(); Как следует из кода выше, 'The error was not caught' не будет выведен, потому что во втором случае ошибка не будет поймана. Объяснение Чтобы понять, почему так происходит, нужно немного копнуть вглубь async/await (но не слишком). Async/await — всего лишь обёртка над промисами, которые в свою очередь являются всего лишь обёрткой над колбеками. Сумма этих двух обёрток позволяет писать асинхронный (с колбеками) код в превдо-синхронном стиле (без колбеков). Async-функции Объявление функции с async позволяет в теле функции использовать await. Кроме этого, если результатом async-функции является не промис, async-функция автоматически заворачивает значение в промис (что-то вроде Promise.resolve(value)). Пример: async function returnNumber() { return 1; } console.log(returnNumber()); // Promise { 1 } И, наконец, если в теле async-функции происходит выбрасывание исключения, это исключение тоже автоматически заворачивается в промис (что-то вроде Promise.reject(exception)). Пример: async function fail() { throw new Error('Ultimate failure'); } console.log(fail()); // Promise { &amp;lt;rejected&amp;gt; Error: Ultimate failure } Await и разворачивание промисов Await-же занимается разворачиванием промисов, возвращённых из той функции, которая вызывалась с ключевым словом await: async function returnNumber() { return 1; } console.log(await returnNumber()); // 1 И, если вернулся промис с reject‘ом, ошибка из этого промиса заново бросается (и затем заново возвращается через Promise.reject, если не будет поймана в try-catch): async function fail() { throw new Error('Ultimate failure'); } console.log(await fail()); // console.log ничего не выведет, будет только 'Uncaught Error: Ultimate failure' «Кто виноват?» и «Что делать?» В результате, если в последнем try-catch (вверх по стеку) не написать await перед потенциально-выбрасывающей-исключение-функцией, промис (с reject-ом) отправится как есть и блок try-catch не перейдёт в секцию catch. В таком случае исключение вместо обработки будет выброшено. И если в браузере выбрашенное исключение приведёт только к красной строчке в инспекторе, то в случае сервера весь процесс ляжет (если не пользоваться совсем неприличными способами вроде process.on('uncaughtException', (error: Error) =&amp;gt; { /* ... */ });) и в лучшем случае будет автоматически перезапущен (потеряв все данные). Что делать? Стараться возвращать результаты асинхронных функций через await даже тогда, когда это кажется нелогичным внутри try-catch-блоков: try { const result = await fail(); return result; } catch (error) { logger.log(error); return undefined; } И всегда вызывать асинхронные функции через await — даже если те возвращают пустой промис (Promise&amp;lt;void&amp;gt;): await fail(); Понятно, что на разворачивание/заворачивание промисов в таком случае будет тратиться как минимум один лишний цикл event loop, но ценой микроскопического оверхеда можно сильно стабилизировать систему на уровне подхода к коду. Заключение Как оказалось, ввиду малых последствий проблемный код пишут в основном те, кто не работал по-настоящему с NodeJS и встречались с JS только в браузере или очень небольшими кусками в NodeJS (без массового использования async/await). С тех пор как я осознал это, я использую вопрос про обработку ошибок и async/await на собеседованиях, что позволяет сразу понять: пользовался соискатель NodeJS по-настоящему или нет.</summary></entry><entry xml:lang="en"><title type="html">Pipelining graph execution</title><link href="https://ivalentinee.github.io/en/programming/2022/09/27/pipelining-graph-execution.html" rel="alternate" type="text/html" title="Pipelining graph execution" /><published>2022-09-27T00:00:00+00:00</published><updated>2022-09-27T00:00:00+00:00</updated><id>https://ivalentinee.github.io/en/programming/2022/09/27/pipelining-graph-execution</id><content type="html" xml:base="https://ivalentinee.github.io/en/programming/2022/09/27/pipelining-graph-execution.html">&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;There’re two things I need to describe before describing actual solution.&lt;/p&gt;

&lt;h3 id=&quot;why-graphs-and-optimization-criteria-are-like-this&quot;&gt;Why graphs and optimization criteria are like this&lt;/h3&gt;
&lt;p&gt;Because that’s a solution that I wanted to suggest at work (for a well-described problem), but the solution will probably be rejected. So the problem is not very abstract.&lt;/p&gt;

&lt;h3 id=&quot;why-dont-i-refer-to-other-solutions&quot;&gt;Why don’t I refer to other solutions&lt;/h3&gt;
&lt;p&gt;The problem at hand is very specific, and, despite it being (as I believe) very common for some systems (say, optimizations for compilers), finding any solutions will take a lot of time (and a lot of reading). I have just one week, and I’m not an expert on optimizing program execution.&lt;/p&gt;

&lt;p&gt;Also, as my solution won’t actually be used anywhere, why not to try to invent a wheel just to do a mental exercise?&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The problem&lt;/h2&gt;
&lt;p&gt;Can be described as “execution graph pipelining and optimization”, but that’s just the tip of the iceberg.&lt;/p&gt;

&lt;h3 id=&quot;what-graphs-are&quot;&gt;What graphs are&lt;/h3&gt;
&lt;p&gt;Graphs to be discussed are what I call “execution graphs”.&lt;/p&gt;

&lt;p&gt;These graphs follow these rules:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Graphs are not planar.&lt;/li&gt;
  &lt;li&gt;Edges are directional&lt;/li&gt;
  &lt;li&gt;There’s only one output (final result) node, but there’re many input nodes.
&lt;img src=&quot;/assets/img/posts/2022-09-27-pipelining-graph-execution/example-default.png&quot; alt=&quot;Sample graph&quot; width=&quot;300&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Every possible path can only contain one reference to each node in that path. i.e. there’re no cyclic dependencies. Thus &lt;a href=&quot;https://en.wikipedia.org/wiki/Control-flow_graph&quot;&gt;CFG&lt;/a&gt;-based solutions are not relevant – there’re no “control” nodes.
&lt;img src=&quot;/assets/img/posts/2022-09-27-pipelining-graph-execution/example-path.png&quot; alt=&quot;Sample graph with path&quot; width=&quot;300&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;Every node (except input nodes and output node) can have multiple inputs and multiple outputs.
That makes it a bit different from common &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;AST&lt;/a&gt;, because those have only one output per node.&lt;/li&gt;
  &lt;li&gt;(This one is obvious, but) no node can start execution before all of it’s dependencies (node inputs) are resolved.&lt;/li&gt;
  &lt;li&gt;Every node returns all values at once, so, once node finished executing – all it’s outputs are available.&lt;/li&gt;
  &lt;li&gt;There’re “external nodes” (E-nodes), that could not be executed within the system. For example, filesystem reads or external execution systems.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;some-specifics&quot;&gt;Some specifics&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Nodes operate on “reasonably” large chunks of data: ~100mb each, which makes passing them through like plain values (say, uint32 numbers) not an option and these chunks should be stored in (pre)allocated buffers.&lt;/li&gt;
  &lt;li&gt;All chunks of data are of the same size (or could be easily padded to be)&lt;/li&gt;
  &lt;li&gt;Each node internal memory and computation consumption is not considered.&lt;/li&gt;
  &lt;li&gt;It’s rare that some graph contains more than 50 nodes, with potential cap at 100 nodes. For now.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;what-im-trying-to-achieve&quot;&gt;What I’m trying to achieve&lt;/h3&gt;
&lt;p&gt;There’re multiple goals, described in order of importance&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Grouped E-node execution, so that context switching (between internal and external execution) is minimized.&lt;/li&gt;
  &lt;li&gt;Static execution. No dynamic allocations, no dynamic execution. Strong execution plan and exact amount of memory preallocated.&lt;/li&gt;
  &lt;li&gt;Memory optimization. Do not allocate memory for every node result, but only those required for next node(s) execution.&lt;/li&gt;
  &lt;li&gt;Potentially parallelization. If some (sub)paths have the same &lt;em&gt;input&lt;/em&gt; or &lt;em&gt;external&lt;/em&gt; dependencies, but no interconnections, execute these subpaths concurrently.&lt;/li&gt;
  &lt;li&gt;Potentially E-node result caching if these are considered expensive.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There’s one thing to have in mind: compilation time and memory consumption is not pretty critical, because such compilation will be performed way less often than graph execution.&lt;/p&gt;

&lt;h2 id=&quot;the-solution&quot;&gt;The solution&lt;/h2&gt;
&lt;h3 id=&quot;grouping-e-nodes-and-internal-nodes-i-nodes&quot;&gt;Grouping E-nodes and internal nodes (I-nodes)&lt;/h3&gt;
&lt;p&gt;The simplest solution to the problem of static execution is graph linearization, because there’re too many algorythms designed for 1-dimensional structures (lists). But, without further analysis it could not be executed concurrently.&lt;/p&gt;

&lt;p&gt;Primitive linearization could be achieved by simply ordering nodes by dependencies like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;If node A depends on node B, node A should be placed after node B (A depends on B -&amp;gt; A &amp;gt; B).
If node B depends on node A, node B should be placed after node A (B depends on A -&amp;gt; B &amp;gt; A).
If neither node A nor node B depend on one another they are considered equal order-wise (A ⊥ B -&amp;gt; A == B).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;By definition they could not depend on each other, so the rule above will ensure any node is executed after it’s dependencies.&lt;/p&gt;

&lt;p&gt;That condition could be further expanded to group E-nodes:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;If node A depends on node B, node A should be placed after node B (A depends on B -&amp;gt; A &amp;gt; B).
If node B depends on node A, node B should be placed after node A (B depends on A -&amp;gt; B &amp;gt; A).
If node A is an internal node and B is an E-node, node A should be placed after node B (A: E-node, B: I-node -&amp;gt; A &amp;gt; B).
If node B is an internal node and A is an E-node, node B should be placed after node A (B: E-node, A: I-node -&amp;gt; B &amp;gt; A).
If neither node A nor node B depend on one another and have the same type they are considered equal order-wise (A ⊥ B -&amp;gt; A == B).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Since input nodes are not fully “executed” (they only contain input values), they could be excluded from that ordering and put in any order at the beginning of the list.&lt;/p&gt;

&lt;p&gt;Since E-nodes are grouped, it makes sense to build plans for each internal-node block.&lt;/p&gt;

&lt;p&gt;So, top-level plan will contain alternating blocks of internal nodes (I-blocks) and E-nodes (E-blocks).&lt;/p&gt;

&lt;h3 id=&quot;naive-planning-and-memory-management&quot;&gt;Naive planning and memory management&lt;/h3&gt;
&lt;p&gt;Obviously, memory management only should be done for I-blocks.&lt;/p&gt;

&lt;p&gt;At the beginning of every internal-node block data should be “imported” into memory from either some initial data or I-block results (which are stored), then, at the end of I-block, it should be exported from memory to storage (making it possible to either output final result or execute E-nodes).&lt;/p&gt;

&lt;p&gt;For naive case we assume, that every operation is non-destructive – does not change data in input buffers.&lt;/p&gt;

&lt;p&gt;Then, simplest method of getting some preallocated memory and strong plan would be to use dynamic “dry run” with these rules:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Buffers will be managed by using “dynamic” pool to which we can add, but not remove. Initially it’s empty.&lt;/li&gt;
  &lt;li&gt;Buffers containing data should be marked with node and output name the data came from. Empty buffers will be marked as “empty”.&lt;/li&gt;
  &lt;li&gt;Every input node will put data into a new buffer (thus, +1 buffer per input node).&lt;/li&gt;
  &lt;li&gt;The system will need to provide a buffer per each requested output for every node when executing that node (getting requested outputs is pretty simple – won’t describe it here). If there’re free buffers – these buffers should be used, otherwise a new buffer should be added to the pool.&lt;/li&gt;
  &lt;li&gt;Every time buffer is not used as an input in non-finished I-block node it’s considered “free” and should be emptied – either by just marking it as free, or by explicitly running nullifying procedure on that buffer. Such check should be executed after each node execution.&lt;/li&gt;
  &lt;li&gt;When all nodes are finished – nonempty buffers should be “exported” to storage as I-block result.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When building the final plan, all allocations should be moved to the beginning.&lt;/p&gt;

&lt;p&gt;So, a simple set of commands could be used:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Allocate buffer (id: $buffer_id)&lt;/code&gt; (or &lt;code class=&quot;highlighter-rouge&quot;&gt;Allocate buffers&lt;/code&gt; if that is possible)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Import (from: $node_id, output_name: $output_name, to: $buffer_id)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Run node (inputs: {$input_name: $buffer_id, ...}, outputs: {$output_name: $buffer_id, ...})&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Free buffer (buffer: $buffer_id)&lt;/code&gt;, which will do nothing if all node implementations fully rewrite buffer content&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Export (from: $buffer_id, node_id: $node_id, output_name: $output_name)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Where all &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; marked values will be inlined by the compiler when performing dry run.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/posts/2022-09-27-pipelining-graph-execution/example-naive-run.gif&quot; alt=&quot;Naive dry run example&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Resulting plan for that graph will look like this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Allocate buffers | {&quot;count&quot;: 5}
Import node data | {&quot;node&quot;: &quot;1&quot;, &quot;output_name&quot;: &quot;data&quot;, &quot;to&quot;: 0}
Import node data | {&quot;node&quot;: &quot;2&quot;, &quot;output_name&quot;: &quot;data&quot;, &quot;to&quot;: 1}
Import node data | {&quot;node&quot;: &quot;3&quot;, &quot;output_name&quot;: &quot;data&quot;, &quot;to&quot;: 2}
Run node         | {&quot;node&quot;: &quot;4&quot;, &quot;input&quot;: {&quot;data&quot;: 0}, &quot;output&quot;: {&quot;another data&quot;: 3, &quot;data&quot;: 4}}
Free buffer      | {&quot;id&quot;: 0}
Run node         | {&quot;node&quot;: &quot;5&quot;, &quot;input&quot;: {&quot;data 1&quot;: 1, &quot;data 2&quot;: 2}, &quot;output&quot;: {&quot;data&quot;: 0}}
Free buffer      | {&quot;id&quot;: 1}
Free buffer      | {&quot;id&quot;: 2}
Run node         | {&quot;node&quot;: &quot;6&quot;, &quot;input&quot;: {&quot;data&quot;: 4}, &quot;output&quot;: {&quot;data&quot;: 1}}
Free buffer      | {&quot;id&quot;: 4}
Run node         | {&quot;node&quot;: &quot;7&quot;, &quot;input&quot;: {&quot;data&quot;: 3}, &quot;output&quot;: {&quot;data&quot;: 2}}
Free buffer      | {&quot;id&quot;: 3}
Run node         | {&quot;node&quot;: &quot;8&quot;, &quot;input&quot;: {&quot;data&quot;: 0}, &quot;output&quot;: {&quot;data&quot;: 3}}
Free buffer      | {&quot;id&quot;: 0}
Run node         | {&quot;node&quot;: &quot;9&quot;, &quot;input&quot;: {&quot;data&quot;: 1}, &quot;output&quot;: {&quot;data&quot;: 0}}
Free buffer      | {&quot;id&quot;: 1}
Run node         | {&quot;node&quot;: &quot;10&quot;, &quot;input&quot;: {&quot;data 1&quot;: 2, &quot;data 2&quot;: 3}, &quot;output&quot;: {&quot;data&quot;: 1}}
Free buffer      | {&quot;id&quot;: 2}
Free buffer      | {&quot;id&quot;: 3}
Run node         | {&quot;node&quot;: &quot;11&quot;, &quot;input&quot;: {&quot;data 1&quot;: 0, &quot;data 2&quot;: 1}, &quot;output&quot;: {&quot;data&quot;: 2}}
Export node data | {&quot;from&quot;: 2, &quot;node&quot;: &quot;11&quot;, &quot;output_name&quot;: &quot;data&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As you can see, it’s a bit unoptimal: there’s no need to free buffers at the end of execution, potentially too many buffers allocated, but that’s why it’s called “naive”: it does the thing the simplest way possible.&lt;/p&gt;

&lt;h3 id=&quot;real-planning-and-memory-management&quot;&gt;&lt;strong&gt;Real&lt;/strong&gt; planning and memory management&lt;/h3&gt;
&lt;p&gt;Now, that’s really complicated.&lt;/p&gt;

&lt;p&gt;Each node can have multiple inputs and multiple outputs. Not only that, node behaviour per-input and per-output might be different depending on the implementation:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Destructively put output to one of input buffers thus losing all the original data stored in input buffer. Generating such output does not require additional “output” buffer.&lt;/li&gt;
  &lt;li&gt;Non-destructively put output to a new buffer. While original values are not overritten and could be used in another node, this will require additional buffer for that output.&lt;/li&gt;
  &lt;li&gt;Both situations depending on requested outputs for a single node.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The exact behaviour should then be described in node spec.&lt;/p&gt;

&lt;p&gt;That makes things messed up, because if, for example, there’re two nodes using some output destructively, the system should make a copy of an output to another buffer. If, on the other hand, no nodes use some output destructively, after all non-destructive nodes using the output are done, that output buffer should be reused.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;For now I do not have enough time to come up with appropriate solution, please use the “naive” one that does not support destructive nodes.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;tbd&quot;&gt;TBD&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Do something on parallelization&lt;/li&gt;
  &lt;li&gt;Support finite non-conditional (enumerated) loops.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Introduction There’re two things I need to describe before describing actual solution. Why graphs and optimization criteria are like this Because that’s a solution that I wanted to suggest at work (for a well-described problem), but the solution will probably be rejected. So the problem is not very abstract. Why don’t I refer to other solutions The problem at hand is very specific, and, despite it being (as I believe) very common for some systems (say, optimizations for compilers), finding any solutions will take a lot of time (and a lot of reading). I have just one week, and I’m not an expert on optimizing program execution. Also, as my solution won’t actually be used anywhere, why not to try to invent a wheel just to do a mental exercise? The problem Can be described as “execution graph pipelining and optimization”, but that’s just the tip of the iceberg. What graphs are Graphs to be discussed are what I call “execution graphs”. These graphs follow these rules: Graphs are not planar. Edges are directional There’s only one output (final result) node, but there’re many input nodes. Every possible path can only contain one reference to each node in that path. i.e. there’re no cyclic dependencies. Thus CFG-based solutions are not relevant – there’re no “control” nodes. Every node (except input nodes and output node) can have multiple inputs and multiple outputs. That makes it a bit different from common AST, because those have only one output per node. (This one is obvious, but) no node can start execution before all of it’s dependencies (node inputs) are resolved. Every node returns all values at once, so, once node finished executing – all it’s outputs are available. There’re “external nodes” (E-nodes), that could not be executed within the system. For example, filesystem reads or external execution systems. Some specifics Nodes operate on “reasonably” large chunks of data: ~100mb each, which makes passing them through like plain values (say, uint32 numbers) not an option and these chunks should be stored in (pre)allocated buffers. All chunks of data are of the same size (or could be easily padded to be) Each node internal memory and computation consumption is not considered. It’s rare that some graph contains more than 50 nodes, with potential cap at 100 nodes. For now. What I’m trying to achieve There’re multiple goals, described in order of importance Grouped E-node execution, so that context switching (between internal and external execution) is minimized. Static execution. No dynamic allocations, no dynamic execution. Strong execution plan and exact amount of memory preallocated. Memory optimization. Do not allocate memory for every node result, but only those required for next node(s) execution. Potentially parallelization. If some (sub)paths have the same input or external dependencies, but no interconnections, execute these subpaths concurrently. Potentially E-node result caching if these are considered expensive. There’s one thing to have in mind: compilation time and memory consumption is not pretty critical, because such compilation will be performed way less often than graph execution. The solution Grouping E-nodes and internal nodes (I-nodes) The simplest solution to the problem of static execution is graph linearization, because there’re too many algorythms designed for 1-dimensional structures (lists). But, without further analysis it could not be executed concurrently. Primitive linearization could be achieved by simply ordering nodes by dependencies like this: If node A depends on node B, node A should be placed after node B (A depends on B -&amp;gt; A &amp;gt; B). If node B depends on node A, node B should be placed after node A (B depends on A -&amp;gt; B &amp;gt; A). If neither node A nor node B depend on one another they are considered equal order-wise (A ⊥ B -&amp;gt; A == B). By definition they could not depend on each other, so the rule above will ensure any node is executed after it’s dependencies. That condition could be further expanded to group E-nodes: If node A depends on node B, node A should be placed after node B (A depends on B -&amp;gt; A &amp;gt; B). If node B depends on node A, node B should be placed after node A (B depends on A -&amp;gt; B &amp;gt; A). If node A is an internal node and B is an E-node, node A should be placed after node B (A: E-node, B: I-node -&amp;gt; A &amp;gt; B). If node B is an internal node and A is an E-node, node B should be placed after node A (B: E-node, A: I-node -&amp;gt; B &amp;gt; A). If neither node A nor node B depend on one another and have the same type they are considered equal order-wise (A ⊥ B -&amp;gt; A == B). Since input nodes are not fully “executed” (they only contain input values), they could be excluded from that ordering and put in any order at the beginning of the list. Since E-nodes are grouped, it makes sense to build plans for each internal-node block. So, top-level plan will contain alternating blocks of internal nodes (I-blocks) and E-nodes (E-blocks). Naive planning and memory management Obviously, memory management only should be done for I-blocks. At the beginning of every internal-node block data should be “imported” into memory from either some initial data or I-block results (which are stored), then, at the end of I-block, it should be exported from memory to storage (making it possible to either output final result or execute E-nodes). For naive case we assume, that every operation is non-destructive – does not change data in input buffers. Then, simplest method of getting some preallocated memory and strong plan would be to use dynamic “dry run” with these rules: Buffers will be managed by using “dynamic” pool to which we can add, but not remove. Initially it’s empty. Buffers containing data should be marked with node and output name the data came from. Empty buffers will be marked as “empty”. Every input node will put data into a new buffer (thus, +1 buffer per input node). The system will need to provide a buffer per each requested output for every node when executing that node (getting requested outputs is pretty simple – won’t describe it here). If there’re free buffers – these buffers should be used, otherwise a new buffer should be added to the pool. Every time buffer is not used as an input in non-finished I-block node it’s considered “free” and should be emptied – either by just marking it as free, or by explicitly running nullifying procedure on that buffer. Such check should be executed after each node execution. When all nodes are finished – nonempty buffers should be “exported” to storage as I-block result. When building the final plan, all allocations should be moved to the beginning. So, a simple set of commands could be used: Allocate buffer (id: $buffer_id) (or Allocate buffers if that is possible) Import (from: $node_id, output_name: $output_name, to: $buffer_id) Run node (inputs: {$input_name: $buffer_id, ...}, outputs: {$output_name: $buffer_id, ...}) Free buffer (buffer: $buffer_id), which will do nothing if all node implementations fully rewrite buffer content Export (from: $buffer_id, node_id: $node_id, output_name: $output_name) Where all $ marked values will be inlined by the compiler when performing dry run. Resulting plan for that graph will look like this: Allocate buffers | {&quot;count&quot;: 5} Import node data | {&quot;node&quot;: &quot;1&quot;, &quot;output_name&quot;: &quot;data&quot;, &quot;to&quot;: 0} Import node data | {&quot;node&quot;: &quot;2&quot;, &quot;output_name&quot;: &quot;data&quot;, &quot;to&quot;: 1} Import node data | {&quot;node&quot;: &quot;3&quot;, &quot;output_name&quot;: &quot;data&quot;, &quot;to&quot;: 2} Run node | {&quot;node&quot;: &quot;4&quot;, &quot;input&quot;: {&quot;data&quot;: 0}, &quot;output&quot;: {&quot;another data&quot;: 3, &quot;data&quot;: 4}} Free buffer | {&quot;id&quot;: 0} Run node | {&quot;node&quot;: &quot;5&quot;, &quot;input&quot;: {&quot;data 1&quot;: 1, &quot;data 2&quot;: 2}, &quot;output&quot;: {&quot;data&quot;: 0}} Free buffer | {&quot;id&quot;: 1} Free buffer | {&quot;id&quot;: 2} Run node | {&quot;node&quot;: &quot;6&quot;, &quot;input&quot;: {&quot;data&quot;: 4}, &quot;output&quot;: {&quot;data&quot;: 1}} Free buffer | {&quot;id&quot;: 4} Run node | {&quot;node&quot;: &quot;7&quot;, &quot;input&quot;: {&quot;data&quot;: 3}, &quot;output&quot;: {&quot;data&quot;: 2}} Free buffer | {&quot;id&quot;: 3} Run node | {&quot;node&quot;: &quot;8&quot;, &quot;input&quot;: {&quot;data&quot;: 0}, &quot;output&quot;: {&quot;data&quot;: 3}} Free buffer | {&quot;id&quot;: 0} Run node | {&quot;node&quot;: &quot;9&quot;, &quot;input&quot;: {&quot;data&quot;: 1}, &quot;output&quot;: {&quot;data&quot;: 0}} Free buffer | {&quot;id&quot;: 1} Run node | {&quot;node&quot;: &quot;10&quot;, &quot;input&quot;: {&quot;data 1&quot;: 2, &quot;data 2&quot;: 3}, &quot;output&quot;: {&quot;data&quot;: 1}} Free buffer | {&quot;id&quot;: 2} Free buffer | {&quot;id&quot;: 3} Run node | {&quot;node&quot;: &quot;11&quot;, &quot;input&quot;: {&quot;data 1&quot;: 0, &quot;data 2&quot;: 1}, &quot;output&quot;: {&quot;data&quot;: 2}} Export node data | {&quot;from&quot;: 2, &quot;node&quot;: &quot;11&quot;, &quot;output_name&quot;: &quot;data&quot;} As you can see, it’s a bit unoptimal: there’s no need to free buffers at the end of execution, potentially too many buffers allocated, but that’s why it’s called “naive”: it does the thing the simplest way possible. Real planning and memory management Now, that’s really complicated. Each node can have multiple inputs and multiple outputs. Not only that, node behaviour per-input and per-output might be different depending on the implementation: Destructively put output to one of input buffers thus losing all the original data stored in input buffer. Generating such output does not require additional “output” buffer. Non-destructively put output to a new buffer. While original values are not overritten and could be used in another node, this will require additional buffer for that output. Both situations depending on requested outputs for a single node. The exact behaviour should then be described in node spec. That makes things messed up, because if, for example, there’re two nodes using some output destructively, the system should make a copy of an output to another buffer. If, on the other hand, no nodes use some output destructively, after all non-destructive nodes using the output are done, that output buffer should be reused. For now I do not have enough time to come up with appropriate solution, please use the “naive” one that does not support destructive nodes. TBD Do something on parallelization Support finite non-conditional (enumerated) loops.</summary></entry><entry xml:lang="en"><title type="html">Emacs on Windows</title><link href="https://ivalentinee.github.io/en/programming/2021/09/24/emacs-on-windows.html" rel="alternate" type="text/html" title="Emacs on Windows" /><published>2021-09-24T00:00:00+00:00</published><updated>2021-09-24T00:00:00+00:00</updated><id>https://ivalentinee.github.io/en/programming/2021/09/24/emacs-on-windows</id><content type="html" xml:base="https://ivalentinee.github.io/en/programming/2021/09/24/emacs-on-windows.html">&lt;h2 id=&quot;how-did-i-get-there&quot;&gt;How did I get there&lt;/h2&gt;
&lt;p&gt;Due to job change I had to buy a new laptop (I had to give laptop from my previous job back).&lt;br /&gt;
Requirements for the new laptop were pretty clear: 16G RAM, 512G SSD and — that was the worst — it has to be able to run linux without too much hassle.&lt;br /&gt;
Since my old Lenovo Carbon (4th gen I suppose) worked for many years without any problem the choice was simple and I got another Lenovo Carbon (9 gen).&lt;/p&gt;

&lt;p&gt;When my new laptop arrived I logged into Windows 10 Pro (OEM) and… decided to keep Windows. Why? This laptop (suddenly!) had touchscreen, fingerprint scanner, power modes to let battery last longer… Well, I didn’t want to make it all work on Linux, but wanted to use all these features.&lt;/p&gt;

&lt;p&gt;I got WSL2, Docker and &lt;a href=&quot;https://emacsredux.com/blog/2020/09/23/using-emacs-on-windows-with-wsl2/&quot;&gt;Emacs on WSL2&lt;/a&gt; working in two days so I was able to go around my day job.&lt;/p&gt;

&lt;p&gt;A month later I had to download lots of files, edit them and send back. As almost all applications (apart from Docker and Emacs) were running on Windows using WSL emacs was not very convenient. So I decided to make Emacs work on Windows. As most of my questions took some hours to google answers I decided to put these answers here.&lt;/p&gt;

&lt;h2 id=&quot;installing&quot;&gt;Installing&lt;/h2&gt;
&lt;p&gt;That’s the easiest part: go to &lt;a href=&quot;https://www.gnu.org/software/emacs/&quot;&gt;https://www.gnu.org/software/emacs/&lt;/a&gt;, download, install.&lt;/p&gt;

&lt;h2 id=&quot;configuring&quot;&gt;Configuring&lt;/h2&gt;
&lt;p&gt;Emacs by default looks for configuration not in &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\&amp;lt;Username&amp;gt;&lt;/code&gt; but in &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\&amp;lt;Username&amp;gt;\AppData\Roaming&lt;/code&gt;. So that’s where we put it.&lt;/p&gt;

&lt;p&gt;As I keep emacs dotfiles in Git I cloned my repo to &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\&amp;lt;Username&amp;gt;\Code\emacs_config&lt;/code&gt; and made symbolic links in PowerShell (as Administrator):&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; C:\Users\Valen&amp;gt; mkdir .emacs.d
 C:\Users\Valen&amp;gt; New-Item -ItemType SymbolicLink -Path C:\Users\Valen\ -Name .emacs -Value 'C:\Users\Valen\Code\emacs_config\.emacs'
 C:\Users\Valen&amp;gt; New-Item -ItemType SymbolicLink -Path C:\Users\Valen\.emacs.d\ -Name settings -Value 'C:\Users\Valen\Code\emacs_config\.emacs.d\settings'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;changing-home-folder&quot;&gt;Changing HOME folder&lt;/h2&gt;
&lt;p&gt;As Emacs looks for home in &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\&amp;lt;Username&amp;gt;\AppData\Roaming&lt;/code&gt; finding files is not very convenient (getting back to &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\&amp;lt;Username&amp;gt;&lt;/code&gt; every time). There’re few ways to fix this:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Set HOME in Windows
Not my thing, ‘cause fighting Windows to set HOME is too painful to me&lt;/li&gt;
  &lt;li&gt;Set HOME in Emacs
That’s my thing!&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To do this I put this code at the end of .emacs:&lt;/p&gt;
&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;string=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;system-type&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;windows-nt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;setenv&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;HOME&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C:\\Users\\Valen&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;emacs-daemon-and-emacsclient&quot;&gt;emacs –daemon and emacsclient&lt;/h2&gt;
&lt;p&gt;It took me about two hours to google answers for that, so this section (I think) is the most valuable.&lt;/p&gt;

&lt;p&gt;First, I wanted to use emacsclient ‘cause in 2021 it takes emacs inexcusibly long time to start.&lt;br /&gt;
Second, I’d like not to lauch &lt;code class=&quot;highlighter-rouge&quot;&gt;emacs --daemon&lt;/code&gt; at system start. That’s just me.&lt;/p&gt;

&lt;p&gt;I found this solution: run emacs with &lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt; option (which starts alternative editor if emacsclient fails to start) with empty value which causes emacsclient to start &lt;code class=&quot;highlighter-rouge&quot;&gt;emacs --daemon&lt;/code&gt; and connect to it.&lt;/p&gt;

&lt;p&gt;To make this work I had to delete &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\Valen\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Emacs-&amp;lt;version&amp;gt;&lt;/code&gt; which had shortcuts created by emacs installer.
Next I created shortcut &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\Valen\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Emacs&lt;/code&gt; and set &lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt; attribute to this:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;C:\Program Files\Emacs\x86_64\bin\emacsclient.exe&quot; -c -n -f &quot;c:\Users\Valen\.emacs.d\server\server&quot; -a=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Where &lt;code class=&quot;highlighter-rouge&quot;&gt;-f &quot;c:\Users\Valen\.emacs.d\server\server&quot;&lt;/code&gt; points to daemon socket. Remember we changed HOME? That has consequences.&lt;/p&gt;

&lt;h2 id=&quot;adopting-emacs-configuration&quot;&gt;Adopting emacs configuration&lt;/h2&gt;
&lt;p&gt;Emacs config from Linux didn’t allow Emacs to start normally, so I had to fix it.&lt;/p&gt;

&lt;p&gt;Specifically, I had to turn off pinentry integration (it makes no sense on Windows anyway):&lt;/p&gt;
&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;string=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;system-type&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gnu/linux&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;progn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;setenv&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;INSIDE_EMACS&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;%s,comint&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;emacs-version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;setq&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;epa-pinentry-mode&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;'loopback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pinentry-start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;powershell&quot;&gt;PowerShell&lt;/h2&gt;
&lt;p&gt;Cmd was not an option, so I had to make PowerShell work in shell-mode:&lt;/p&gt;
&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;string=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;system-type&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;windows-nt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;setq&lt;/span&gt;
     &lt;span class=&quot;nv&quot;&gt;shell-file-name&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot;&lt;/span&gt;
     &lt;span class=&quot;nv&quot;&gt;explicit-powershell.exe-args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-InputFormat&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Text&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;-NoLogo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Autocompletition doesn’t work though.&lt;/p&gt;

&lt;h2 id=&quot;what-else&quot;&gt;What else?&lt;/h2&gt;
&lt;p&gt;Well, neither grep nor silversearcher-ag are easy to install for PowerShell which is sad.&lt;br /&gt;
And I didn’t bother wit git integration because I don’t write too much code on Windows.&lt;/p&gt;

&lt;h2 id=&quot;small-recap&quot;&gt;Small recap&lt;/h2&gt;
&lt;p&gt;In WSL2 it (Emacs) still runs faster and is easier to use. So I ended up making &lt;code class=&quot;highlighter-rouge&quot;&gt;/mnt/c/Users/Valen → ~/winhome&lt;/code&gt; symlink ans use Emacs on WSL.&lt;/p&gt;

&lt;p&gt;And yeah, I saw Surface Laptop Studio announce and now I regret that I got Lenovo Carbon. But at least it was a way to know that development on Windows (with WSL) works pretty well (so I don’t need Linux as host system).&lt;/p&gt;</content><author><name></name></author><summary type="html">How did I get there Due to job change I had to buy a new laptop (I had to give laptop from my previous job back). Requirements for the new laptop were pretty clear: 16G RAM, 512G SSD and — that was the worst — it has to be able to run linux without too much hassle. Since my old Lenovo Carbon (4th gen I suppose) worked for many years without any problem the choice was simple and I got another Lenovo Carbon (9 gen). When my new laptop arrived I logged into Windows 10 Pro (OEM) and… decided to keep Windows. Why? This laptop (suddenly!) had touchscreen, fingerprint scanner, power modes to let battery last longer… Well, I didn’t want to make it all work on Linux, but wanted to use all these features. I got WSL2, Docker and Emacs on WSL2 working in two days so I was able to go around my day job. A month later I had to download lots of files, edit them and send back. As almost all applications (apart from Docker and Emacs) were running on Windows using WSL emacs was not very convenient. So I decided to make Emacs work on Windows. As most of my questions took some hours to google answers I decided to put these answers here. Installing That’s the easiest part: go to https://www.gnu.org/software/emacs/, download, install. Configuring Emacs by default looks for configuration not in C:\Users\&amp;lt;Username&amp;gt; but in C:\Users\&amp;lt;Username&amp;gt;\AppData\Roaming. So that’s where we put it. As I keep emacs dotfiles in Git I cloned my repo to C:\Users\&amp;lt;Username&amp;gt;\Code\emacs_config and made symbolic links in PowerShell (as Administrator): C:\Users\Valen&amp;gt; mkdir .emacs.d C:\Users\Valen&amp;gt; New-Item -ItemType SymbolicLink -Path C:\Users\Valen\ -Name .emacs -Value 'C:\Users\Valen\Code\emacs_config\.emacs' C:\Users\Valen&amp;gt; New-Item -ItemType SymbolicLink -Path C:\Users\Valen\.emacs.d\ -Name settings -Value 'C:\Users\Valen\Code\emacs_config\.emacs.d\settings' Changing HOME folder As Emacs looks for home in C:\Users\&amp;lt;Username&amp;gt;\AppData\Roaming finding files is not very convenient (getting back to C:\Users\&amp;lt;Username&amp;gt; every time). There’re few ways to fix this: Set HOME in Windows Not my thing, ‘cause fighting Windows to set HOME is too painful to me Set HOME in Emacs That’s my thing! To do this I put this code at the end of .emacs: (if (string= system-type &quot;windows-nt&quot;) (setenv &quot;HOME&quot; &quot;C:\\Users\\Valen&quot;)) emacs –daemon and emacsclient It took me about two hours to google answers for that, so this section (I think) is the most valuable. First, I wanted to use emacsclient ‘cause in 2021 it takes emacs inexcusibly long time to start. Second, I’d like not to lauch emacs --daemon at system start. That’s just me. I found this solution: run emacs with -a option (which starts alternative editor if emacsclient fails to start) with empty value which causes emacsclient to start emacs --daemon and connect to it. To make this work I had to delete C:\Users\Valen\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Emacs-&amp;lt;version&amp;gt; which had shortcuts created by emacs installer. Next I created shortcut C:\Users\Valen\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Emacs and set target attribute to this: &quot;C:\Program Files\Emacs\x86_64\bin\emacsclient.exe&quot; -c -n -f &quot;c:\Users\Valen\.emacs.d\server\server&quot; -a= Where -f &quot;c:\Users\Valen\.emacs.d\server\server&quot; points to daemon socket. Remember we changed HOME? That has consequences. Adopting emacs configuration Emacs config from Linux didn’t allow Emacs to start normally, so I had to fix it. Specifically, I had to turn off pinentry integration (it makes no sense on Windows anyway): (if (string= system-type &quot;gnu/linux&quot;) (progn (setenv &quot;INSIDE_EMACS&quot; (format &quot;%s,comint&quot; emacs-version)) (setq epa-pinentry-mode 'loopback) (pinentry-start))) PowerShell Cmd was not an option, so I had to make PowerShell work in shell-mode: (if (string= system-type &quot;windows-nt&quot;) (setq shell-file-name &quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot; explicit-powershell.exe-args '(&quot;-InputFormat&quot; &quot;Text&quot; &quot;-NoLogo&quot;))) Autocompletition doesn’t work though. What else? Well, neither grep nor silversearcher-ag are easy to install for PowerShell which is sad. And I didn’t bother wit git integration because I don’t write too much code on Windows. Small recap In WSL2 it (Emacs) still runs faster and is easier to use. So I ended up making /mnt/c/Users/Valen → ~/winhome symlink ans use Emacs on WSL. And yeah, I saw Surface Laptop Studio announce and now I regret that I got Lenovo Carbon. But at least it was a way to know that development on Windows (with WSL) works pretty well (so I don’t need Linux as host system).</summary></entry><entry xml:lang="ru"><title type="html">Emacs в Windows</title><link href="https://ivalentinee.github.io/ru/programming/2021/09/24/emacs-on-windows.html" rel="alternate" type="text/html" title="Emacs в Windows" /><published>2021-09-24T00:00:00+00:00</published><updated>2021-09-24T00:00:00+00:00</updated><id>https://ivalentinee.github.io/ru/programming/2021/09/24/emacs-on-windows</id><content type="html" xml:base="https://ivalentinee.github.io/ru/programming/2021/09/24/emacs-on-windows.html">&lt;h2 id=&quot;как-же-я-дошёл-до-жизни-такой&quot;&gt;Как же я дошёл до жизни такой?&lt;/h2&gt;
&lt;p&gt;В связи со сменой работы мне пришлось взять новый ноут (корпоративный забрали).&lt;br /&gt;
Требования к ноуту у меня были достаточно понятные: 16 гиг оперативы, 512 гиг жёсткого диска (или больше) и — это самое противное — чтобы на нём завёлся Linux без особых танцев.&lt;br /&gt;
Я не очень долго выбирал, потому что несколько лет работал на Lenovo X1 Carbon (вроде как 4 поколения), взяв Lenovo X1 Carbon но уже 9 поколения.&lt;/p&gt;

&lt;p&gt;Когда мне пришёл ноут, я запустил Windows 10 Pro, которая шла в комплекте, и … решил не ставить Linux. Почему? Потому что тут внезапно(!) оказался тачскрин, работающий сканер отпечатков пальцев, профили питания для экономии батареи… Короче, я понял, что заводить всё это в лялихе мне неохота, а отказываться от таких удобств чисто ради виндекапца я не готов.&lt;/p&gt;

&lt;p&gt;Настроил за пару дней WSL2, Docker, &lt;a href=&quot;https://emacsredux.com/blog/2020/09/23/using-emacs-on-windows-with-wsl2/&quot;&gt;Emacs&lt;/a&gt;, всё завелось, я смог работать.&lt;/p&gt;

&lt;p&gt;Но тут по работе пришлось скачивать кучу файлов, смотреть/редактировать их, затем отправлять назад. Так как все приложения кроме докера и Emacs’а у меня запущены в винде, открывать всё это в Emacs, который работает изнутри WSL не очень удобно. Я решил попробовать запустить Emacs в винде. Так как на многие мои вопросы ответы в интернете ищутся не по первой ссылке, я решил часть всего этого описать тут.&lt;/p&gt;

&lt;h2 id=&quot;установка&quot;&gt;Установка&lt;/h2&gt;
&lt;p&gt;Ну тут всё просто: идём на сайт &lt;a href=&quot;https://www.gnu.org/software/emacs/&quot;&gt;https://www.gnu.org/software/emacs/&lt;/a&gt;, качаем, ставим.&lt;/p&gt;

&lt;h2 id=&quot;складываем-конфиги&quot;&gt;Складываем конфиги&lt;/h2&gt;
&lt;p&gt;По-умолчанию Emacs ищет конфиги не в &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\&amp;lt;Username&amp;gt;&lt;/code&gt;, а в &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\&amp;lt;Username&amp;gt;\AppData\Roaming&lt;/code&gt;. Туда их и сложим, чтобы не извращаться с особенностями винды.&lt;/p&gt;

&lt;p&gt;Так как я держу конфиги в Git, я склонировал репозиторий в &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\&amp;lt;Username&amp;gt;\Code\emacs_config&lt;/code&gt;, а затем сделал символические ссылки в PowerShell (запущенном под админом):&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; C:\Users\Valen&amp;gt; mkdir .emacs.d
 C:\Users\Valen&amp;gt; New-Item -ItemType SymbolicLink -Path C:\Users\Valen\ -Name .emacs -Value 'C:\Users\Valen\Code\emacs_config\.emacs'
 C:\Users\Valen&amp;gt; New-Item -ItemType SymbolicLink -Path C:\Users\Valen\.emacs.d\ -Name settings -Value 'C:\Users\Valen\Code\emacs_config\.emacs.d\settings'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;меняем-домашнюю-директорию&quot;&gt;Меняем домашнюю директорию&lt;/h2&gt;
&lt;p&gt;Так как emacs по-умолчанию считает домашней директорией &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\&amp;lt;Username&amp;gt;\AppData\Roaming&lt;/code&gt;, открывать файлы в emacs не очень удобно (нужно постоянно возвращаться в &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\&amp;lt;Username&amp;gt;&lt;/code&gt;). Чтобы с этим побороться есть несколько способов:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Перенастроить переменную HOME&lt;br /&gt;
Не мой вариант, потому что мне лень возиться с тем, чтобы объяснять Emacs’у, где у него HOME из винды&lt;/li&gt;
  &lt;li&gt;Переопределить переменную HOME&lt;br /&gt;
Вот это мой варик, тут мне всё понятно&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Для этого в конец .emacs дописываем следующий код:&lt;/p&gt;
&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;string=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;system-type&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;windows-nt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;setenv&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;HOME&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C:\\Users\\Valen&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;emacs-daemon-и-emacsclient&quot;&gt;emacs –daemon и emacsclient&lt;/h2&gt;
&lt;p&gt;Я достаточно долго (пару часов) гуглил, чтобы решить ряд непонятных ошибок, поэтому в этом разделе, думаю, самое ценное.&lt;/p&gt;

&lt;p&gt;Во-первых, мне бы хотелось пользоваться emacsclient, потому что в 2021 году emacs всё ещё стартует непозволительно долго.&lt;br /&gt;
Во-вторых, мне не хотелось запускать &lt;code class=&quot;highlighter-rouge&quot;&gt;emacs --daemon&lt;/code&gt; при каждом старте системы. Ну просто потому что.&lt;/p&gt;

&lt;p&gt;Выход я нашёл следующий: если запускать emacsclient с ключом &lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt; (который запускает альтернативный редактор, если emacsclient не запустился) равным пустой строке, то emacsclient сам пытается запустить &lt;code class=&quot;highlighter-rouge&quot;&gt;emacs --daemon&lt;/code&gt; и подключиться к нему. Наш вариант!&lt;/p&gt;

&lt;p&gt;Для того, чтобы это всё заработало, надо удалить папку &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\Valen\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Emacs-&amp;lt;version&amp;gt;&lt;/code&gt;, в которой находятся ярлыки, созданные при установке Emacs.&lt;/p&gt;

&lt;p&gt;Далее в папке &lt;code class=&quot;highlighter-rouge&quot;&gt;C:\Users\Valen\AppData\Roaming\Microsoft\Windows\Start Menu\Programs&lt;/code&gt; нужно создать ярлык с названием Emacs и в свойстве &lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt; указать следующее:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;C:\Program Files\Emacs\x86_64\bin\emacsclient.exe&quot; -c -n -f &quot;c:\Users\Valen\.emacs.d\server\server&quot; -a=
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Где &lt;code class=&quot;highlighter-rouge&quot;&gt;-f &quot;c:\Users\Valen\.emacs.d\server\server&quot;&lt;/code&gt; указывает на файл сокета. Помните, мы меняли домашнюю директорию? Так вот да, есть последствия.&lt;/p&gt;

&lt;h2 id=&quot;перенастройка&quot;&gt;Перенастройка&lt;/h2&gt;
&lt;p&gt;Linux’овый конфиг Emacs’а не давал нормально запускаться. Пришлось искать и лечить.&lt;/p&gt;

&lt;p&gt;В частности, пришлось отключить pinentry-интеграция (в винде она всё равно не актуальна):&lt;/p&gt;
&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;string=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;system-type&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gnu/linux&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;progn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;setenv&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;INSIDE_EMACS&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;%s,comint&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;emacs-version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;setq&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;epa-pinentry-mode&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;'loopback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;pinentry-start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;powershell&quot;&gt;PowerShell&lt;/h2&gt;
&lt;p&gt;Для полного счастья не хватало только PowerShell в shell-mode. Делается это добавлением следующего в конфиг Emacs:&lt;/p&gt;
&lt;div class=&quot;language-elisp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;string=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;system-type&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;windows-nt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;setq&lt;/span&gt;
     &lt;span class=&quot;nv&quot;&gt;shell-file-name&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot;&lt;/span&gt;
     &lt;span class=&quot;nv&quot;&gt;explicit-powershell.exe-args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-InputFormat&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Text&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;-NoLogo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Правда, автодополнение не завелось пока что.&lt;/p&gt;

&lt;h2 id=&quot;что-ещё&quot;&gt;Что ещё?&lt;/h2&gt;
&lt;p&gt;Очевидно, не завелись ни grep, ни silversearcher-ag, что печалит. Но наверняка найдётся выход и из этого положения.&lt;br /&gt;
Плюс я не занимался вопросом интеграции с git, потому что, очевидно, под виндой не занимаюсь написанием кода.&lt;/p&gt;

&lt;h2 id=&quot;небольшое-заключение&quot;&gt;Небольшое заключение&lt;/h2&gt;
&lt;p&gt;В WSL2 он (Emacs) всё ещё работает быстрее а пользоваться им удобнее. Поэтому я всё-таки сделал symlink &lt;code class=&quot;highlighter-rouge&quot;&gt;/mnt/c/Users/Valen → ~/winhome&lt;/code&gt; и пользуюсь WSL’ным.&lt;/p&gt;

&lt;p&gt;А, да, на днях вышел анонс Surface Laptop Studio, так что я пожалел, что взял Lenovo Carbon. Но теперь я знаю, что на винде есть жизнь.&lt;/p&gt;</content><author><name></name></author><summary type="html">Как же я дошёл до жизни такой? В связи со сменой работы мне пришлось взять новый ноут (корпоративный забрали). Требования к ноуту у меня были достаточно понятные: 16 гиг оперативы, 512 гиг жёсткого диска (или больше) и — это самое противное — чтобы на нём завёлся Linux без особых танцев. Я не очень долго выбирал, потому что несколько лет работал на Lenovo X1 Carbon (вроде как 4 поколения), взяв Lenovo X1 Carbon но уже 9 поколения. Когда мне пришёл ноут, я запустил Windows 10 Pro, которая шла в комплекте, и … решил не ставить Linux. Почему? Потому что тут внезапно(!) оказался тачскрин, работающий сканер отпечатков пальцев, профили питания для экономии батареи… Короче, я понял, что заводить всё это в лялихе мне неохота, а отказываться от таких удобств чисто ради виндекапца я не готов. Настроил за пару дней WSL2, Docker, Emacs, всё завелось, я смог работать. Но тут по работе пришлось скачивать кучу файлов, смотреть/редактировать их, затем отправлять назад. Так как все приложения кроме докера и Emacs’а у меня запущены в винде, открывать всё это в Emacs, который работает изнутри WSL не очень удобно. Я решил попробовать запустить Emacs в винде. Так как на многие мои вопросы ответы в интернете ищутся не по первой ссылке, я решил часть всего этого описать тут. Установка Ну тут всё просто: идём на сайт https://www.gnu.org/software/emacs/, качаем, ставим. Складываем конфиги По-умолчанию Emacs ищет конфиги не в C:\Users\&amp;lt;Username&amp;gt;, а в C:\Users\&amp;lt;Username&amp;gt;\AppData\Roaming. Туда их и сложим, чтобы не извращаться с особенностями винды. Так как я держу конфиги в Git, я склонировал репозиторий в C:\Users\&amp;lt;Username&amp;gt;\Code\emacs_config, а затем сделал символические ссылки в PowerShell (запущенном под админом): C:\Users\Valen&amp;gt; mkdir .emacs.d C:\Users\Valen&amp;gt; New-Item -ItemType SymbolicLink -Path C:\Users\Valen\ -Name .emacs -Value 'C:\Users\Valen\Code\emacs_config\.emacs' C:\Users\Valen&amp;gt; New-Item -ItemType SymbolicLink -Path C:\Users\Valen\.emacs.d\ -Name settings -Value 'C:\Users\Valen\Code\emacs_config\.emacs.d\settings' Меняем домашнюю директорию Так как emacs по-умолчанию считает домашней директорией C:\Users\&amp;lt;Username&amp;gt;\AppData\Roaming, открывать файлы в emacs не очень удобно (нужно постоянно возвращаться в C:\Users\&amp;lt;Username&amp;gt;). Чтобы с этим побороться есть несколько способов: Перенастроить переменную HOME Не мой вариант, потому что мне лень возиться с тем, чтобы объяснять Emacs’у, где у него HOME из винды Переопределить переменную HOME Вот это мой варик, тут мне всё понятно Для этого в конец .emacs дописываем следующий код: (if (string= system-type &quot;windows-nt&quot;) (setenv &quot;HOME&quot; &quot;C:\\Users\\Valen&quot;)) emacs –daemon и emacsclient Я достаточно долго (пару часов) гуглил, чтобы решить ряд непонятных ошибок, поэтому в этом разделе, думаю, самое ценное. Во-первых, мне бы хотелось пользоваться emacsclient, потому что в 2021 году emacs всё ещё стартует непозволительно долго. Во-вторых, мне не хотелось запускать emacs --daemon при каждом старте системы. Ну просто потому что. Выход я нашёл следующий: если запускать emacsclient с ключом -a (который запускает альтернативный редактор, если emacsclient не запустился) равным пустой строке, то emacsclient сам пытается запустить emacs --daemon и подключиться к нему. Наш вариант! Для того, чтобы это всё заработало, надо удалить папку C:\Users\Valen\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Emacs-&amp;lt;version&amp;gt;, в которой находятся ярлыки, созданные при установке Emacs. Далее в папке C:\Users\Valen\AppData\Roaming\Microsoft\Windows\Start Menu\Programs нужно создать ярлык с названием Emacs и в свойстве target указать следующее: &quot;C:\Program Files\Emacs\x86_64\bin\emacsclient.exe&quot; -c -n -f &quot;c:\Users\Valen\.emacs.d\server\server&quot; -a= Где -f &quot;c:\Users\Valen\.emacs.d\server\server&quot; указывает на файл сокета. Помните, мы меняли домашнюю директорию? Так вот да, есть последствия. Перенастройка Linux’овый конфиг Emacs’а не давал нормально запускаться. Пришлось искать и лечить. В частности, пришлось отключить pinentry-интеграция (в винде она всё равно не актуальна): (if (string= system-type &quot;gnu/linux&quot;) (progn (setenv &quot;INSIDE_EMACS&quot; (format &quot;%s,comint&quot; emacs-version)) (setq epa-pinentry-mode 'loopback) (pinentry-start))) PowerShell Для полного счастья не хватало только PowerShell в shell-mode. Делается это добавлением следующего в конфиг Emacs: (if (string= system-type &quot;windows-nt&quot;) (setq shell-file-name &quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot; explicit-powershell.exe-args '(&quot;-InputFormat&quot; &quot;Text&quot; &quot;-NoLogo&quot;))) Правда, автодополнение не завелось пока что. Что ещё? Очевидно, не завелись ни grep, ни silversearcher-ag, что печалит. Но наверняка найдётся выход и из этого положения. Плюс я не занимался вопросом интеграции с git, потому что, очевидно, под виндой не занимаюсь написанием кода. Небольшое заключение В WSL2 он (Emacs) всё ещё работает быстрее а пользоваться им удобнее. Поэтому я всё-таки сделал symlink /mnt/c/Users/Valen → ~/winhome и пользуюсь WSL’ным. А, да, на днях вышел анонс Surface Laptop Studio, так что я пожалел, что взял Lenovo Carbon. Но теперь я знаю, что на винде есть жизнь.</summary></entry></feed>